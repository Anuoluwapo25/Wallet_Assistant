import {
  require_elliptic
} from "./chunk-A6QULM34.js";
import {
  AbstractWallet,
  ENTRYPOINT_ADDRESS,
  ERC6551_REGISTRY,
  checkContractWalletSignature,
  getAnalyticsHeaders,
  require_dist
} from "./chunk-4FXYU36F.js";
import {
  getInjectedMagicEdenProvider
} from "./chunk-3SKRXWUN.js";
import {
  getInjectedXDEFIProvider
} from "./chunk-GGII2DOJ.js";
import {
  getInjectedPhantomProvider
} from "./chunk-BGCQ64CW.js";
import {
  getInjectedRainbowProvider
} from "./chunk-SQHU4NWU.js";
import {
  getInjectedCryptoDefiWalletProvider
} from "./chunk-7ZTRRMDX.js";
import {
  getInjectedRabbyProvider
} from "./chunk-M5HHJ5TL.js";
import {
  getInjectedCoin98Provider
} from "./chunk-H7BIURJ6.js";
import {
  getInjectedMetamaskProvider
} from "./chunk-R3IZTCGT.js";
import {
  A,
  Br,
  C,
  E,
  IEvents,
  Po,
  Qe,
  Qo,
  clear,
  createStore,
  del,
  destr,
  detect,
  esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  get,
  getBigIntRpcId,
  import_pino,
  init_esm,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  isLocalhostUrl,
  isWsUrl,
  k,
  keys,
  parseConnectionError,
  payloadId,
  r,
  require_binary,
  require_browser,
  require_chacha20poly1305,
  require_cjs,
  require_cjs2,
  require_cjs3,
  require_hkdf,
  require_lodash,
  require_query_string,
  require_random,
  require_sha256,
  require_wipe,
  require_x25519,
  safeJsonParse,
  safeJsonStringify,
  set,
  sn,
  y
} from "./chunk-NY2HE5IQ.js";
import {
  getInjectedOKXProvider
} from "./chunk-SRRH4CRM.js";
import {
  getInjectedCoreWalletProvider
} from "./chunk-GQWRI7QN.js";
import {
  getInjectedOneKeyProvider
} from "./chunk-TFMZQD2J.js";
import {
  ThirdwebSDK
} from "./chunk-GBYOH3OX.js";
import {
  WagmiAdapter
} from "./chunk-UCYGK4C7.js";
import {
  walletIds
} from "./chunk-KOCNAQFC.js";
import {
  assertWindowEthereum
} from "./chunk-RKAC5DGX.js";
import {
  _defineProperty
} from "./chunk-EKYLSAGW.js";
import {
  require_events
} from "./chunk-XAZ6AATU.js";
import {
  aesDecryptCompat,
  aesEncrypt,
  getChainProvider,
  isContractDeployed
} from "./chunk-HYU4DDVV.js";
import {
  require_utils
} from "./chunk-LZRVQWU5.js";
import {
  bases,
  init_basics
} from "./chunk-44IMT2VJ.js";
import {
  c1,
  defaultChains,
  getValidChainRPCs,
  updateChainRPCs
} from "./chunk-DBUC3OVX.js";
import {
  eventemitter3_default,
  init_eventemitter3
} from "./chunk-LYKHSI7P.js";
import {
  require_buffer
} from "./chunk-FSHJLBLG.js";
import {
  Wallet,
  ethers_exports,
  init_lib7 as init_lib3,
  utils_exports
} from "./chunk-ICVCM4I6.js";
import {
  BigNumber,
  hashMessage,
  init_lib11 as init_lib,
  init_lib15 as init_lib2,
  recoverAddress
} from "./chunk-FZ2VX2UM.js";
import {
  __commonJS,
  __toESM
} from "./chunk-MVEJMUOB.js";

// node_modules/@walletconnect/jsonrpc-ws-connection/node_modules/ws/browser.js
var require_browser2 = __commonJS({
  "node_modules/@walletconnect/jsonrpc-ws-connection/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@stablelib/sha512/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@stablelib/sha512/lib/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 64;
    exports.BLOCK_SIZE = 128;
    var SHA512 = (
      /** @class */
      function() {
        function SHA5122() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._stateHi = new Int32Array(8);
          this._stateLo = new Int32Array(8);
          this._tempHi = new Int32Array(16);
          this._tempLo = new Int32Array(16);
          this._buffer = new Uint8Array(256);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA5122.prototype._initState = function() {
          this._stateHi[0] = 1779033703;
          this._stateHi[1] = 3144134277;
          this._stateHi[2] = 1013904242;
          this._stateHi[3] = 2773480762;
          this._stateHi[4] = 1359893119;
          this._stateHi[5] = 2600822924;
          this._stateHi[6] = 528734635;
          this._stateHi[7] = 1541459225;
          this._stateLo[0] = 4089235720;
          this._stateLo[1] = 2227873595;
          this._stateLo[2] = 4271175723;
          this._stateLo[3] = 1595750129;
          this._stateLo[4] = 2917565137;
          this._stateLo[5] = 725511199;
          this._stateLo[6] = 4215389547;
          this._stateLo[7] = 327033209;
        };
        SHA5122.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._tempHi);
          wipe_1.wipe(this._tempLo);
          this.reset();
        };
        SHA5122.prototype.update = function(data, dataLength) {
          if (dataLength === void 0) {
            dataLength = data.length;
          }
          if (this._finished) {
            throw new Error("SHA512: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
              this._buffer[this._bufferLength++] = data[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA5122.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 128 < 112 ? 128 : 256;
            this._buffer[left] = 128;
            for (var i3 = left + 1; i3 < padLength - 8; i3++) {
              this._buffer[i3] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i3 = 0; i3 < this.digestLength / 8; i3++) {
            binary_1.writeUint32BE(this._stateHi[i3], out, i3 * 8);
            binary_1.writeUint32BE(this._stateLo[i3], out, i3 * 8 + 4);
          }
          return this;
        };
        SHA5122.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA5122.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA5122.prototype.restoreState = function(savedState) {
          this._stateHi.set(savedState.stateHi);
          this._stateLo.set(savedState.stateLo);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.stateHi);
          wipe_1.wipe(savedState.stateLo);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA5122;
      }()
    );
    exports.SHA512 = SHA512;
    var K8 = new Int32Array([
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ]);
    function hashBlocks(wh2, wl, hh2, hl, m2, pos, len) {
      var ah0 = hh2[0], ah1 = hh2[1], ah2 = hh2[2], ah3 = hh2[3], ah4 = hh2[4], ah5 = hh2[5], ah6 = hh2[6], ah7 = hh2[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var h7, l7;
      var th, tl;
      var a5, b6, c7, d5;
      while (len >= 128) {
        for (var i3 = 0; i3 < 16; i3++) {
          var j7 = 8 * i3 + pos;
          wh2[i3] = binary_1.readUint32BE(m2, j7);
          wl[i3] = binary_1.readUint32BE(m2, j7 + 4);
        }
        for (var i3 = 0; i3 < 80; i3++) {
          var bh0 = ah0;
          var bh1 = ah1;
          var bh2 = ah2;
          var bh3 = ah3;
          var bh4 = ah4;
          var bh5 = ah5;
          var bh6 = ah6;
          var bh7 = ah7;
          var bl0 = al0;
          var bl1 = al1;
          var bl2 = al2;
          var bl3 = al3;
          var bl4 = al4;
          var bl5 = al5;
          var bl6 = al6;
          var bl7 = al7;
          h7 = ah7;
          l7 = al7;
          a5 = l7 & 65535;
          b6 = l7 >>> 16;
          c7 = h7 & 65535;
          d5 = h7 >>> 16;
          h7 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l7 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a5 += l7 & 65535;
          b6 += l7 >>> 16;
          c7 += h7 & 65535;
          d5 += h7 >>> 16;
          h7 = ah4 & ah5 ^ ~ah4 & ah6;
          l7 = al4 & al5 ^ ~al4 & al6;
          a5 += l7 & 65535;
          b6 += l7 >>> 16;
          c7 += h7 & 65535;
          d5 += h7 >>> 16;
          h7 = K8[i3 * 2];
          l7 = K8[i3 * 2 + 1];
          a5 += l7 & 65535;
          b6 += l7 >>> 16;
          c7 += h7 & 65535;
          d5 += h7 >>> 16;
          h7 = wh2[i3 % 16];
          l7 = wl[i3 % 16];
          a5 += l7 & 65535;
          b6 += l7 >>> 16;
          c7 += h7 & 65535;
          d5 += h7 >>> 16;
          b6 += a5 >>> 16;
          c7 += b6 >>> 16;
          d5 += c7 >>> 16;
          th = c7 & 65535 | d5 << 16;
          tl = a5 & 65535 | b6 << 16;
          h7 = th;
          l7 = tl;
          a5 = l7 & 65535;
          b6 = l7 >>> 16;
          c7 = h7 & 65535;
          d5 = h7 >>> 16;
          h7 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l7 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a5 += l7 & 65535;
          b6 += l7 >>> 16;
          c7 += h7 & 65535;
          d5 += h7 >>> 16;
          h7 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l7 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a5 += l7 & 65535;
          b6 += l7 >>> 16;
          c7 += h7 & 65535;
          d5 += h7 >>> 16;
          b6 += a5 >>> 16;
          c7 += b6 >>> 16;
          d5 += c7 >>> 16;
          bh7 = c7 & 65535 | d5 << 16;
          bl7 = a5 & 65535 | b6 << 16;
          h7 = bh3;
          l7 = bl3;
          a5 = l7 & 65535;
          b6 = l7 >>> 16;
          c7 = h7 & 65535;
          d5 = h7 >>> 16;
          h7 = th;
          l7 = tl;
          a5 += l7 & 65535;
          b6 += l7 >>> 16;
          c7 += h7 & 65535;
          d5 += h7 >>> 16;
          b6 += a5 >>> 16;
          c7 += b6 >>> 16;
          d5 += c7 >>> 16;
          bh3 = c7 & 65535 | d5 << 16;
          bl3 = a5 & 65535 | b6 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i3 % 16 === 15) {
            for (var j7 = 0; j7 < 16; j7++) {
              h7 = wh2[j7];
              l7 = wl[j7];
              a5 = l7 & 65535;
              b6 = l7 >>> 16;
              c7 = h7 & 65535;
              d5 = h7 >>> 16;
              h7 = wh2[(j7 + 9) % 16];
              l7 = wl[(j7 + 9) % 16];
              a5 += l7 & 65535;
              b6 += l7 >>> 16;
              c7 += h7 & 65535;
              d5 += h7 >>> 16;
              th = wh2[(j7 + 1) % 16];
              tl = wl[(j7 + 1) % 16];
              h7 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l7 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a5 += l7 & 65535;
              b6 += l7 >>> 16;
              c7 += h7 & 65535;
              d5 += h7 >>> 16;
              th = wh2[(j7 + 14) % 16];
              tl = wl[(j7 + 14) % 16];
              h7 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l7 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a5 += l7 & 65535;
              b6 += l7 >>> 16;
              c7 += h7 & 65535;
              d5 += h7 >>> 16;
              b6 += a5 >>> 16;
              c7 += b6 >>> 16;
              d5 += c7 >>> 16;
              wh2[j7] = c7 & 65535 | d5 << 16;
              wl[j7] = a5 & 65535 | b6 << 16;
            }
          }
        }
        h7 = ah0;
        l7 = al0;
        a5 = l7 & 65535;
        b6 = l7 >>> 16;
        c7 = h7 & 65535;
        d5 = h7 >>> 16;
        h7 = hh2[0];
        l7 = hl[0];
        a5 += l7 & 65535;
        b6 += l7 >>> 16;
        c7 += h7 & 65535;
        d5 += h7 >>> 16;
        b6 += a5 >>> 16;
        c7 += b6 >>> 16;
        d5 += c7 >>> 16;
        hh2[0] = ah0 = c7 & 65535 | d5 << 16;
        hl[0] = al0 = a5 & 65535 | b6 << 16;
        h7 = ah1;
        l7 = al1;
        a5 = l7 & 65535;
        b6 = l7 >>> 16;
        c7 = h7 & 65535;
        d5 = h7 >>> 16;
        h7 = hh2[1];
        l7 = hl[1];
        a5 += l7 & 65535;
        b6 += l7 >>> 16;
        c7 += h7 & 65535;
        d5 += h7 >>> 16;
        b6 += a5 >>> 16;
        c7 += b6 >>> 16;
        d5 += c7 >>> 16;
        hh2[1] = ah1 = c7 & 65535 | d5 << 16;
        hl[1] = al1 = a5 & 65535 | b6 << 16;
        h7 = ah2;
        l7 = al2;
        a5 = l7 & 65535;
        b6 = l7 >>> 16;
        c7 = h7 & 65535;
        d5 = h7 >>> 16;
        h7 = hh2[2];
        l7 = hl[2];
        a5 += l7 & 65535;
        b6 += l7 >>> 16;
        c7 += h7 & 65535;
        d5 += h7 >>> 16;
        b6 += a5 >>> 16;
        c7 += b6 >>> 16;
        d5 += c7 >>> 16;
        hh2[2] = ah2 = c7 & 65535 | d5 << 16;
        hl[2] = al2 = a5 & 65535 | b6 << 16;
        h7 = ah3;
        l7 = al3;
        a5 = l7 & 65535;
        b6 = l7 >>> 16;
        c7 = h7 & 65535;
        d5 = h7 >>> 16;
        h7 = hh2[3];
        l7 = hl[3];
        a5 += l7 & 65535;
        b6 += l7 >>> 16;
        c7 += h7 & 65535;
        d5 += h7 >>> 16;
        b6 += a5 >>> 16;
        c7 += b6 >>> 16;
        d5 += c7 >>> 16;
        hh2[3] = ah3 = c7 & 65535 | d5 << 16;
        hl[3] = al3 = a5 & 65535 | b6 << 16;
        h7 = ah4;
        l7 = al4;
        a5 = l7 & 65535;
        b6 = l7 >>> 16;
        c7 = h7 & 65535;
        d5 = h7 >>> 16;
        h7 = hh2[4];
        l7 = hl[4];
        a5 += l7 & 65535;
        b6 += l7 >>> 16;
        c7 += h7 & 65535;
        d5 += h7 >>> 16;
        b6 += a5 >>> 16;
        c7 += b6 >>> 16;
        d5 += c7 >>> 16;
        hh2[4] = ah4 = c7 & 65535 | d5 << 16;
        hl[4] = al4 = a5 & 65535 | b6 << 16;
        h7 = ah5;
        l7 = al5;
        a5 = l7 & 65535;
        b6 = l7 >>> 16;
        c7 = h7 & 65535;
        d5 = h7 >>> 16;
        h7 = hh2[5];
        l7 = hl[5];
        a5 += l7 & 65535;
        b6 += l7 >>> 16;
        c7 += h7 & 65535;
        d5 += h7 >>> 16;
        b6 += a5 >>> 16;
        c7 += b6 >>> 16;
        d5 += c7 >>> 16;
        hh2[5] = ah5 = c7 & 65535 | d5 << 16;
        hl[5] = al5 = a5 & 65535 | b6 << 16;
        h7 = ah6;
        l7 = al6;
        a5 = l7 & 65535;
        b6 = l7 >>> 16;
        c7 = h7 & 65535;
        d5 = h7 >>> 16;
        h7 = hh2[6];
        l7 = hl[6];
        a5 += l7 & 65535;
        b6 += l7 >>> 16;
        c7 += h7 & 65535;
        d5 += h7 >>> 16;
        b6 += a5 >>> 16;
        c7 += b6 >>> 16;
        d5 += c7 >>> 16;
        hh2[6] = ah6 = c7 & 65535 | d5 << 16;
        hl[6] = al6 = a5 & 65535 | b6 << 16;
        h7 = ah7;
        l7 = al7;
        a5 = l7 & 65535;
        b6 = l7 >>> 16;
        c7 = h7 & 65535;
        d5 = h7 >>> 16;
        h7 = hh2[7];
        l7 = hl[7];
        a5 += l7 & 65535;
        b6 += l7 >>> 16;
        c7 += h7 & 65535;
        d5 += h7 >>> 16;
        b6 += a5 >>> 16;
        c7 += b6 >>> 16;
        d5 += c7 >>> 16;
        hh2[7] = ah7 = c7 & 65535 | d5 << 16;
        hl[7] = al7 = a5 & 65535 | b6 << 16;
        pos += 128;
        len -= 128;
      }
      return pos;
    }
    function hash(data) {
      var h7 = new SHA512();
      h7.update(data);
      var digest = h7.digest();
      h7.clean();
      return digest;
    }
    exports.hash = hash;
  }
});

// node_modules/@stablelib/ed25519/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/@stablelib/ed25519/lib/ed25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertSecretKeyToX25519 = exports.convertPublicKeyToX25519 = exports.verify = exports.sign = exports.extractPublicKeyFromSecretKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.SEED_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = exports.SIGNATURE_LENGTH = void 0;
    var random_1 = require_random();
    var sha512_1 = require_sha512();
    var wipe_1 = require_wipe();
    exports.SIGNATURE_LENGTH = 64;
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 64;
    exports.SEED_LENGTH = 32;
    function gf2(init) {
      const r3 = new Float64Array(16);
      if (init) {
        for (let i3 = 0; i3 < init.length; i3++) {
          r3[i3] = init[i3];
        }
      }
      return r3;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf2();
    var gf1 = gf2([1]);
    var D5 = gf2([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf2([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X2 = gf2([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y6 = gf2([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var I5 = gf2([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function set25519(r3, a5) {
      for (let i3 = 0; i3 < 16; i3++) {
        r3[i3] = a5[i3] | 0;
      }
    }
    function car25519(o4) {
      let c7 = 1;
      for (let i3 = 0; i3 < 16; i3++) {
        let v7 = o4[i3] + c7 + 65535;
        c7 = Math.floor(v7 / 65536);
        o4[i3] = v7 - c7 * 65536;
      }
      o4[0] += c7 - 1 + 37 * (c7 - 1);
    }
    function sel25519(p5, q4, b6) {
      const c7 = ~(b6 - 1);
      for (let i3 = 0; i3 < 16; i3++) {
        const t = c7 & (p5[i3] ^ q4[i3]);
        p5[i3] ^= t;
        q4[i3] ^= t;
      }
    }
    function pack25519(o4, n4) {
      const m2 = gf2();
      const t = gf2();
      for (let i3 = 0; i3 < 16; i3++) {
        t[i3] = n4[i3];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (let j7 = 0; j7 < 2; j7++) {
        m2[0] = t[0] - 65517;
        for (let i3 = 1; i3 < 15; i3++) {
          m2[i3] = t[i3] - 65535 - (m2[i3 - 1] >> 16 & 1);
          m2[i3 - 1] &= 65535;
        }
        m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
        const b6 = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t, m2, 1 - b6);
      }
      for (let i3 = 0; i3 < 16; i3++) {
        o4[2 * i3] = t[i3] & 255;
        o4[2 * i3 + 1] = t[i3] >> 8;
      }
    }
    function verify32(x7, y10) {
      let d5 = 0;
      for (let i3 = 0; i3 < 32; i3++) {
        d5 |= x7[i3] ^ y10[i3];
      }
      return (1 & d5 - 1 >>> 8) - 1;
    }
    function neq25519(a5, b6) {
      const c7 = new Uint8Array(32);
      const d5 = new Uint8Array(32);
      pack25519(c7, a5);
      pack25519(d5, b6);
      return verify32(c7, d5);
    }
    function par25519(a5) {
      const d5 = new Uint8Array(32);
      pack25519(d5, a5);
      return d5[0] & 1;
    }
    function unpack25519(o4, n4) {
      for (let i3 = 0; i3 < 16; i3++) {
        o4[i3] = n4[2 * i3] + (n4[2 * i3 + 1] << 8);
      }
      o4[15] &= 32767;
    }
    function add(o4, a5, b6) {
      for (let i3 = 0; i3 < 16; i3++) {
        o4[i3] = a5[i3] + b6[i3];
      }
    }
    function sub(o4, a5, b6) {
      for (let i3 = 0; i3 < 16; i3++) {
        o4[i3] = a5[i3] - b6[i3];
      }
    }
    function mul(o4, a5, b6) {
      let v7, c7, t02 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b02 = b6[0], b1 = b6[1], b22 = b6[2], b32 = b6[3], b42 = b6[4], b52 = b6[5], b62 = b6[6], b7 = b6[7], b8 = b6[8], b9 = b6[9], b10 = b6[10], b11 = b6[11], b12 = b6[12], b13 = b6[13], b14 = b6[14], b15 = b6[15];
      v7 = a5[0];
      t02 += v7 * b02;
      t1 += v7 * b1;
      t2 += v7 * b22;
      t3 += v7 * b32;
      t4 += v7 * b42;
      t5 += v7 * b52;
      t6 += v7 * b62;
      t7 += v7 * b7;
      t8 += v7 * b8;
      t9 += v7 * b9;
      t10 += v7 * b10;
      t11 += v7 * b11;
      t12 += v7 * b12;
      t13 += v7 * b13;
      t14 += v7 * b14;
      t15 += v7 * b15;
      v7 = a5[1];
      t1 += v7 * b02;
      t2 += v7 * b1;
      t3 += v7 * b22;
      t4 += v7 * b32;
      t5 += v7 * b42;
      t6 += v7 * b52;
      t7 += v7 * b62;
      t8 += v7 * b7;
      t9 += v7 * b8;
      t10 += v7 * b9;
      t11 += v7 * b10;
      t12 += v7 * b11;
      t13 += v7 * b12;
      t14 += v7 * b13;
      t15 += v7 * b14;
      t16 += v7 * b15;
      v7 = a5[2];
      t2 += v7 * b02;
      t3 += v7 * b1;
      t4 += v7 * b22;
      t5 += v7 * b32;
      t6 += v7 * b42;
      t7 += v7 * b52;
      t8 += v7 * b62;
      t9 += v7 * b7;
      t10 += v7 * b8;
      t11 += v7 * b9;
      t12 += v7 * b10;
      t13 += v7 * b11;
      t14 += v7 * b12;
      t15 += v7 * b13;
      t16 += v7 * b14;
      t17 += v7 * b15;
      v7 = a5[3];
      t3 += v7 * b02;
      t4 += v7 * b1;
      t5 += v7 * b22;
      t6 += v7 * b32;
      t7 += v7 * b42;
      t8 += v7 * b52;
      t9 += v7 * b62;
      t10 += v7 * b7;
      t11 += v7 * b8;
      t12 += v7 * b9;
      t13 += v7 * b10;
      t14 += v7 * b11;
      t15 += v7 * b12;
      t16 += v7 * b13;
      t17 += v7 * b14;
      t18 += v7 * b15;
      v7 = a5[4];
      t4 += v7 * b02;
      t5 += v7 * b1;
      t6 += v7 * b22;
      t7 += v7 * b32;
      t8 += v7 * b42;
      t9 += v7 * b52;
      t10 += v7 * b62;
      t11 += v7 * b7;
      t12 += v7 * b8;
      t13 += v7 * b9;
      t14 += v7 * b10;
      t15 += v7 * b11;
      t16 += v7 * b12;
      t17 += v7 * b13;
      t18 += v7 * b14;
      t19 += v7 * b15;
      v7 = a5[5];
      t5 += v7 * b02;
      t6 += v7 * b1;
      t7 += v7 * b22;
      t8 += v7 * b32;
      t9 += v7 * b42;
      t10 += v7 * b52;
      t11 += v7 * b62;
      t12 += v7 * b7;
      t13 += v7 * b8;
      t14 += v7 * b9;
      t15 += v7 * b10;
      t16 += v7 * b11;
      t17 += v7 * b12;
      t18 += v7 * b13;
      t19 += v7 * b14;
      t20 += v7 * b15;
      v7 = a5[6];
      t6 += v7 * b02;
      t7 += v7 * b1;
      t8 += v7 * b22;
      t9 += v7 * b32;
      t10 += v7 * b42;
      t11 += v7 * b52;
      t12 += v7 * b62;
      t13 += v7 * b7;
      t14 += v7 * b8;
      t15 += v7 * b9;
      t16 += v7 * b10;
      t17 += v7 * b11;
      t18 += v7 * b12;
      t19 += v7 * b13;
      t20 += v7 * b14;
      t21 += v7 * b15;
      v7 = a5[7];
      t7 += v7 * b02;
      t8 += v7 * b1;
      t9 += v7 * b22;
      t10 += v7 * b32;
      t11 += v7 * b42;
      t12 += v7 * b52;
      t13 += v7 * b62;
      t14 += v7 * b7;
      t15 += v7 * b8;
      t16 += v7 * b9;
      t17 += v7 * b10;
      t18 += v7 * b11;
      t19 += v7 * b12;
      t20 += v7 * b13;
      t21 += v7 * b14;
      t22 += v7 * b15;
      v7 = a5[8];
      t8 += v7 * b02;
      t9 += v7 * b1;
      t10 += v7 * b22;
      t11 += v7 * b32;
      t12 += v7 * b42;
      t13 += v7 * b52;
      t14 += v7 * b62;
      t15 += v7 * b7;
      t16 += v7 * b8;
      t17 += v7 * b9;
      t18 += v7 * b10;
      t19 += v7 * b11;
      t20 += v7 * b12;
      t21 += v7 * b13;
      t22 += v7 * b14;
      t23 += v7 * b15;
      v7 = a5[9];
      t9 += v7 * b02;
      t10 += v7 * b1;
      t11 += v7 * b22;
      t12 += v7 * b32;
      t13 += v7 * b42;
      t14 += v7 * b52;
      t15 += v7 * b62;
      t16 += v7 * b7;
      t17 += v7 * b8;
      t18 += v7 * b9;
      t19 += v7 * b10;
      t20 += v7 * b11;
      t21 += v7 * b12;
      t22 += v7 * b13;
      t23 += v7 * b14;
      t24 += v7 * b15;
      v7 = a5[10];
      t10 += v7 * b02;
      t11 += v7 * b1;
      t12 += v7 * b22;
      t13 += v7 * b32;
      t14 += v7 * b42;
      t15 += v7 * b52;
      t16 += v7 * b62;
      t17 += v7 * b7;
      t18 += v7 * b8;
      t19 += v7 * b9;
      t20 += v7 * b10;
      t21 += v7 * b11;
      t22 += v7 * b12;
      t23 += v7 * b13;
      t24 += v7 * b14;
      t25 += v7 * b15;
      v7 = a5[11];
      t11 += v7 * b02;
      t12 += v7 * b1;
      t13 += v7 * b22;
      t14 += v7 * b32;
      t15 += v7 * b42;
      t16 += v7 * b52;
      t17 += v7 * b62;
      t18 += v7 * b7;
      t19 += v7 * b8;
      t20 += v7 * b9;
      t21 += v7 * b10;
      t22 += v7 * b11;
      t23 += v7 * b12;
      t24 += v7 * b13;
      t25 += v7 * b14;
      t26 += v7 * b15;
      v7 = a5[12];
      t12 += v7 * b02;
      t13 += v7 * b1;
      t14 += v7 * b22;
      t15 += v7 * b32;
      t16 += v7 * b42;
      t17 += v7 * b52;
      t18 += v7 * b62;
      t19 += v7 * b7;
      t20 += v7 * b8;
      t21 += v7 * b9;
      t22 += v7 * b10;
      t23 += v7 * b11;
      t24 += v7 * b12;
      t25 += v7 * b13;
      t26 += v7 * b14;
      t27 += v7 * b15;
      v7 = a5[13];
      t13 += v7 * b02;
      t14 += v7 * b1;
      t15 += v7 * b22;
      t16 += v7 * b32;
      t17 += v7 * b42;
      t18 += v7 * b52;
      t19 += v7 * b62;
      t20 += v7 * b7;
      t21 += v7 * b8;
      t22 += v7 * b9;
      t23 += v7 * b10;
      t24 += v7 * b11;
      t25 += v7 * b12;
      t26 += v7 * b13;
      t27 += v7 * b14;
      t28 += v7 * b15;
      v7 = a5[14];
      t14 += v7 * b02;
      t15 += v7 * b1;
      t16 += v7 * b22;
      t17 += v7 * b32;
      t18 += v7 * b42;
      t19 += v7 * b52;
      t20 += v7 * b62;
      t21 += v7 * b7;
      t22 += v7 * b8;
      t23 += v7 * b9;
      t24 += v7 * b10;
      t25 += v7 * b11;
      t26 += v7 * b12;
      t27 += v7 * b13;
      t28 += v7 * b14;
      t29 += v7 * b15;
      v7 = a5[15];
      t15 += v7 * b02;
      t16 += v7 * b1;
      t17 += v7 * b22;
      t18 += v7 * b32;
      t19 += v7 * b42;
      t20 += v7 * b52;
      t21 += v7 * b62;
      t22 += v7 * b7;
      t23 += v7 * b8;
      t24 += v7 * b9;
      t25 += v7 * b10;
      t26 += v7 * b11;
      t27 += v7 * b12;
      t28 += v7 * b13;
      t29 += v7 * b14;
      t30 += v7 * b15;
      t02 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c7 = 1;
      v7 = t02 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t02 = v7 - c7 * 65536;
      v7 = t1 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t1 = v7 - c7 * 65536;
      v7 = t2 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t2 = v7 - c7 * 65536;
      v7 = t3 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t3 = v7 - c7 * 65536;
      v7 = t4 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t4 = v7 - c7 * 65536;
      v7 = t5 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t5 = v7 - c7 * 65536;
      v7 = t6 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t6 = v7 - c7 * 65536;
      v7 = t7 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t7 = v7 - c7 * 65536;
      v7 = t8 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t8 = v7 - c7 * 65536;
      v7 = t9 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t9 = v7 - c7 * 65536;
      v7 = t10 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t10 = v7 - c7 * 65536;
      v7 = t11 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t11 = v7 - c7 * 65536;
      v7 = t12 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t12 = v7 - c7 * 65536;
      v7 = t13 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t13 = v7 - c7 * 65536;
      v7 = t14 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t14 = v7 - c7 * 65536;
      v7 = t15 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t15 = v7 - c7 * 65536;
      t02 += c7 - 1 + 37 * (c7 - 1);
      c7 = 1;
      v7 = t02 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t02 = v7 - c7 * 65536;
      v7 = t1 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t1 = v7 - c7 * 65536;
      v7 = t2 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t2 = v7 - c7 * 65536;
      v7 = t3 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t3 = v7 - c7 * 65536;
      v7 = t4 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t4 = v7 - c7 * 65536;
      v7 = t5 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t5 = v7 - c7 * 65536;
      v7 = t6 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t6 = v7 - c7 * 65536;
      v7 = t7 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t7 = v7 - c7 * 65536;
      v7 = t8 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t8 = v7 - c7 * 65536;
      v7 = t9 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t9 = v7 - c7 * 65536;
      v7 = t10 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t10 = v7 - c7 * 65536;
      v7 = t11 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t11 = v7 - c7 * 65536;
      v7 = t12 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t12 = v7 - c7 * 65536;
      v7 = t13 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t13 = v7 - c7 * 65536;
      v7 = t14 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t14 = v7 - c7 * 65536;
      v7 = t15 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t15 = v7 - c7 * 65536;
      t02 += c7 - 1 + 37 * (c7 - 1);
      o4[0] = t02;
      o4[1] = t1;
      o4[2] = t2;
      o4[3] = t3;
      o4[4] = t4;
      o4[5] = t5;
      o4[6] = t6;
      o4[7] = t7;
      o4[8] = t8;
      o4[9] = t9;
      o4[10] = t10;
      o4[11] = t11;
      o4[12] = t12;
      o4[13] = t13;
      o4[14] = t14;
      o4[15] = t15;
    }
    function square(o4, a5) {
      mul(o4, a5, a5);
    }
    function inv25519(o4, i3) {
      const c7 = gf2();
      let a5;
      for (a5 = 0; a5 < 16; a5++) {
        c7[a5] = i3[a5];
      }
      for (a5 = 253; a5 >= 0; a5--) {
        square(c7, c7);
        if (a5 !== 2 && a5 !== 4) {
          mul(c7, c7, i3);
        }
      }
      for (a5 = 0; a5 < 16; a5++) {
        o4[a5] = c7[a5];
      }
    }
    function pow2523(o4, i3) {
      const c7 = gf2();
      let a5;
      for (a5 = 0; a5 < 16; a5++) {
        c7[a5] = i3[a5];
      }
      for (a5 = 250; a5 >= 0; a5--) {
        square(c7, c7);
        if (a5 !== 1) {
          mul(c7, c7, i3);
        }
      }
      for (a5 = 0; a5 < 16; a5++) {
        o4[a5] = c7[a5];
      }
    }
    function edadd(p5, q4) {
      const a5 = gf2(), b6 = gf2(), c7 = gf2(), d5 = gf2(), e = gf2(), f6 = gf2(), g4 = gf2(), h7 = gf2(), t = gf2();
      sub(a5, p5[1], p5[0]);
      sub(t, q4[1], q4[0]);
      mul(a5, a5, t);
      add(b6, p5[0], p5[1]);
      add(t, q4[0], q4[1]);
      mul(b6, b6, t);
      mul(c7, p5[3], q4[3]);
      mul(c7, c7, D22);
      mul(d5, p5[2], q4[2]);
      add(d5, d5, d5);
      sub(e, b6, a5);
      sub(f6, d5, c7);
      add(g4, d5, c7);
      add(h7, b6, a5);
      mul(p5[0], e, f6);
      mul(p5[1], h7, g4);
      mul(p5[2], g4, f6);
      mul(p5[3], e, h7);
    }
    function cswap(p5, q4, b6) {
      for (let i3 = 0; i3 < 4; i3++) {
        sel25519(p5[i3], q4[i3], b6);
      }
    }
    function pack(r3, p5) {
      const tx = gf2(), ty = gf2(), zi4 = gf2();
      inv25519(zi4, p5[2]);
      mul(tx, p5[0], zi4);
      mul(ty, p5[1], zi4);
      pack25519(r3, ty);
      r3[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p5, q4, s2) {
      set25519(p5[0], gf0);
      set25519(p5[1], gf1);
      set25519(p5[2], gf1);
      set25519(p5[3], gf0);
      for (let i3 = 255; i3 >= 0; --i3) {
        const b6 = s2[i3 / 8 | 0] >> (i3 & 7) & 1;
        cswap(p5, q4, b6);
        edadd(q4, p5);
        edadd(p5, p5);
        cswap(p5, q4, b6);
      }
    }
    function scalarbase(p5, s2) {
      const q4 = [gf2(), gf2(), gf2(), gf2()];
      set25519(q4[0], X2);
      set25519(q4[1], Y6);
      set25519(q4[2], gf1);
      mul(q4[3], X2, Y6);
      scalarmult(p5, q4, s2);
    }
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SEED_LENGTH) {
        throw new Error(`ed25519: seed must be ${exports.SEED_LENGTH} bytes`);
      }
      const d5 = (0, sha512_1.hash)(seed);
      d5[0] &= 248;
      d5[31] &= 127;
      d5[31] |= 64;
      const publicKey = new Uint8Array(32);
      const p5 = [gf2(), gf2(), gf2(), gf2()];
      scalarbase(p5, d5);
      pack(publicKey, p5);
      const secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair3(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports.generateKeyPair = generateKeyPair3;
    function extractPublicKeyFromSecretKey(secretKey) {
      if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`ed25519: secret key must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      return new Uint8Array(secretKey.subarray(32));
    }
    exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    var L4 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function modL(r3, x7) {
      let carry;
      let i3;
      let j7;
      let k6;
      for (i3 = 63; i3 >= 32; --i3) {
        carry = 0;
        for (j7 = i3 - 32, k6 = i3 - 12; j7 < k6; ++j7) {
          x7[j7] += carry - 16 * x7[i3] * L4[j7 - (i3 - 32)];
          carry = Math.floor((x7[j7] + 128) / 256);
          x7[j7] -= carry * 256;
        }
        x7[j7] += carry;
        x7[i3] = 0;
      }
      carry = 0;
      for (j7 = 0; j7 < 32; j7++) {
        x7[j7] += carry - (x7[31] >> 4) * L4[j7];
        carry = x7[j7] >> 8;
        x7[j7] &= 255;
      }
      for (j7 = 0; j7 < 32; j7++) {
        x7[j7] -= carry * L4[j7];
      }
      for (i3 = 0; i3 < 32; i3++) {
        x7[i3 + 1] += x7[i3] >> 8;
        r3[i3] = x7[i3] & 255;
      }
    }
    function reduce(r3) {
      const x7 = new Float64Array(64);
      for (let i3 = 0; i3 < 64; i3++) {
        x7[i3] = r3[i3];
      }
      for (let i3 = 0; i3 < 64; i3++) {
        r3[i3] = 0;
      }
      modL(r3, x7);
    }
    function sign2(secretKey, message) {
      const x7 = new Float64Array(64);
      const p5 = [gf2(), gf2(), gf2(), gf2()];
      const d5 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d5[0] &= 248;
      d5[31] &= 127;
      d5[31] |= 64;
      const signature = new Uint8Array(64);
      signature.set(d5.subarray(32), 32);
      const hs = new sha512_1.SHA512();
      hs.update(signature.subarray(32));
      hs.update(message);
      const r3 = hs.digest();
      hs.clean();
      reduce(r3);
      scalarbase(p5, r3);
      pack(signature, p5);
      hs.reset();
      hs.update(signature.subarray(0, 32));
      hs.update(secretKey.subarray(32));
      hs.update(message);
      const h7 = hs.digest();
      reduce(h7);
      for (let i3 = 0; i3 < 32; i3++) {
        x7[i3] = r3[i3];
      }
      for (let i3 = 0; i3 < 32; i3++) {
        for (let j7 = 0; j7 < 32; j7++) {
          x7[i3 + j7] += h7[i3] * d5[j7];
        }
      }
      modL(signature.subarray(32), x7);
      return signature;
    }
    exports.sign = sign2;
    function unpackneg(r3, p5) {
      const t = gf2(), chk = gf2(), num = gf2(), den = gf2(), den2 = gf2(), den4 = gf2(), den6 = gf2();
      set25519(r3[2], gf1);
      unpack25519(r3[1], p5);
      square(num, r3[1]);
      mul(den, num, D5);
      sub(num, num, r3[2]);
      add(den, r3[2], den);
      square(den2, den);
      square(den4, den2);
      mul(den6, den4, den2);
      mul(t, den6, num);
      mul(t, t, den);
      pow2523(t, t);
      mul(t, t, num);
      mul(t, t, den);
      mul(t, t, den);
      mul(r3[0], t, den);
      square(chk, r3[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        mul(r3[0], r3[0], I5);
      }
      square(chk, r3[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r3[0]) === p5[31] >> 7) {
        sub(r3[0], gf0, r3[0]);
      }
      mul(r3[3], r3[0], r3[1]);
      return 0;
    }
    function verify2(publicKey, message, signature) {
      const t = new Uint8Array(32);
      const p5 = [gf2(), gf2(), gf2(), gf2()];
      const q4 = [gf2(), gf2(), gf2(), gf2()];
      if (signature.length !== exports.SIGNATURE_LENGTH) {
        throw new Error(`ed25519: signature must be ${exports.SIGNATURE_LENGTH} bytes`);
      }
      if (unpackneg(q4, publicKey)) {
        return false;
      }
      const hs = new sha512_1.SHA512();
      hs.update(signature.subarray(0, 32));
      hs.update(publicKey);
      hs.update(message);
      const h7 = hs.digest();
      reduce(h7);
      scalarmult(p5, q4, h7);
      scalarbase(q4, signature.subarray(32));
      edadd(p5, q4);
      pack(t, p5);
      if (verify32(signature, t)) {
        return false;
      }
      return true;
    }
    exports.verify = verify2;
    function convertPublicKeyToX25519(publicKey) {
      let q4 = [gf2(), gf2(), gf2(), gf2()];
      if (unpackneg(q4, publicKey)) {
        throw new Error("Ed25519: invalid public key");
      }
      let a5 = gf2();
      let b6 = gf2();
      let y10 = q4[1];
      add(a5, gf1, y10);
      sub(b6, gf1, y10);
      inv25519(b6, b6);
      mul(a5, a5, b6);
      let z9 = new Uint8Array(32);
      pack25519(z9, a5);
      return z9;
    }
    exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
    function convertSecretKeyToX25519(secretKey) {
      const d5 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d5[0] &= 248;
      d5[31] &= 127;
      d5[31] |= 64;
      const o4 = new Uint8Array(d5.subarray(0, 32));
      (0, wipe_1.wipe)(d5);
      return o4;
    }
    exports.convertSecretKeyToX25519 = convertSecretKeyToX25519;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/ws/browser.js
var require_browser3 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@walletconnect/core/dist/index.es.js
var import_events7 = __toESM(require_events());

// node_modules/@walletconnect/heartbeat/dist/index.es.js
var import_events = __toESM(require_events());
var import_time = __toESM(require_cjs());
init_esm();
var n = class extends IEvents {
  constructor(e) {
    super();
  }
};
var s = import_time.FIVE_SECONDS;
var r2 = { pulse: "heartbeat_pulse" };
var i = class _i5 extends n {
  constructor(e) {
    super(e), this.events = new import_events.EventEmitter(), this.interval = s, this.interval = (e == null ? void 0 : e.interval) || s;
  }
  static async init(e) {
    const t = new _i5(e);
    return await t.init(), t;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), (0, import_time.toMiliseconds)(this.interval));
  }
  pulse() {
    this.events.emit(r2.pulse);
  }
};

// node_modules/@walletconnect/core/node_modules/unstorage/dist/shared/unstorage.mNKHTF5Y.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c7) => c7.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key) {
  var _a2;
  if (!key) {
    return "";
  }
  return ((_a2 = key.split("?")[0]) == null ? void 0 : _a2.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base2) {
  base2 = normalizeKey(base2);
  return base2 ? base2 + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base2) {
  if (base2) {
    return key.startsWith(base2) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

// node_modules/@walletconnect/core/node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base2 of context.mountpoints) {
      if (key.startsWith(base2)) {
        return {
          base: base2,
          relativeKey: key.slice(base2.length),
          driver: context.mounts[base2]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base2, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base2) || includeParent && base2.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base2.length > mountpoint.length ? base2.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r3) => r3.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r3) => r3.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base2, opts = {}) {
      var _a2;
      base2 = normalizeBaseKey(base2);
      const mounts = getMounts(base2, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a2 = mount.driver.flags) == null ? void 0 : _a2.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p5) => fullKey.startsWith(p5))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p5) => !p5.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base2)
      );
    },
    // Utils
    async clear(base2, opts = {}) {
      base2 = normalizeBaseKey(base2);
      await Promise.all(
        getMounts(base2, false).map(async (m2) => {
          if (m2.driver.clear) {
            return asyncCall(m2.driver.clear, m2.relativeBase, opts);
          }
          if (m2.driver.removeItem) {
            const keys2 = await m2.driver.getKeys(m2.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m2.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base2, driver) {
      base2 = normalizeBaseKey(base2);
      if (base2 && context.mounts[base2]) {
        throw new Error(`already mounted at ${base2}`);
      }
      if (base2) {
        context.mountpoints.push(base2);
        context.mountpoints.sort((a5, b6) => b6.length - a5.length);
      }
      context.mounts[base2] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base2)).then((unwatcher) => {
          context.unwatch[base2] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base2, _dispose = true) {
      var _a2, _b;
      base2 = normalizeBaseKey(base2);
      if (!base2 || !context.mounts[base2]) {
        return;
      }
      if (context.watching && base2 in context.unwatch) {
        (_b = (_a2 = context.unwatch)[base2]) == null ? void 0 : _b.call(_a2);
        delete context.unwatch[base2];
      }
      if (_dispose) {
        await dispose(context.mounts[base2]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base2);
      delete context.mounts[base2];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m2 = getMount(key);
      return {
        driver: m2.driver,
        base: m2.base
      };
    },
    getMounts(base2 = "", opts = {}) {
      base2 = normalizeKey(base2);
      const mounts = getMounts(base2, opts.parents);
      return mounts.map((m2) => ({
        driver: m2.driver,
        base: m2.mountpoint
      }));
    },
    // Aliases
    keys: (base2, opts = {}) => storage.getKeys(base2, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base2) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base2 + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x = "idb-keyval";
var z = (i3 = {}) => {
  const t = i3.base && i3.base.length > 0 ? `${i3.base}:` : "", e = (s2) => t + s2;
  let n4;
  return i3.dbName && i3.storeName && (n4 = createStore(i3.dbName, i3.storeName)), { name: x, options: i3, async hasItem(s2) {
    return !(typeof await get(e(s2), n4) > "u");
  }, async getItem(s2) {
    return await get(e(s2), n4) ?? null;
  }, setItem(s2, a5) {
    return set(e(s2), a5, n4);
  }, removeItem(s2) {
    return del(e(s2), n4);
  }, getKeys() {
    return keys(n4);
  }, clear() {
    return clear(n4);
  } };
};
var D = "WALLET_CONNECT_V2_INDEXED_DB";
var E2 = "keyvaluestorage";
var _ = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D, storeName: E2 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e = await this.indexedDb.getItem(t);
    if (e !== null) return e;
  }
  async setItem(t, e) {
    await this.indexedDb.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i3;
  function t() {
  }
  i3 = t, i3.prototype.getItem = function(e) {
    return this.hasOwnProperty(e) ? String(this[e]) : null;
  }, i3.prototype.setItem = function(e, n4) {
    this[e] = String(n4);
  }, i3.prototype.removeItem = function(e) {
    delete this[e];
  }, i3.prototype.clear = function() {
    const e = this;
    Object.keys(e).forEach(function(n4) {
      e[n4] = void 0, delete e[n4];
    });
  }, i3.prototype.key = function(e) {
    return e = e || 0, Object.keys(this)[e];
  }, i3.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l2 < "u" && l2.localStorage ? c.exports = l2.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();
function k2(i3) {
  var t;
  return [i3[0], safeJsonParse((t = i3[1]) != null ? t : "")];
}
var K = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k2);
  }
  async getItem(t) {
    const e = this.localStorage.getItem(t);
    if (e !== null) return safeJsonParse(e);
  }
  async setItem(t, e) {
    this.localStorage.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N = "wc_storage_version";
var y2 = 1;
var O = async (i3, t, e) => {
  const n4 = N, s2 = await t.getItem(n4);
  if (s2 && s2 >= y2) {
    e(t);
    return;
  }
  const a5 = await i3.getKeys();
  if (!a5.length) {
    e(t);
    return;
  }
  const m2 = [];
  for (; a5.length; ) {
    const r3 = a5.shift();
    if (!r3) continue;
    const o4 = r3.toLowerCase();
    if (o4.includes("wc@") || o4.includes("walletconnect") || o4.includes("wc_") || o4.includes("wallet_connect")) {
      const f6 = await i3.getItem(r3);
      await t.setItem(r3, f6), m2.push(r3);
    }
  }
  await t.setItem(n4, y2), e(t), j(i3, m2);
};
var j = async (i3, t) => {
  t.length && t.forEach(async (e) => {
    await i3.removeItem(e);
  });
};
var h = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e) => {
      this.storage = e, this.initialized = true;
    };
    const t = new K();
    this.storage = t;
    try {
      const e = new _();
      O(t, e, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e) {
    return await this.initialize(), this.storage.setItem(t, e);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e = setInterval(() => {
        this.initialized && (clearInterval(e), t());
      }, 20);
    });
  }
};

// node_modules/@walletconnect/types/dist/index.es.js
init_esm();
var import_events4 = __toESM(require_events());
var a2 = Object.defineProperty;
var u = (e, s2, r3) => s2 in e ? a2(e, s2, { enumerable: true, configurable: true, writable: true, value: r3 }) : e[s2] = r3;
var c2 = (e, s2, r3) => u(e, typeof s2 != "symbol" ? s2 + "" : s2, r3);
var h2 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, c2(this, "protocol", "wc"), c2(this, "version", 2);
  }
};
var p = Object.defineProperty;
var b = (e, s2, r3) => s2 in e ? p(e, s2, { enumerable: true, configurable: true, writable: true, value: r3 }) : e[s2] = r3;
var v = (e, s2, r3) => b(e, typeof s2 != "symbol" ? s2 + "" : s2, r3);
var I = class extends IEvents {
  constructor(s2, r3) {
    super(), this.core = s2, this.logger = r3, v(this, "records", /* @__PURE__ */ new Map());
  }
};
var y3 = class {
  constructor(s2, r3) {
    this.logger = s2, this.core = r3;
  }
};
var m = class extends IEvents {
  constructor(s2, r3) {
    super(), this.relayer = s2, this.logger = r3;
  }
};
var d = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var f = class {
  constructor(s2, r3, t, q4) {
    this.core = s2, this.logger = r3, this.name = t;
  }
};
var P = class extends IEvents {
  constructor(s2, r3) {
    super(), this.relayer = s2, this.logger = r3;
  }
};
var S = class extends IEvents {
  constructor(s2, r3) {
    super(), this.core = s2, this.logger = r3;
  }
};
var M = class {
  constructor(s2, r3, t) {
    this.core = s2, this.logger = r3, this.store = t;
  }
};
var O2 = class {
  constructor(s2, r3) {
    this.projectId = s2, this.logger = r3;
  }
};
var R = class {
  constructor(s2, r3, t) {
    this.core = s2, this.logger = r3, this.telemetryEnabled = t;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_time3 = __toESM(require_cjs());

// node_modules/@walletconnect/utils/dist/index.es.js
var import_time2 = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());

// node_modules/@walletconnect/utils/node_modules/base-x/src/esm/index.js
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j7 = 0; j7 < BASE_MAP.length; j7++) {
    BASE_MAP[j7] = 255;
  }
  for (let i3 = 0; i3 < ALPHABET2.length; i3++) {
    const x7 = ALPHABET2.charAt(i3);
    const xc2 = x7.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x7 + " is ambiguous");
    }
    BASE_MAP[xc2] = i3;
  }
  const BASE = ALPHABET2.length;
  const LEADER = ALPHABET2.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i3 = 0;
      for (let it1 = size - 1; (carry !== 0 || i3 < length) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      pbegin++;
    }
    let it22 = size - length;
    while (it22 !== size && b58[it22] === 0) {
      it22++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it22 < size; ++it22) {
      str += ALPHABET2.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i3 = 0;
      for (let it32 = size - 1; (carry !== 0 || i3 < length) && it32 !== -1; it32--, i3++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      psz++;
    }
    let it42 = size - length;
    while (it42 !== size && b256[it42] === 0) {
      it42++;
    }
    const vch = new Uint8Array(zeroes + (size - it42));
    let j7 = zeroes;
    while (it42 !== size) {
      vch[j7++] = b256[it42++];
    }
    return vch;
  }
  function decode(string4) {
    const buffer = decodeUnsafe(string4);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode,
    decodeUnsafe,
    decode
  };
}
var esm_default = base;

// node_modules/@walletconnect/utils/node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default2 = esm_default(ALPHABET);

// node_modules/@walletconnect/utils/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return globalThis.Buffer.allocUnsafe(size);
  }
  return new Uint8Array(size);
}

// node_modules/@walletconnect/utils/node_modules/uint8arrays/esm/src/concat.js
function concat(arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return output;
}

// node_modules/@walletconnect/utils/node_modules/uint8arrays/esm/src/util/bases.js
init_basics();
function createCodec(name, prefix, encode, decode) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode
    },
    decoder: { decode }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string4 = "a";
  for (let i3 = 0; i3 < buf.length; i3++) {
    string4 += String.fromCharCode(buf[i3]);
  }
  return string4;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i3 = 0; i3 < str.length; i3++) {
    buf[i3] = str.charCodeAt(i3);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/@walletconnect/utils/node_modules/uint8arrays/esm/src/from-string.js
function fromString(string4, encoding = "utf8") {
  const base2 = bases_default[encoding];
  if (!base2) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(string4, "utf8");
  }
  return base2.decoder.decode(`${base2.prefix}${string4}`);
}

// node_modules/@walletconnect/utils/node_modules/uint8arrays/esm/src/to-string.js
function toString(array, encoding = "utf8") {
  const base2 = bases_default[encoding];
  if (!base2) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base2.encoder.encode(array).substring(1);
}

// node_modules/@walletconnect/utils/dist/index.es.js
var $n = "ReactNative";
var Y = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var jn = "js";
function Re() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function pt() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === $n;
}
function ei() {
  return pt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function ni() {
  return pt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function Yt() {
  return !Re() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function xt() {
  return pt() ? Y.reactNative : Re() ? Y.node : Yt() ? Y.browser : Y.unknown;
}
function ri() {
  var t;
  try {
    return pt() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function Cn(t, e) {
  const n4 = new URLSearchParams(t);
  for (const r3 of Object.keys(e).sort()) if (e.hasOwnProperty(r3)) {
    const o4 = e[r3];
    o4 !== void 0 && n4.set(r3, o4);
  }
  return n4.toString();
}
function Pn() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function kn() {
  if (xt() === Y.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n4, Version: r3 } = global.Platform;
    return [n4, r3].join("-");
  }
  const t = detect();
  if (t === null) return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function Vn() {
  var t;
  const e = xt();
  return e === Y.browser ? [e, ((t = (0, import_window_getters.getLocation)()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function Mn(t, e, n4) {
  const r3 = kn(), o4 = Vn();
  return [[t, e].join("-"), [jn, n4].join("-"), r3, o4].join("/");
}
function si({ protocol: t, version: e, relayUrl: n4, sdkVersion: r3, auth: o4, projectId: i3, useOnCloseEvent: s2, bundleId: c7, packageName: a5 }) {
  const u4 = n4.split("?"), l7 = Mn(t, e, r3), f6 = { auth: o4, ua: l7, projectId: i3, useOnCloseEvent: s2 || void 0, packageName: a5 || void 0, bundleId: c7 || void 0 }, h7 = Cn(u4[1] || "", f6);
  return u4[0] + "?" + h7;
}
function fi(t) {
  return Object.fromEntries(t.entries());
}
function li(t) {
  return new Map(Object.entries(t));
}
function gi(t = import_time2.FIVE_MINUTES, e) {
  const n4 = (0, import_time2.toMiliseconds)(t || import_time2.FIVE_MINUTES);
  let r3, o4, i3, s2;
  return { resolve: (c7) => {
    i3 && r3 && (clearTimeout(i3), r3(c7), s2 = Promise.resolve(c7));
  }, reject: (c7) => {
    i3 && o4 && (clearTimeout(i3), o4(c7));
  }, done: () => new Promise((c7, a5) => {
    if (s2) return c7(s2);
    i3 = setTimeout(() => {
      const u4 = new Error(e);
      s2 = Promise.reject(u4), a5(u4);
    }, n4), r3 = c7, o4 = a5;
  }) };
}
function yi(t, e, n4) {
  return new Promise(async (r3, o4) => {
    const i3 = setTimeout(() => o4(new Error(n4)), e);
    try {
      const s2 = await t;
      r3(s2);
    } catch (s2) {
      o4(s2);
    }
    clearTimeout(i3);
  });
}
function _e(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function mi(t) {
  return _e("topic", t);
}
function wi(t) {
  return _e("id", t);
}
function bi(t) {
  const [e, n4] = t.split(":"), r3 = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof n4 == "string") r3.topic = n4;
  else if (e === "id" && Number.isInteger(Number(n4))) r3.id = Number(n4);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${n4}`);
  return r3;
}
function Ei(t, e) {
  return (0, import_time2.fromMiliseconds)((e || Date.now()) + (0, import_time2.toMiliseconds)(t));
}
function vi(t) {
  return Date.now() >= (0, import_time2.toMiliseconds)(t);
}
function xi(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function Bi() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
    const e = Math.random() * 16 | 0;
    return (t === "x" ? e : e & 3 | 8).toString(16);
  });
}
function Ii() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function Le(t) {
  return Buffer.from(t, "base64").toString("utf-8");
}
function Ni(t) {
  return new Promise((e) => setTimeout(e, t));
}
function Gt(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function Ui(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Wt(t, ...e) {
  if (!Ui(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function je(t) {
  if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Gt(t.outputLen), Gt(t.blockLen);
}
function Tt(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function Gn(t, e) {
  Wt(t);
  const n4 = e.outputLen;
  if (t.length < n4) throw new Error("digestInto() expects output buffer of length at least " + n4);
}
var ue = BigInt(2 ** 32 - 1);
var Wn = BigInt(32);
function Ti(t, e = false) {
  return e ? { h: Number(t & ue), l: Number(t >> Wn & ue) } : { h: Number(t >> Wn & ue) | 0, l: Number(t & ue) | 0 };
}
function Ri(t, e = false) {
  let n4 = new Uint32Array(t.length), r3 = new Uint32Array(t.length);
  for (let o4 = 0; o4 < t.length; o4++) {
    const { h: i3, l: s2 } = Ti(t[o4], e);
    [n4[o4], r3[o4]] = [i3, s2];
  }
  return [n4, r3];
}
var _i = (t, e, n4) => t << n4 | e >>> 32 - n4;
var $i = (t, e, n4) => e << n4 | t >>> 32 - n4;
var Li = (t, e, n4) => e << n4 - 32 | t >>> 64 - n4;
var ji = (t, e, n4) => t << n4 - 32 | e >>> 64 - n4;
var Rt = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function Ci(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function Ce(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function st(t, e) {
  return t << 32 - e | t >>> e;
}
var Xn = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Pi(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function Jn(t) {
  for (let e = 0; e < t.length; e++) t[e] = Pi(t[e]);
}
function ki(t) {
  if (typeof t != "string") throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function _t(t) {
  return typeof t == "string" && (t = ki(t)), Wt(t), t;
}
function Vi(...t) {
  let e = 0;
  for (let r3 = 0; r3 < t.length; r3++) {
    const o4 = t[r3];
    Wt(o4), e += o4.length;
  }
  const n4 = new Uint8Array(e);
  for (let r3 = 0, o4 = 0; r3 < t.length; r3++) {
    const i3 = t[r3];
    n4.set(i3, o4), o4 += i3.length;
  }
  return n4;
}
var Pe = class {
  clone() {
    return this._cloneInto();
  }
};
function Qn(t) {
  const e = (r3) => t().update(_t(r3)).digest(), n4 = t();
  return e.outputLen = n4.outputLen, e.blockLen = n4.blockLen, e.create = () => t(), e;
}
function $t(t = 32) {
  if (Rt && typeof Rt.getRandomValues == "function") return Rt.getRandomValues(new Uint8Array(t));
  if (Rt && typeof Rt.randomBytes == "function") return Rt.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
var tr = [];
var er = [];
var nr = [];
var Mi = BigInt(0);
var Xt = BigInt(1);
var Di = BigInt(2);
var Hi = BigInt(7);
var qi = BigInt(256);
var Ki = BigInt(113);
for (let t = 0, e = Xt, n4 = 1, r3 = 0; t < 24; t++) {
  [n4, r3] = [r3, (2 * n4 + 3 * r3) % 5], tr.push(2 * (5 * r3 + n4)), er.push((t + 1) * (t + 2) / 2 % 64);
  let o4 = Mi;
  for (let i3 = 0; i3 < 7; i3++) e = (e << Xt ^ (e >> Hi) * Ki) % qi, e & Di && (o4 ^= Xt << (Xt << BigInt(i3)) - Xt);
  nr.push(o4);
}
var [Fi, zi] = Ri(nr, true);
var rr = (t, e, n4) => n4 > 32 ? Li(t, e, n4) : _i(t, e, n4);
var or = (t, e, n4) => n4 > 32 ? ji(t, e, n4) : $i(t, e, n4);
function Zi(t, e = 24) {
  const n4 = new Uint32Array(10);
  for (let r3 = 24 - e; r3 < 24; r3++) {
    for (let s2 = 0; s2 < 10; s2++) n4[s2] = t[s2] ^ t[s2 + 10] ^ t[s2 + 20] ^ t[s2 + 30] ^ t[s2 + 40];
    for (let s2 = 0; s2 < 10; s2 += 2) {
      const c7 = (s2 + 8) % 10, a5 = (s2 + 2) % 10, u4 = n4[a5], l7 = n4[a5 + 1], f6 = rr(u4, l7, 1) ^ n4[c7], h7 = or(u4, l7, 1) ^ n4[c7 + 1];
      for (let y10 = 0; y10 < 50; y10 += 10) t[s2 + y10] ^= f6, t[s2 + y10 + 1] ^= h7;
    }
    let o4 = t[2], i3 = t[3];
    for (let s2 = 0; s2 < 24; s2++) {
      const c7 = er[s2], a5 = rr(o4, i3, c7), u4 = or(o4, i3, c7), l7 = tr[s2];
      o4 = t[l7], i3 = t[l7 + 1], t[l7] = a5, t[l7 + 1] = u4;
    }
    for (let s2 = 0; s2 < 50; s2 += 10) {
      for (let c7 = 0; c7 < 10; c7++) n4[c7] = t[s2 + c7];
      for (let c7 = 0; c7 < 10; c7++) t[s2 + c7] ^= ~n4[(c7 + 2) % 10] & n4[(c7 + 4) % 10];
    }
    t[0] ^= Fi[r3], t[1] ^= zi[r3];
  }
  n4.fill(0);
}
var En = class _En extends Pe {
  constructor(e, n4, r3, o4 = false, i3 = 24) {
    if (super(), this.blockLen = e, this.suffix = n4, this.outputLen = r3, this.enableXOF = o4, this.rounds = i3, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Gt(r3), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Ci(this.state);
  }
  keccak() {
    Xn || Jn(this.state32), Zi(this.state32, this.rounds), Xn || Jn(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Tt(this);
    const { blockLen: n4, state: r3 } = this;
    e = _t(e);
    const o4 = e.length;
    for (let i3 = 0; i3 < o4; ) {
      const s2 = Math.min(n4 - this.pos, o4 - i3);
      for (let c7 = 0; c7 < s2; c7++) r3[this.pos++] ^= e[i3++];
      this.pos === n4 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e, suffix: n4, pos: r3, blockLen: o4 } = this;
    e[r3] ^= n4, (n4 & 128) !== 0 && r3 === o4 - 1 && this.keccak(), e[o4 - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Tt(this, false), Wt(e), this.finish();
    const n4 = this.state, { blockLen: r3 } = this;
    for (let o4 = 0, i3 = e.length; o4 < i3; ) {
      this.posOut >= r3 && this.keccak();
      const s2 = Math.min(r3 - this.posOut, i3 - o4);
      e.set(n4.subarray(this.posOut, this.posOut + s2), o4), this.posOut += s2, o4 += s2;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Gt(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Gn(e, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: n4, suffix: r3, outputLen: o4, rounds: i3, enableXOF: s2 } = this;
    return e || (e = new _En(n4, r3, o4, s2, i3)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i3, e.suffix = r3, e.outputLen = o4, e.enableXOF = s2, e.destroyed = this.destroyed, e;
  }
};
var Yi = (t, e, n4) => Qn(() => new En(e, t, n4));
var Gi = Yi(1, 136, 256 / 8);
function Ke(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function Sr(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function tt(t, ...e) {
  if (!Sr(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function Or(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function ps(t, e) {
  tt(t);
  const n4 = e.outputLen;
  if (t.length < n4) throw new Error("digestInto() expects output buffer of length at least " + n4);
}
function Ar(t) {
  if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
}
var mt = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
var gs = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
var ys = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!ys) throw new Error("Non little-endian hardware is not supported");
function ms(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function Fe(t) {
  if (typeof t == "string") t = ms(t);
  else if (Sr(t)) t = ze(t);
  else throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function ws(t, e) {
  if (e == null || typeof e != "object") throw new Error("options must be defined");
  return Object.assign(t, e);
}
function bs(t, e) {
  if (t.length !== e.length) return false;
  let n4 = 0;
  for (let r3 = 0; r3 < t.length; r3++) n4 |= t[r3] ^ e[r3];
  return n4 === 0;
}
var Es = (t, e) => {
  function n4(r3, ...o4) {
    if (tt(r3), t.nonceLength !== void 0) {
      const l7 = o4[0];
      if (!l7) throw new Error("nonce / iv required");
      t.varSizeNonce ? tt(l7) : tt(l7, t.nonceLength);
    }
    const i3 = t.tagLength;
    i3 && o4[1] !== void 0 && tt(o4[1]);
    const s2 = e(r3, ...o4), c7 = (l7, f6) => {
      if (f6 !== void 0) {
        if (l7 !== 2) throw new Error("cipher output not supported");
        tt(f6);
      }
    };
    let a5 = false;
    return { encrypt(l7, f6) {
      if (a5) throw new Error("cannot encrypt() twice with same key + nonce");
      return a5 = true, tt(l7), c7(s2.encrypt.length, f6), s2.encrypt(l7, f6);
    }, decrypt(l7, f6) {
      if (tt(l7), i3 && l7.length < i3) throw new Error("invalid ciphertext length: smaller than tagLength=" + i3);
      return c7(s2.decrypt.length, f6), s2.decrypt(l7, f6);
    } };
  }
  return Object.assign(n4, t), n4;
};
function Br2(t, e, n4 = true) {
  if (e === void 0) return new Uint8Array(t);
  if (e.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e.length);
  if (n4 && !vs(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function Ir(t, e, n4, r3) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n4, r3);
  const o4 = BigInt(32), i3 = BigInt(4294967295), s2 = Number(n4 >> o4 & i3), c7 = Number(n4 & i3), a5 = r3 ? 4 : 0, u4 = r3 ? 0 : 4;
  t.setUint32(e + a5, s2, r3), t.setUint32(e + u4, c7, r3);
}
function vs(t) {
  return t.byteOffset % 4 === 0;
}
function ze(t) {
  return Uint8Array.from(t);
}
function Lt(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
var Nr = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0)));
var xs = Nr("expand 16-byte k");
var Ss = Nr("expand 32-byte k");
var Os = mt(xs);
var As = mt(Ss);
function V(t, e) {
  return t << e | t >>> 32 - e;
}
function Ze(t) {
  return t.byteOffset % 4 === 0;
}
var he = 64;
var Bs = 16;
var Ur = 2 ** 32 - 1;
var Tr = new Uint32Array();
function Is(t, e, n4, r3, o4, i3, s2, c7) {
  const a5 = o4.length, u4 = new Uint8Array(he), l7 = mt(u4), f6 = Ze(o4) && Ze(i3), h7 = f6 ? mt(o4) : Tr, y10 = f6 ? mt(i3) : Tr;
  for (let E6 = 0; E6 < a5; s2++) {
    if (t(e, n4, r3, l7, s2, c7), s2 >= Ur) throw new Error("arx: counter overflow");
    const p5 = Math.min(he, a5 - E6);
    if (f6 && p5 === he) {
      const d5 = E6 / 4;
      if (E6 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let v7 = 0, m2; v7 < Bs; v7++) m2 = d5 + v7, y10[m2] = h7[m2] ^ l7[v7];
      E6 += he;
      continue;
    }
    for (let d5 = 0, v7; d5 < p5; d5++) v7 = E6 + d5, i3[v7] = o4[v7] ^ u4[d5];
    E6 += p5;
  }
}
function Ns(t, e) {
  const { allowShortKeys: n4, extendNonceFn: r3, counterLength: o4, counterRight: i3, rounds: s2 } = ws({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e);
  if (typeof t != "function") throw new Error("core must be a function");
  return Ke(o4), Ke(s2), Ar(i3), Ar(n4), (c7, a5, u4, l7, f6 = 0) => {
    tt(c7), tt(a5), tt(u4);
    const h7 = u4.length;
    if (l7 === void 0 && (l7 = new Uint8Array(h7)), tt(l7), Ke(f6), f6 < 0 || f6 >= Ur) throw new Error("arx: counter overflow");
    if (l7.length < h7) throw new Error(`arx: output (${l7.length}) is shorter than data (${h7})`);
    const y10 = [];
    let E6 = c7.length, p5, d5;
    if (E6 === 32) y10.push(p5 = ze(c7)), d5 = As;
    else if (E6 === 16 && n4) p5 = new Uint8Array(32), p5.set(c7), p5.set(c7, 16), d5 = Os, y10.push(p5);
    else throw new Error(`arx: invalid 32-byte key, got length=${E6}`);
    Ze(a5) || y10.push(a5 = ze(a5));
    const v7 = mt(p5);
    if (r3) {
      if (a5.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r3(d5, v7, mt(a5.subarray(0, 16)), v7), a5 = a5.subarray(16);
    }
    const m2 = 16 - o4;
    if (m2 !== a5.length) throw new Error(`arx: nonce must be ${m2} or 16 bytes`);
    if (m2 !== 12) {
      const N4 = new Uint8Array(12);
      N4.set(a5, i3 ? 0 : 12 - a5.length), a5 = N4, y10.push(a5);
    }
    const O8 = mt(a5);
    return Is(t, d5, v7, O8, u4, l7, f6, s2), Lt(...y10), l7;
  };
}
var F = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;
var Us = class {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e = Fe(e), tt(e, 32);
    const n4 = F(e, 0), r3 = F(e, 2), o4 = F(e, 4), i3 = F(e, 6), s2 = F(e, 8), c7 = F(e, 10), a5 = F(e, 12), u4 = F(e, 14);
    this.r[0] = n4 & 8191, this.r[1] = (n4 >>> 13 | r3 << 3) & 8191, this.r[2] = (r3 >>> 10 | o4 << 6) & 7939, this.r[3] = (o4 >>> 7 | i3 << 9) & 8191, this.r[4] = (i3 >>> 4 | s2 << 12) & 255, this.r[5] = s2 >>> 1 & 8190, this.r[6] = (s2 >>> 14 | c7 << 2) & 8191, this.r[7] = (c7 >>> 11 | a5 << 5) & 8065, this.r[8] = (a5 >>> 8 | u4 << 8) & 8191, this.r[9] = u4 >>> 5 & 127;
    for (let l7 = 0; l7 < 8; l7++) this.pad[l7] = F(e, 16 + 2 * l7);
  }
  process(e, n4, r3 = false) {
    const o4 = r3 ? 0 : 2048, { h: i3, r: s2 } = this, c7 = s2[0], a5 = s2[1], u4 = s2[2], l7 = s2[3], f6 = s2[4], h7 = s2[5], y10 = s2[6], E6 = s2[7], p5 = s2[8], d5 = s2[9], v7 = F(e, n4 + 0), m2 = F(e, n4 + 2), O8 = F(e, n4 + 4), N4 = F(e, n4 + 6), $5 = F(e, n4 + 8), B5 = F(e, n4 + 10), A5 = F(e, n4 + 12), T4 = F(e, n4 + 14);
    let S7 = i3[0] + (v7 & 8191), L4 = i3[1] + ((v7 >>> 13 | m2 << 3) & 8191), U5 = i3[2] + ((m2 >>> 10 | O8 << 6) & 8191), _5 = i3[3] + ((O8 >>> 7 | N4 << 9) & 8191), j7 = i3[4] + ((N4 >>> 4 | $5 << 12) & 8191), g4 = i3[5] + ($5 >>> 1 & 8191), w6 = i3[6] + (($5 >>> 14 | B5 << 2) & 8191), b6 = i3[7] + ((B5 >>> 11 | A5 << 5) & 8191), I5 = i3[8] + ((A5 >>> 8 | T4 << 8) & 8191), R6 = i3[9] + (T4 >>> 5 | o4), x7 = 0, C5 = x7 + S7 * c7 + L4 * (5 * d5) + U5 * (5 * p5) + _5 * (5 * E6) + j7 * (5 * y10);
    x7 = C5 >>> 13, C5 &= 8191, C5 += g4 * (5 * h7) + w6 * (5 * f6) + b6 * (5 * l7) + I5 * (5 * u4) + R6 * (5 * a5), x7 += C5 >>> 13, C5 &= 8191;
    let P5 = x7 + S7 * a5 + L4 * c7 + U5 * (5 * d5) + _5 * (5 * p5) + j7 * (5 * E6);
    x7 = P5 >>> 13, P5 &= 8191, P5 += g4 * (5 * y10) + w6 * (5 * h7) + b6 * (5 * f6) + I5 * (5 * l7) + R6 * (5 * u4), x7 += P5 >>> 13, P5 &= 8191;
    let k6 = x7 + S7 * u4 + L4 * a5 + U5 * c7 + _5 * (5 * d5) + j7 * (5 * p5);
    x7 = k6 >>> 13, k6 &= 8191, k6 += g4 * (5 * E6) + w6 * (5 * y10) + b6 * (5 * h7) + I5 * (5 * f6) + R6 * (5 * l7), x7 += k6 >>> 13, k6 &= 8191;
    let M6 = x7 + S7 * l7 + L4 * u4 + U5 * a5 + _5 * c7 + j7 * (5 * d5);
    x7 = M6 >>> 13, M6 &= 8191, M6 += g4 * (5 * p5) + w6 * (5 * E6) + b6 * (5 * y10) + I5 * (5 * h7) + R6 * (5 * f6), x7 += M6 >>> 13, M6 &= 8191;
    let D5 = x7 + S7 * f6 + L4 * l7 + U5 * u4 + _5 * a5 + j7 * c7;
    x7 = D5 >>> 13, D5 &= 8191, D5 += g4 * (5 * d5) + w6 * (5 * p5) + b6 * (5 * E6) + I5 * (5 * y10) + R6 * (5 * h7), x7 += D5 >>> 13, D5 &= 8191;
    let z9 = x7 + S7 * h7 + L4 * f6 + U5 * l7 + _5 * u4 + j7 * a5;
    x7 = z9 >>> 13, z9 &= 8191, z9 += g4 * c7 + w6 * (5 * d5) + b6 * (5 * p5) + I5 * (5 * E6) + R6 * (5 * y10), x7 += z9 >>> 13, z9 &= 8191;
    let Z5 = x7 + S7 * y10 + L4 * h7 + U5 * f6 + _5 * l7 + j7 * u4;
    x7 = Z5 >>> 13, Z5 &= 8191, Z5 += g4 * a5 + w6 * c7 + b6 * (5 * d5) + I5 * (5 * p5) + R6 * (5 * E6), x7 += Z5 >>> 13, Z5 &= 8191;
    let it5 = x7 + S7 * E6 + L4 * y10 + U5 * h7 + _5 * f6 + j7 * l7;
    x7 = it5 >>> 13, it5 &= 8191, it5 += g4 * u4 + w6 * a5 + b6 * c7 + I5 * (5 * d5) + R6 * (5 * p5), x7 += it5 >>> 13, it5 &= 8191;
    let W3 = x7 + S7 * p5 + L4 * E6 + U5 * y10 + _5 * h7 + j7 * f6;
    x7 = W3 >>> 13, W3 &= 8191, W3 += g4 * l7 + w6 * u4 + b6 * a5 + I5 * c7 + R6 * (5 * d5), x7 += W3 >>> 13, W3 &= 8191;
    let J2 = x7 + S7 * d5 + L4 * p5 + U5 * E6 + _5 * y10 + j7 * h7;
    x7 = J2 >>> 13, J2 &= 8191, J2 += g4 * f6 + w6 * l7 + b6 * u4 + I5 * a5 + R6 * c7, x7 += J2 >>> 13, J2 &= 8191, x7 = (x7 << 2) + x7 | 0, x7 = x7 + C5 | 0, C5 = x7 & 8191, x7 = x7 >>> 13, P5 += x7, i3[0] = C5, i3[1] = P5, i3[2] = k6, i3[3] = M6, i3[4] = D5, i3[5] = z9, i3[6] = Z5, i3[7] = it5, i3[8] = W3, i3[9] = J2;
  }
  finalize() {
    const { h: e, pad: n4 } = this, r3 = new Uint16Array(10);
    let o4 = e[1] >>> 13;
    e[1] &= 8191;
    for (let c7 = 2; c7 < 10; c7++) e[c7] += o4, o4 = e[c7] >>> 13, e[c7] &= 8191;
    e[0] += o4 * 5, o4 = e[0] >>> 13, e[0] &= 8191, e[1] += o4, o4 = e[1] >>> 13, e[1] &= 8191, e[2] += o4, r3[0] = e[0] + 5, o4 = r3[0] >>> 13, r3[0] &= 8191;
    for (let c7 = 1; c7 < 10; c7++) r3[c7] = e[c7] + o4, o4 = r3[c7] >>> 13, r3[c7] &= 8191;
    r3[9] -= 8192;
    let i3 = (o4 ^ 1) - 1;
    for (let c7 = 0; c7 < 10; c7++) r3[c7] &= i3;
    i3 = ~i3;
    for (let c7 = 0; c7 < 10; c7++) e[c7] = e[c7] & i3 | r3[c7];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let s2 = e[0] + n4[0];
    e[0] = s2 & 65535;
    for (let c7 = 1; c7 < 8; c7++) s2 = (e[c7] + n4[c7] | 0) + (s2 >>> 16) | 0, e[c7] = s2 & 65535;
    Lt(r3);
  }
  update(e) {
    Or(this);
    const { buffer: n4, blockLen: r3 } = this;
    e = Fe(e);
    const o4 = e.length;
    for (let i3 = 0; i3 < o4; ) {
      const s2 = Math.min(r3 - this.pos, o4 - i3);
      if (s2 === r3) {
        for (; r3 <= o4 - i3; i3 += r3) this.process(e, i3);
        continue;
      }
      n4.set(e.subarray(i3, i3 + s2), this.pos), this.pos += s2, i3 += s2, this.pos === r3 && (this.process(n4, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Lt(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    Or(this), ps(e, this), this.finished = true;
    const { buffer: n4, h: r3 } = this;
    let { pos: o4 } = this;
    if (o4) {
      for (n4[o4++] = 1; o4 < 16; o4++) n4[o4] = 0;
      this.process(n4, 0, true);
    }
    this.finalize();
    let i3 = 0;
    for (let s2 = 0; s2 < 8; s2++) e[i3++] = r3[s2] >>> 0, e[i3++] = r3[s2] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: n4 } = this;
    this.digestInto(e);
    const r3 = e.slice(0, n4);
    return this.destroy(), r3;
  }
};
function Ts(t) {
  const e = (r3, o4) => t(o4).update(Fe(r3)).digest(), n4 = t(new Uint8Array(32));
  return e.outputLen = n4.outputLen, e.blockLen = n4.blockLen, e.create = (r3) => t(r3), e;
}
var Rs = Ts((t) => new Us(t));
function _s(t, e, n4, r3, o4, i3 = 20) {
  let s2 = t[0], c7 = t[1], a5 = t[2], u4 = t[3], l7 = e[0], f6 = e[1], h7 = e[2], y10 = e[3], E6 = e[4], p5 = e[5], d5 = e[6], v7 = e[7], m2 = o4, O8 = n4[0], N4 = n4[1], $5 = n4[2], B5 = s2, A5 = c7, T4 = a5, S7 = u4, L4 = l7, U5 = f6, _5 = h7, j7 = y10, g4 = E6, w6 = p5, b6 = d5, I5 = v7, R6 = m2, x7 = O8, C5 = N4, P5 = $5;
  for (let M6 = 0; M6 < i3; M6 += 2) B5 = B5 + L4 | 0, R6 = V(R6 ^ B5, 16), g4 = g4 + R6 | 0, L4 = V(L4 ^ g4, 12), B5 = B5 + L4 | 0, R6 = V(R6 ^ B5, 8), g4 = g4 + R6 | 0, L4 = V(L4 ^ g4, 7), A5 = A5 + U5 | 0, x7 = V(x7 ^ A5, 16), w6 = w6 + x7 | 0, U5 = V(U5 ^ w6, 12), A5 = A5 + U5 | 0, x7 = V(x7 ^ A5, 8), w6 = w6 + x7 | 0, U5 = V(U5 ^ w6, 7), T4 = T4 + _5 | 0, C5 = V(C5 ^ T4, 16), b6 = b6 + C5 | 0, _5 = V(_5 ^ b6, 12), T4 = T4 + _5 | 0, C5 = V(C5 ^ T4, 8), b6 = b6 + C5 | 0, _5 = V(_5 ^ b6, 7), S7 = S7 + j7 | 0, P5 = V(P5 ^ S7, 16), I5 = I5 + P5 | 0, j7 = V(j7 ^ I5, 12), S7 = S7 + j7 | 0, P5 = V(P5 ^ S7, 8), I5 = I5 + P5 | 0, j7 = V(j7 ^ I5, 7), B5 = B5 + U5 | 0, P5 = V(P5 ^ B5, 16), b6 = b6 + P5 | 0, U5 = V(U5 ^ b6, 12), B5 = B5 + U5 | 0, P5 = V(P5 ^ B5, 8), b6 = b6 + P5 | 0, U5 = V(U5 ^ b6, 7), A5 = A5 + _5 | 0, R6 = V(R6 ^ A5, 16), I5 = I5 + R6 | 0, _5 = V(_5 ^ I5, 12), A5 = A5 + _5 | 0, R6 = V(R6 ^ A5, 8), I5 = I5 + R6 | 0, _5 = V(_5 ^ I5, 7), T4 = T4 + j7 | 0, x7 = V(x7 ^ T4, 16), g4 = g4 + x7 | 0, j7 = V(j7 ^ g4, 12), T4 = T4 + j7 | 0, x7 = V(x7 ^ T4, 8), g4 = g4 + x7 | 0, j7 = V(j7 ^ g4, 7), S7 = S7 + L4 | 0, C5 = V(C5 ^ S7, 16), w6 = w6 + C5 | 0, L4 = V(L4 ^ w6, 12), S7 = S7 + L4 | 0, C5 = V(C5 ^ S7, 8), w6 = w6 + C5 | 0, L4 = V(L4 ^ w6, 7);
  let k6 = 0;
  r3[k6++] = s2 + B5 | 0, r3[k6++] = c7 + A5 | 0, r3[k6++] = a5 + T4 | 0, r3[k6++] = u4 + S7 | 0, r3[k6++] = l7 + L4 | 0, r3[k6++] = f6 + U5 | 0, r3[k6++] = h7 + _5 | 0, r3[k6++] = y10 + j7 | 0, r3[k6++] = E6 + g4 | 0, r3[k6++] = p5 + w6 | 0, r3[k6++] = d5 + b6 | 0, r3[k6++] = v7 + I5 | 0, r3[k6++] = m2 + R6 | 0, r3[k6++] = O8 + x7 | 0, r3[k6++] = N4 + C5 | 0, r3[k6++] = $5 + P5 | 0;
}
var $s = Ns(_s, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Ls = new Uint8Array(16);
var Rr = (t, e) => {
  t.update(e);
  const n4 = e.length % 16;
  n4 && t.update(Ls.subarray(n4));
};
var js = new Uint8Array(32);
function _r(t, e, n4, r3, o4) {
  const i3 = t(e, n4, js), s2 = Rs.create(i3);
  o4 && Rr(s2, o4), Rr(s2, r3);
  const c7 = new Uint8Array(16), a5 = gs(c7);
  Ir(a5, 0, BigInt(o4 ? o4.length : 0), true), Ir(a5, 8, BigInt(r3.length), true), s2.update(c7);
  const u4 = s2.digest();
  return Lt(i3, c7), u4;
}
var Cs = (t) => (e, n4, r3) => ({ encrypt(i3, s2) {
  const c7 = i3.length;
  s2 = Br2(c7 + 16, s2, false), s2.set(i3);
  const a5 = s2.subarray(0, -16);
  t(e, n4, a5, a5, 1);
  const u4 = _r(t, e, n4, a5, r3);
  return s2.set(u4, c7), Lt(u4), s2;
}, decrypt(i3, s2) {
  s2 = Br2(i3.length - 16, s2, false);
  const c7 = i3.subarray(0, -16), a5 = i3.subarray(-16), u4 = _r(t, e, n4, c7, r3);
  if (!bs(a5, u4)) throw new Error("invalid tag");
  return s2.set(i3.subarray(0, -16)), t(e, n4, s2, s2, 1), Lt(u4), s2;
} });
var $r = Es({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Cs($s));
var Lr = class extends Pe {
  constructor(e, n4) {
    super(), this.finished = false, this.destroyed = false, je(e);
    const r3 = _t(n4);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o4 = this.blockLen, i3 = new Uint8Array(o4);
    i3.set(r3.length > o4 ? e.create().update(r3).digest() : r3);
    for (let s2 = 0; s2 < i3.length; s2++) i3[s2] ^= 54;
    this.iHash.update(i3), this.oHash = e.create();
    for (let s2 = 0; s2 < i3.length; s2++) i3[s2] ^= 106;
    this.oHash.update(i3), i3.fill(0);
  }
  update(e) {
    return Tt(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Tt(this), Wt(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n4, iHash: r3, finished: o4, destroyed: i3, blockLen: s2, outputLen: c7 } = this;
    return e = e, e.finished = o4, e.destroyed = i3, e.blockLen = s2, e.outputLen = c7, e.oHash = n4._cloneInto(e.oHash), e.iHash = r3._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var pe = (t, e, n4) => new Lr(t, e).update(n4).digest();
pe.create = (t, e) => new Lr(t, e);
function Ps(t, e, n4) {
  return je(t), n4 === void 0 && (n4 = new Uint8Array(t.outputLen)), pe(t, _t(n4), _t(e));
}
var Ye = new Uint8Array([0]);
var jr = new Uint8Array();
function ks(t, e, n4, r3 = 32) {
  if (je(t), Gt(r3), r3 > 255 * t.outputLen) throw new Error("Length should be <= 255*HashLen");
  const o4 = Math.ceil(r3 / t.outputLen);
  n4 === void 0 && (n4 = jr);
  const i3 = new Uint8Array(o4 * t.outputLen), s2 = pe.create(t, e), c7 = s2._cloneInto(), a5 = new Uint8Array(s2.outputLen);
  for (let u4 = 0; u4 < o4; u4++) Ye[0] = u4 + 1, c7.update(u4 === 0 ? jr : a5).update(n4).update(Ye).digestInto(a5), i3.set(a5, t.outputLen * u4), s2._cloneInto(c7);
  return s2.destroy(), c7.destroy(), a5.fill(0), Ye.fill(0), i3.slice(0, r3);
}
var Vs = (t, e, n4, r3, o4) => ks(t, Ps(t, e, n4), r3, o4);
function Ms(t, e, n4, r3) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n4, r3);
  const o4 = BigInt(32), i3 = BigInt(4294967295), s2 = Number(n4 >> o4 & i3), c7 = Number(n4 & i3), a5 = r3 ? 4 : 0, u4 = r3 ? 0 : 4;
  t.setUint32(e + a5, s2, r3), t.setUint32(e + u4, c7, r3);
}
function Ds(t, e, n4) {
  return t & e ^ ~t & n4;
}
function Hs(t, e, n4) {
  return t & e ^ t & n4 ^ e & n4;
}
var qs = class extends Pe {
  constructor(e, n4, r3, o4) {
    super(), this.blockLen = e, this.outputLen = n4, this.padOffset = r3, this.isLE = o4, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = Ce(this.buffer);
  }
  update(e) {
    Tt(this);
    const { view: n4, buffer: r3, blockLen: o4 } = this;
    e = _t(e);
    const i3 = e.length;
    for (let s2 = 0; s2 < i3; ) {
      const c7 = Math.min(o4 - this.pos, i3 - s2);
      if (c7 === o4) {
        const a5 = Ce(e);
        for (; o4 <= i3 - s2; s2 += o4) this.process(a5, s2);
        continue;
      }
      r3.set(e.subarray(s2, s2 + c7), this.pos), this.pos += c7, s2 += c7, this.pos === o4 && (this.process(n4, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Tt(this), Gn(e, this), this.finished = true;
    const { buffer: n4, view: r3, blockLen: o4, isLE: i3 } = this;
    let { pos: s2 } = this;
    n4[s2++] = 128, this.buffer.subarray(s2).fill(0), this.padOffset > o4 - s2 && (this.process(r3, 0), s2 = 0);
    for (let f6 = s2; f6 < o4; f6++) n4[f6] = 0;
    Ms(r3, o4 - 8, BigInt(this.length * 8), i3), this.process(r3, 0);
    const c7 = Ce(e), a5 = this.outputLen;
    if (a5 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u4 = a5 / 4, l7 = this.get();
    if (u4 > l7.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f6 = 0; f6 < u4; f6++) c7.setUint32(4 * f6, l7[f6], i3);
  }
  digest() {
    const { buffer: e, outputLen: n4 } = this;
    this.digestInto(e);
    const r3 = e.slice(0, n4);
    return this.destroy(), r3;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n4, buffer: r3, length: o4, finished: i3, destroyed: s2, pos: c7 } = this;
    return e.length = o4, e.pos = c7, e.finished = i3, e.destroyed = s2, o4 % n4 && e.buffer.set(r3), e;
  }
};
var Ks = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var wt = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var bt = new Uint32Array(64);
var Fs = class extends qs {
  constructor() {
    super(64, 32, 8, false), this.A = wt[0] | 0, this.B = wt[1] | 0, this.C = wt[2] | 0, this.D = wt[3] | 0, this.E = wt[4] | 0, this.F = wt[5] | 0, this.G = wt[6] | 0, this.H = wt[7] | 0;
  }
  get() {
    const { A: e, B: n4, C: r3, D: o4, E: i3, F: s2, G: c7, H: a5 } = this;
    return [e, n4, r3, o4, i3, s2, c7, a5];
  }
  set(e, n4, r3, o4, i3, s2, c7, a5) {
    this.A = e | 0, this.B = n4 | 0, this.C = r3 | 0, this.D = o4 | 0, this.E = i3 | 0, this.F = s2 | 0, this.G = c7 | 0, this.H = a5 | 0;
  }
  process(e, n4) {
    for (let f6 = 0; f6 < 16; f6++, n4 += 4) bt[f6] = e.getUint32(n4, false);
    for (let f6 = 16; f6 < 64; f6++) {
      const h7 = bt[f6 - 15], y10 = bt[f6 - 2], E6 = st(h7, 7) ^ st(h7, 18) ^ h7 >>> 3, p5 = st(y10, 17) ^ st(y10, 19) ^ y10 >>> 10;
      bt[f6] = p5 + bt[f6 - 7] + E6 + bt[f6 - 16] | 0;
    }
    let { A: r3, B: o4, C: i3, D: s2, E: c7, F: a5, G: u4, H: l7 } = this;
    for (let f6 = 0; f6 < 64; f6++) {
      const h7 = st(c7, 6) ^ st(c7, 11) ^ st(c7, 25), y10 = l7 + h7 + Ds(c7, a5, u4) + Ks[f6] + bt[f6] | 0, p5 = (st(r3, 2) ^ st(r3, 13) ^ st(r3, 22)) + Hs(r3, o4, i3) | 0;
      l7 = u4, u4 = a5, a5 = c7, c7 = s2 + y10 | 0, s2 = i3, i3 = o4, o4 = r3, r3 = y10 + p5 | 0;
    }
    r3 = r3 + this.A | 0, o4 = o4 + this.B | 0, i3 = i3 + this.C | 0, s2 = s2 + this.D | 0, c7 = c7 + this.E | 0, a5 = a5 + this.F | 0, u4 = u4 + this.G | 0, l7 = l7 + this.H | 0, this.set(r3, o4, i3, s2, c7, a5, u4, l7);
  }
  roundClean() {
    bt.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var Jt = Qn(() => new Fs());
var ge = BigInt(0);
var ye = BigInt(1);
var zs = BigInt(2);
function St(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Qt(t) {
  if (!St(t)) throw new Error("Uint8Array expected");
}
function jt(t, e) {
  if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e);
}
var Zs = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Ct(t) {
  Qt(t);
  let e = "";
  for (let n4 = 0; n4 < t.length; n4++) e += Zs[t[n4]];
  return e;
}
function Pt(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function Ge(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? ge : BigInt("0x" + t);
}
var ut = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Cr(t) {
  if (t >= ut._0 && t <= ut._9) return t - ut._0;
  if (t >= ut.A && t <= ut.F) return t - (ut.A - 10);
  if (t >= ut.a && t <= ut.f) return t - (ut.a - 10);
}
function kt(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  const e = t.length, n4 = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const r3 = new Uint8Array(n4);
  for (let o4 = 0, i3 = 0; o4 < n4; o4++, i3 += 2) {
    const s2 = Cr(t.charCodeAt(i3)), c7 = Cr(t.charCodeAt(i3 + 1));
    if (s2 === void 0 || c7 === void 0) {
      const a5 = t[i3] + t[i3 + 1];
      throw new Error('hex string expected, got non-hex character "' + a5 + '" at index ' + i3);
    }
    r3[o4] = s2 * 16 + c7;
  }
  return r3;
}
function Ot(t) {
  return Ge(Ct(t));
}
function te(t) {
  return Qt(t), Ge(Ct(Uint8Array.from(t).reverse()));
}
function Vt(t, e) {
  return kt(t.toString(16).padStart(e * 2, "0"));
}
function me(t, e) {
  return Vt(t, e).reverse();
}
function Ys(t) {
  return kt(Pt(t));
}
function et(t, e, n4) {
  let r3;
  if (typeof e == "string") try {
    r3 = kt(e);
  } catch (i3) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + i3);
  }
  else if (St(e)) r3 = Uint8Array.from(e);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o4 = r3.length;
  if (typeof n4 == "number" && o4 !== n4) throw new Error(t + " of length " + n4 + " expected, got " + o4);
  return r3;
}
function ee(...t) {
  let e = 0;
  for (let r3 = 0; r3 < t.length; r3++) {
    const o4 = t[r3];
    Qt(o4), e += o4.length;
  }
  const n4 = new Uint8Array(e);
  for (let r3 = 0, o4 = 0; r3 < t.length; r3++) {
    const i3 = t[r3];
    n4.set(i3, o4), o4 += i3.length;
  }
  return n4;
}
function Gs(t, e) {
  if (t.length !== e.length) return false;
  let n4 = 0;
  for (let r3 = 0; r3 < t.length; r3++) n4 |= t[r3] ^ e[r3];
  return n4 === 0;
}
function Ws(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
var We = (t) => typeof t == "bigint" && ge <= t;
function we(t, e, n4) {
  return We(t) && We(e) && We(n4) && e <= t && t < n4;
}
function ft(t, e, n4, r3) {
  if (!we(e, n4, r3)) throw new Error("expected valid " + t + ": " + n4 + " <= n < " + r3 + ", got " + e);
}
function Pr(t) {
  let e;
  for (e = 0; t > ge; t >>= ye, e += 1) ;
  return e;
}
function Xs(t, e) {
  return t >> BigInt(e) & ye;
}
function Js(t, e, n4) {
  return t | (n4 ? ye : ge) << BigInt(e);
}
var Xe = (t) => (zs << BigInt(t - 1)) - ye;
var Je = (t) => new Uint8Array(t);
var kr = (t) => Uint8Array.from(t);
function Vr(t, e, n4) {
  if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
  if (typeof n4 != "function") throw new Error("hmacFn must be a function");
  let r3 = Je(t), o4 = Je(t), i3 = 0;
  const s2 = () => {
    r3.fill(1), o4.fill(0), i3 = 0;
  }, c7 = (...f6) => n4(o4, r3, ...f6), a5 = (f6 = Je()) => {
    o4 = c7(kr([0]), f6), r3 = c7(), f6.length !== 0 && (o4 = c7(kr([1]), f6), r3 = c7());
  }, u4 = () => {
    if (i3++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let f6 = 0;
    const h7 = [];
    for (; f6 < e; ) {
      r3 = c7();
      const y10 = r3.slice();
      h7.push(y10), f6 += r3.length;
    }
    return ee(...h7);
  };
  return (f6, h7) => {
    s2(), a5(f6);
    let y10;
    for (; !(y10 = h7(u4())); ) a5();
    return s2(), y10;
  };
}
var Qs = { bigint: (t) => typeof t == "bigint", function: (t) => typeof t == "function", boolean: (t) => typeof t == "boolean", string: (t) => typeof t == "string", stringOrUint8Array: (t) => typeof t == "string" || St(t), isSafeInteger: (t) => Number.isSafeInteger(t), array: (t) => Array.isArray(t), field: (t, e) => e.Fp.isValid(t), hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen) };
function Mt(t, e, n4 = {}) {
  const r3 = (o4, i3, s2) => {
    const c7 = Qs[i3];
    if (typeof c7 != "function") throw new Error("invalid validator function");
    const a5 = t[o4];
    if (!(s2 && a5 === void 0) && !c7(a5, t)) throw new Error("param " + String(o4) + " is invalid. Expected " + i3 + ", got " + a5);
  };
  for (const [o4, i3] of Object.entries(e)) r3(o4, i3, false);
  for (const [o4, i3] of Object.entries(n4)) r3(o4, i3, true);
  return t;
}
var tc = () => {
  throw new Error("not implemented");
};
function Qe2(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n4, ...r3) => {
    const o4 = e.get(n4);
    if (o4 !== void 0) return o4;
    const i3 = t(n4, ...r3);
    return e.set(n4, i3), i3;
  };
}
var ec = Object.freeze({ __proto__: null, isBytes: St, abytes: Qt, abool: jt, bytesToHex: Ct, numberToHexUnpadded: Pt, hexToNumber: Ge, hexToBytes: kt, bytesToNumberBE: Ot, bytesToNumberLE: te, numberToBytesBE: Vt, numberToBytesLE: me, numberToVarBytesBE: Ys, ensureBytes: et, concatBytes: ee, equalBytes: Gs, utf8ToBytes: Ws, inRange: we, aInRange: ft, bitLen: Pr, bitGet: Xs, bitSet: Js, bitMask: Xe, createHmacDrbg: Vr, validateObject: Mt, notImplemented: tc, memoized: Qe2 });
var q = BigInt(0);
var H = BigInt(1);
var At = BigInt(2);
var nc = BigInt(3);
var tn = BigInt(4);
var Mr = BigInt(5);
var Dr = BigInt(8);
function X(t, e) {
  const n4 = t % e;
  return n4 >= q ? n4 : e + n4;
}
function Hr(t, e, n4) {
  if (e < q) throw new Error("invalid exponent, negatives unsupported");
  if (n4 <= q) throw new Error("invalid modulus");
  if (n4 === H) return q;
  let r3 = H;
  for (; e > q; ) e & H && (r3 = r3 * t % n4), t = t * t % n4, e >>= H;
  return r3;
}
function ot(t, e, n4) {
  let r3 = t;
  for (; e-- > q; ) r3 *= r3, r3 %= n4;
  return r3;
}
function en(t, e) {
  if (t === q) throw new Error("invert: expected non-zero number");
  if (e <= q) throw new Error("invert: expected positive modulus, got " + e);
  let n4 = X(t, e), r3 = e, o4 = q, i3 = H;
  for (; n4 !== q; ) {
    const c7 = r3 / n4, a5 = r3 % n4, u4 = o4 - i3 * c7;
    r3 = n4, n4 = a5, o4 = i3, i3 = u4;
  }
  if (r3 !== H) throw new Error("invert: does not exist");
  return X(o4, e);
}
function rc(t) {
  const e = (t - H) / At;
  let n4, r3, o4;
  for (n4 = t - H, r3 = 0; n4 % At === q; n4 /= At, r3++) ;
  for (o4 = At; o4 < t && Hr(o4, e, t) !== t - H; o4++) if (o4 > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (r3 === 1) {
    const s2 = (t + H) / tn;
    return function(a5, u4) {
      const l7 = a5.pow(u4, s2);
      if (!a5.eql(a5.sqr(l7), u4)) throw new Error("Cannot find square root");
      return l7;
    };
  }
  const i3 = (n4 + H) / At;
  return function(c7, a5) {
    if (c7.pow(a5, e) === c7.neg(c7.ONE)) throw new Error("Cannot find square root");
    let u4 = r3, l7 = c7.pow(c7.mul(c7.ONE, o4), n4), f6 = c7.pow(a5, i3), h7 = c7.pow(a5, n4);
    for (; !c7.eql(h7, c7.ONE); ) {
      if (c7.eql(h7, c7.ZERO)) return c7.ZERO;
      let y10 = 1;
      for (let p5 = c7.sqr(h7); y10 < u4 && !c7.eql(p5, c7.ONE); y10++) p5 = c7.sqr(p5);
      const E6 = c7.pow(l7, H << BigInt(u4 - y10 - 1));
      l7 = c7.sqr(E6), f6 = c7.mul(f6, E6), h7 = c7.mul(h7, l7), u4 = y10;
    }
    return f6;
  };
}
function oc(t) {
  if (t % tn === nc) {
    const e = (t + H) / tn;
    return function(r3, o4) {
      const i3 = r3.pow(o4, e);
      if (!r3.eql(r3.sqr(i3), o4)) throw new Error("Cannot find square root");
      return i3;
    };
  }
  if (t % Dr === Mr) {
    const e = (t - Mr) / Dr;
    return function(r3, o4) {
      const i3 = r3.mul(o4, At), s2 = r3.pow(i3, e), c7 = r3.mul(o4, s2), a5 = r3.mul(r3.mul(c7, At), s2), u4 = r3.mul(c7, r3.sub(a5, r3.ONE));
      if (!r3.eql(r3.sqr(u4), o4)) throw new Error("Cannot find square root");
      return u4;
    };
  }
  return rc(t);
}
var ic = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function sc(t) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, n4 = ic.reduce((r3, o4) => (r3[o4] = "function", r3), e);
  return Mt(t, n4);
}
function cc(t, e, n4) {
  if (n4 < q) throw new Error("invalid exponent, negatives unsupported");
  if (n4 === q) return t.ONE;
  if (n4 === H) return e;
  let r3 = t.ONE, o4 = e;
  for (; n4 > q; ) n4 & H && (r3 = t.mul(r3, o4)), o4 = t.sqr(o4), n4 >>= H;
  return r3;
}
function ac(t, e) {
  const n4 = new Array(e.length), r3 = e.reduce((i3, s2, c7) => t.is0(s2) ? i3 : (n4[c7] = i3, t.mul(i3, s2)), t.ONE), o4 = t.inv(r3);
  return e.reduceRight((i3, s2, c7) => t.is0(s2) ? i3 : (n4[c7] = t.mul(i3, n4[c7]), t.mul(i3, s2)), o4), n4;
}
function qr(t, e) {
  const n4 = e !== void 0 ? e : t.toString(2).length, r3 = Math.ceil(n4 / 8);
  return { nBitLength: n4, nByteLength: r3 };
}
function Kr(t, e, n4 = false, r3 = {}) {
  if (t <= q) throw new Error("invalid field: expected ORDER > 0, got " + t);
  const { nBitLength: o4, nByteLength: i3 } = qr(t, e);
  if (i3 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let s2;
  const c7 = Object.freeze({ ORDER: t, isLE: n4, BITS: o4, BYTES: i3, MASK: Xe(o4), ZERO: q, ONE: H, create: (a5) => X(a5, t), isValid: (a5) => {
    if (typeof a5 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof a5);
    return q <= a5 && a5 < t;
  }, is0: (a5) => a5 === q, isOdd: (a5) => (a5 & H) === H, neg: (a5) => X(-a5, t), eql: (a5, u4) => a5 === u4, sqr: (a5) => X(a5 * a5, t), add: (a5, u4) => X(a5 + u4, t), sub: (a5, u4) => X(a5 - u4, t), mul: (a5, u4) => X(a5 * u4, t), pow: (a5, u4) => cc(c7, a5, u4), div: (a5, u4) => X(a5 * en(u4, t), t), sqrN: (a5) => a5 * a5, addN: (a5, u4) => a5 + u4, subN: (a5, u4) => a5 - u4, mulN: (a5, u4) => a5 * u4, inv: (a5) => en(a5, t), sqrt: r3.sqrt || ((a5) => (s2 || (s2 = oc(t)), s2(c7, a5))), invertBatch: (a5) => ac(c7, a5), cmov: (a5, u4, l7) => l7 ? u4 : a5, toBytes: (a5) => n4 ? me(a5, i3) : Vt(a5, i3), fromBytes: (a5) => {
    if (a5.length !== i3) throw new Error("Field.fromBytes: expected " + i3 + " bytes, got " + a5.length);
    return n4 ? te(a5) : Ot(a5);
  } });
  return Object.freeze(c7);
}
function Fr(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function zr(t) {
  const e = Fr(t);
  return e + Math.ceil(e / 2);
}
function uc(t, e, n4 = false) {
  const r3 = t.length, o4 = Fr(e), i3 = zr(e);
  if (r3 < 16 || r3 < i3 || r3 > 1024) throw new Error("expected " + i3 + "-1024 bytes of input, got " + r3);
  const s2 = n4 ? te(t) : Ot(t), c7 = X(s2, e - H) + H;
  return n4 ? me(c7, o4) : Vt(c7, o4);
}
var Zr = BigInt(0);
var be = BigInt(1);
function nn(t, e) {
  const n4 = e.negate();
  return t ? n4 : e;
}
function Yr(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function rn(t, e) {
  Yr(t, e);
  const n4 = Math.ceil(e / t) + 1, r3 = 2 ** (t - 1);
  return { windows: n4, windowSize: r3 };
}
function fc(t, e) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n4, r3) => {
    if (!(n4 instanceof e)) throw new Error("invalid point at index " + r3);
  });
}
function lc(t, e) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n4, r3) => {
    if (!e.isValid(n4)) throw new Error("invalid scalar at index " + r3);
  });
}
var on = /* @__PURE__ */ new WeakMap();
var Gr = /* @__PURE__ */ new WeakMap();
function sn2(t) {
  return Gr.get(t) || 1;
}
function dc(t, e) {
  return { constTimeNegate: nn, hasPrecomputes(n4) {
    return sn2(n4) !== 1;
  }, unsafeLadder(n4, r3, o4 = t.ZERO) {
    let i3 = n4;
    for (; r3 > Zr; ) r3 & be && (o4 = o4.add(i3)), i3 = i3.double(), r3 >>= be;
    return o4;
  }, precomputeWindow(n4, r3) {
    const { windows: o4, windowSize: i3 } = rn(r3, e), s2 = [];
    let c7 = n4, a5 = c7;
    for (let u4 = 0; u4 < o4; u4++) {
      a5 = c7, s2.push(a5);
      for (let l7 = 1; l7 < i3; l7++) a5 = a5.add(c7), s2.push(a5);
      c7 = a5.double();
    }
    return s2;
  }, wNAF(n4, r3, o4) {
    const { windows: i3, windowSize: s2 } = rn(n4, e);
    let c7 = t.ZERO, a5 = t.BASE;
    const u4 = BigInt(2 ** n4 - 1), l7 = 2 ** n4, f6 = BigInt(n4);
    for (let h7 = 0; h7 < i3; h7++) {
      const y10 = h7 * s2;
      let E6 = Number(o4 & u4);
      o4 >>= f6, E6 > s2 && (E6 -= l7, o4 += be);
      const p5 = y10, d5 = y10 + Math.abs(E6) - 1, v7 = h7 % 2 !== 0, m2 = E6 < 0;
      E6 === 0 ? a5 = a5.add(nn(v7, r3[p5])) : c7 = c7.add(nn(m2, r3[d5]));
    }
    return { p: c7, f: a5 };
  }, wNAFUnsafe(n4, r3, o4, i3 = t.ZERO) {
    const { windows: s2, windowSize: c7 } = rn(n4, e), a5 = BigInt(2 ** n4 - 1), u4 = 2 ** n4, l7 = BigInt(n4);
    for (let f6 = 0; f6 < s2; f6++) {
      const h7 = f6 * c7;
      if (o4 === Zr) break;
      let y10 = Number(o4 & a5);
      if (o4 >>= l7, y10 > c7 && (y10 -= u4, o4 += be), y10 === 0) continue;
      let E6 = r3[h7 + Math.abs(y10) - 1];
      y10 < 0 && (E6 = E6.negate()), i3 = i3.add(E6);
    }
    return i3;
  }, getPrecomputes(n4, r3, o4) {
    let i3 = on.get(r3);
    return i3 || (i3 = this.precomputeWindow(r3, n4), n4 !== 1 && on.set(r3, o4(i3))), i3;
  }, wNAFCached(n4, r3, o4) {
    const i3 = sn2(n4);
    return this.wNAF(i3, this.getPrecomputes(i3, n4, o4), r3);
  }, wNAFCachedUnsafe(n4, r3, o4, i3) {
    const s2 = sn2(n4);
    return s2 === 1 ? this.unsafeLadder(n4, r3, i3) : this.wNAFUnsafe(s2, this.getPrecomputes(s2, n4, o4), r3, i3);
  }, setWindowSize(n4, r3) {
    Yr(r3, e), Gr.set(n4, r3), on.delete(n4);
  } };
}
function hc(t, e, n4, r3) {
  if (fc(n4, t), lc(r3, e), n4.length !== r3.length) throw new Error("arrays of points and scalars must have equal length");
  const o4 = t.ZERO, i3 = Pr(BigInt(n4.length)), s2 = i3 > 12 ? i3 - 3 : i3 > 4 ? i3 - 2 : i3 ? 2 : 1, c7 = (1 << s2) - 1, a5 = new Array(c7 + 1).fill(o4), u4 = Math.floor((e.BITS - 1) / s2) * s2;
  let l7 = o4;
  for (let f6 = u4; f6 >= 0; f6 -= s2) {
    a5.fill(o4);
    for (let y10 = 0; y10 < r3.length; y10++) {
      const E6 = r3[y10], p5 = Number(E6 >> BigInt(f6) & BigInt(c7));
      a5[p5] = a5[p5].add(n4[y10]);
    }
    let h7 = o4;
    for (let y10 = a5.length - 1, E6 = o4; y10 > 0; y10--) E6 = E6.add(a5[y10]), h7 = h7.add(E6);
    if (l7 = l7.add(h7), f6 !== 0) for (let y10 = 0; y10 < s2; y10++) l7 = l7.double();
  }
  return l7;
}
function Wr(t) {
  return sc(t.Fp), Mt(t, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...qr(t.n, t.nBitLength), ...t, p: t.Fp.ORDER });
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var Dt = BigInt(0);
var cn = BigInt(1);
function pc(t) {
  return Mt(t, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...t });
}
function gc(t) {
  const e = pc(t), { P: n4 } = e, r3 = (m2) => X(m2, n4), o4 = e.montgomeryBits, i3 = Math.ceil(o4 / 8), s2 = e.nByteLength, c7 = e.adjustScalarBytes || ((m2) => m2), a5 = e.powPminus2 || ((m2) => Hr(m2, n4 - BigInt(2), n4));
  function u4(m2, O8, N4) {
    const $5 = r3(m2 * (O8 - N4));
    return O8 = r3(O8 - $5), N4 = r3(N4 + $5), [O8, N4];
  }
  const l7 = (e.a - BigInt(2)) / BigInt(4);
  function f6(m2, O8) {
    ft("u", m2, Dt, n4), ft("scalar", O8, Dt, n4);
    const N4 = O8, $5 = m2;
    let B5 = cn, A5 = Dt, T4 = m2, S7 = cn, L4 = Dt, U5;
    for (let j7 = BigInt(o4 - 1); j7 >= Dt; j7--) {
      const g4 = N4 >> j7 & cn;
      L4 ^= g4, U5 = u4(L4, B5, T4), B5 = U5[0], T4 = U5[1], U5 = u4(L4, A5, S7), A5 = U5[0], S7 = U5[1], L4 = g4;
      const w6 = B5 + A5, b6 = r3(w6 * w6), I5 = B5 - A5, R6 = r3(I5 * I5), x7 = b6 - R6, C5 = T4 + S7, P5 = T4 - S7, k6 = r3(P5 * w6), M6 = r3(C5 * I5), D5 = k6 + M6, z9 = k6 - M6;
      T4 = r3(D5 * D5), S7 = r3($5 * r3(z9 * z9)), B5 = r3(b6 * R6), A5 = r3(x7 * (b6 + r3(l7 * x7)));
    }
    U5 = u4(L4, B5, T4), B5 = U5[0], T4 = U5[1], U5 = u4(L4, A5, S7), A5 = U5[0], S7 = U5[1];
    const _5 = a5(A5);
    return r3(B5 * _5);
  }
  function h7(m2) {
    return me(r3(m2), i3);
  }
  function y10(m2) {
    const O8 = et("u coordinate", m2, i3);
    return s2 === 32 && (O8[31] &= 127), te(O8);
  }
  function E6(m2) {
    const O8 = et("scalar", m2), N4 = O8.length;
    if (N4 !== i3 && N4 !== s2) {
      let $5 = "" + i3 + " or " + s2;
      throw new Error("invalid scalar, expected " + $5 + " bytes, got " + N4);
    }
    return te(c7(O8));
  }
  function p5(m2, O8) {
    const N4 = y10(O8), $5 = E6(m2), B5 = f6(N4, $5);
    if (B5 === Dt) throw new Error("invalid private or public key received");
    return h7(B5);
  }
  const d5 = h7(e.Gu);
  function v7(m2) {
    return p5(m2, d5);
  }
  return { scalarMult: p5, scalarMultBase: v7, getSharedSecret: (m2, O8) => p5(m2, O8), getPublicKey: (m2) => v7(m2), utils: { randomPrivateKey: () => e.randomBytes(e.nByteLength) }, GuBytes: d5 };
}
var an = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
var yc = BigInt(1);
var Xr = BigInt(2);
var mc = BigInt(3);
var wc = BigInt(5);
BigInt(8);
function bc(t) {
  const e = BigInt(10), n4 = BigInt(20), r3 = BigInt(40), o4 = BigInt(80), i3 = an, c7 = t * t % i3 * t % i3, a5 = ot(c7, Xr, i3) * c7 % i3, u4 = ot(a5, yc, i3) * t % i3, l7 = ot(u4, wc, i3) * u4 % i3, f6 = ot(l7, e, i3) * l7 % i3, h7 = ot(f6, n4, i3) * f6 % i3, y10 = ot(h7, r3, i3) * h7 % i3, E6 = ot(y10, o4, i3) * y10 % i3, p5 = ot(E6, o4, i3) * y10 % i3, d5 = ot(p5, e, i3) * l7 % i3;
  return { pow_p_5_8: ot(d5, Xr, i3) * t % i3, b2: c7 };
}
function Ec(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
var un = gc({ P: an, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (t) => {
  const e = an, { pow_p_5_8: n4, b2: r3 } = bc(t);
  return X(ot(n4, mc, e) * r3, e);
}, adjustScalarBytes: Ec, randomBytes: $t });
function Jr(t) {
  t.lowS !== void 0 && jt("lowS", t.lowS), t.prehash !== void 0 && jt("prehash", t.prehash);
}
function vc(t) {
  const e = Wr(t);
  Mt(e, { a: "field", b: "field" }, { allowedPrivateKeyLengths: "array", wrapPrivateKey: "boolean", isTorsionFree: "function", clearCofactor: "function", allowInfinityPoint: "boolean", fromBytes: "function", toBytes: "function" });
  const { endo: n4, Fp: r3, a: o4 } = e;
  if (n4) {
    if (!r3.eql(o4, r3.ZERO)) throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    if (typeof n4 != "object" || typeof n4.beta != "bigint" || typeof n4.splitScalar != "function") throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
var { bytesToNumberBE: xc, hexToBytes: Sc } = ec;
var Oc = class extends Error {
  constructor(e = "") {
    super(e);
  }
};
var lt = { Err: Oc, _tlv: { encode: (t, e) => {
  const { Err: n4 } = lt;
  if (t < 0 || t > 256) throw new n4("tlv.encode: wrong tag");
  if (e.length & 1) throw new n4("tlv.encode: unpadded data");
  const r3 = e.length / 2, o4 = Pt(r3);
  if (o4.length / 2 & 128) throw new n4("tlv.encode: long form length too big");
  const i3 = r3 > 127 ? Pt(o4.length / 2 | 128) : "";
  return Pt(t) + i3 + o4 + e;
}, decode(t, e) {
  const { Err: n4 } = lt;
  let r3 = 0;
  if (t < 0 || t > 256) throw new n4("tlv.encode: wrong tag");
  if (e.length < 2 || e[r3++] !== t) throw new n4("tlv.decode: wrong tlv");
  const o4 = e[r3++], i3 = !!(o4 & 128);
  let s2 = 0;
  if (!i3) s2 = o4;
  else {
    const a5 = o4 & 127;
    if (!a5) throw new n4("tlv.decode(long): indefinite length not supported");
    if (a5 > 4) throw new n4("tlv.decode(long): byte length is too big");
    const u4 = e.subarray(r3, r3 + a5);
    if (u4.length !== a5) throw new n4("tlv.decode: length bytes not complete");
    if (u4[0] === 0) throw new n4("tlv.decode(long): zero leftmost byte");
    for (const l7 of u4) s2 = s2 << 8 | l7;
    if (r3 += a5, s2 < 128) throw new n4("tlv.decode(long): not minimal encoding");
  }
  const c7 = e.subarray(r3, r3 + s2);
  if (c7.length !== s2) throw new n4("tlv.decode: wrong value length");
  return { v: c7, l: e.subarray(r3 + s2) };
} }, _int: { encode(t) {
  const { Err: e } = lt;
  if (t < dt) throw new e("integer: negative integers are not allowed");
  let n4 = Pt(t);
  if (Number.parseInt(n4[0], 16) & 8 && (n4 = "00" + n4), n4.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
  return n4;
}, decode(t) {
  const { Err: e } = lt;
  if (t[0] & 128) throw new e("invalid signature integer: negative");
  if (t[0] === 0 && !(t[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
  return xc(t);
} }, toSig(t) {
  const { Err: e, _int: n4, _tlv: r3 } = lt, o4 = typeof t == "string" ? Sc(t) : t;
  Qt(o4);
  const { v: i3, l: s2 } = r3.decode(48, o4);
  if (s2.length) throw new e("invalid signature: left bytes after parsing");
  const { v: c7, l: a5 } = r3.decode(2, i3), { v: u4, l: l7 } = r3.decode(2, a5);
  if (l7.length) throw new e("invalid signature: left bytes after parsing");
  return { r: n4.decode(c7), s: n4.decode(u4) };
}, hexFromSig(t) {
  const { _tlv: e, _int: n4 } = lt, r3 = e.encode(2, n4.encode(t.r)), o4 = e.encode(2, n4.encode(t.s)), i3 = r3 + o4;
  return e.encode(48, i3);
} };
var dt = BigInt(0);
var K2 = BigInt(1);
BigInt(2);
var Qr = BigInt(3);
BigInt(4);
function Ac(t) {
  const e = vc(t), { Fp: n4 } = e, r3 = Kr(e.n, e.nBitLength), o4 = e.toBytes || ((p5, d5, v7) => {
    const m2 = d5.toAffine();
    return ee(Uint8Array.from([4]), n4.toBytes(m2.x), n4.toBytes(m2.y));
  }), i3 = e.fromBytes || ((p5) => {
    const d5 = p5.subarray(1), v7 = n4.fromBytes(d5.subarray(0, n4.BYTES)), m2 = n4.fromBytes(d5.subarray(n4.BYTES, 2 * n4.BYTES));
    return { x: v7, y: m2 };
  });
  function s2(p5) {
    const { a: d5, b: v7 } = e, m2 = n4.sqr(p5), O8 = n4.mul(m2, p5);
    return n4.add(n4.add(O8, n4.mul(p5, d5)), v7);
  }
  if (!n4.eql(n4.sqr(e.Gy), s2(e.Gx))) throw new Error("bad generator point: equation left != right");
  function c7(p5) {
    return we(p5, K2, e.n);
  }
  function a5(p5) {
    const { allowedPrivateKeyLengths: d5, nByteLength: v7, wrapPrivateKey: m2, n: O8 } = e;
    if (d5 && typeof p5 != "bigint") {
      if (St(p5) && (p5 = Ct(p5)), typeof p5 != "string" || !d5.includes(p5.length)) throw new Error("invalid private key");
      p5 = p5.padStart(v7 * 2, "0");
    }
    let N4;
    try {
      N4 = typeof p5 == "bigint" ? p5 : Ot(et("private key", p5, v7));
    } catch {
      throw new Error("invalid private key, expected hex or " + v7 + " bytes, got " + typeof p5);
    }
    return m2 && (N4 = X(N4, O8)), ft("private key", N4, K2, O8), N4;
  }
  function u4(p5) {
    if (!(p5 instanceof h7)) throw new Error("ProjectivePoint expected");
  }
  const l7 = Qe2((p5, d5) => {
    const { px: v7, py: m2, pz: O8 } = p5;
    if (n4.eql(O8, n4.ONE)) return { x: v7, y: m2 };
    const N4 = p5.is0();
    d5 == null && (d5 = N4 ? n4.ONE : n4.inv(O8));
    const $5 = n4.mul(v7, d5), B5 = n4.mul(m2, d5), A5 = n4.mul(O8, d5);
    if (N4) return { x: n4.ZERO, y: n4.ZERO };
    if (!n4.eql(A5, n4.ONE)) throw new Error("invZ was invalid");
    return { x: $5, y: B5 };
  }), f6 = Qe2((p5) => {
    if (p5.is0()) {
      if (e.allowInfinityPoint && !n4.is0(p5.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d5, y: v7 } = p5.toAffine();
    if (!n4.isValid(d5) || !n4.isValid(v7)) throw new Error("bad point: x or y not FE");
    const m2 = n4.sqr(v7), O8 = s2(d5);
    if (!n4.eql(m2, O8)) throw new Error("bad point: equation left != right");
    if (!p5.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class h7 {
    constructor(d5, v7, m2) {
      if (this.px = d5, this.py = v7, this.pz = m2, d5 == null || !n4.isValid(d5)) throw new Error("x required");
      if (v7 == null || !n4.isValid(v7)) throw new Error("y required");
      if (m2 == null || !n4.isValid(m2)) throw new Error("z required");
      Object.freeze(this);
    }
    static fromAffine(d5) {
      const { x: v7, y: m2 } = d5 || {};
      if (!d5 || !n4.isValid(v7) || !n4.isValid(m2)) throw new Error("invalid affine point");
      if (d5 instanceof h7) throw new Error("projective point not allowed");
      const O8 = (N4) => n4.eql(N4, n4.ZERO);
      return O8(v7) && O8(m2) ? h7.ZERO : new h7(v7, m2, n4.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d5) {
      const v7 = n4.invertBatch(d5.map((m2) => m2.pz));
      return d5.map((m2, O8) => m2.toAffine(v7[O8])).map(h7.fromAffine);
    }
    static fromHex(d5) {
      const v7 = h7.fromAffine(i3(et("pointHex", d5)));
      return v7.assertValidity(), v7;
    }
    static fromPrivateKey(d5) {
      return h7.BASE.multiply(a5(d5));
    }
    static msm(d5, v7) {
      return hc(h7, r3, d5, v7);
    }
    _setWindowSize(d5) {
      E6.setWindowSize(this, d5);
    }
    assertValidity() {
      f6(this);
    }
    hasEvenY() {
      const { y: d5 } = this.toAffine();
      if (n4.isOdd) return !n4.isOdd(d5);
      throw new Error("Field doesn't support isOdd");
    }
    equals(d5) {
      u4(d5);
      const { px: v7, py: m2, pz: O8 } = this, { px: N4, py: $5, pz: B5 } = d5, A5 = n4.eql(n4.mul(v7, B5), n4.mul(N4, O8)), T4 = n4.eql(n4.mul(m2, B5), n4.mul($5, O8));
      return A5 && T4;
    }
    negate() {
      return new h7(this.px, n4.neg(this.py), this.pz);
    }
    double() {
      const { a: d5, b: v7 } = e, m2 = n4.mul(v7, Qr), { px: O8, py: N4, pz: $5 } = this;
      let B5 = n4.ZERO, A5 = n4.ZERO, T4 = n4.ZERO, S7 = n4.mul(O8, O8), L4 = n4.mul(N4, N4), U5 = n4.mul($5, $5), _5 = n4.mul(O8, N4);
      return _5 = n4.add(_5, _5), T4 = n4.mul(O8, $5), T4 = n4.add(T4, T4), B5 = n4.mul(d5, T4), A5 = n4.mul(m2, U5), A5 = n4.add(B5, A5), B5 = n4.sub(L4, A5), A5 = n4.add(L4, A5), A5 = n4.mul(B5, A5), B5 = n4.mul(_5, B5), T4 = n4.mul(m2, T4), U5 = n4.mul(d5, U5), _5 = n4.sub(S7, U5), _5 = n4.mul(d5, _5), _5 = n4.add(_5, T4), T4 = n4.add(S7, S7), S7 = n4.add(T4, S7), S7 = n4.add(S7, U5), S7 = n4.mul(S7, _5), A5 = n4.add(A5, S7), U5 = n4.mul(N4, $5), U5 = n4.add(U5, U5), S7 = n4.mul(U5, _5), B5 = n4.sub(B5, S7), T4 = n4.mul(U5, L4), T4 = n4.add(T4, T4), T4 = n4.add(T4, T4), new h7(B5, A5, T4);
    }
    add(d5) {
      u4(d5);
      const { px: v7, py: m2, pz: O8 } = this, { px: N4, py: $5, pz: B5 } = d5;
      let A5 = n4.ZERO, T4 = n4.ZERO, S7 = n4.ZERO;
      const L4 = e.a, U5 = n4.mul(e.b, Qr);
      let _5 = n4.mul(v7, N4), j7 = n4.mul(m2, $5), g4 = n4.mul(O8, B5), w6 = n4.add(v7, m2), b6 = n4.add(N4, $5);
      w6 = n4.mul(w6, b6), b6 = n4.add(_5, j7), w6 = n4.sub(w6, b6), b6 = n4.add(v7, O8);
      let I5 = n4.add(N4, B5);
      return b6 = n4.mul(b6, I5), I5 = n4.add(_5, g4), b6 = n4.sub(b6, I5), I5 = n4.add(m2, O8), A5 = n4.add($5, B5), I5 = n4.mul(I5, A5), A5 = n4.add(j7, g4), I5 = n4.sub(I5, A5), S7 = n4.mul(L4, b6), A5 = n4.mul(U5, g4), S7 = n4.add(A5, S7), A5 = n4.sub(j7, S7), S7 = n4.add(j7, S7), T4 = n4.mul(A5, S7), j7 = n4.add(_5, _5), j7 = n4.add(j7, _5), g4 = n4.mul(L4, g4), b6 = n4.mul(U5, b6), j7 = n4.add(j7, g4), g4 = n4.sub(_5, g4), g4 = n4.mul(L4, g4), b6 = n4.add(b6, g4), _5 = n4.mul(j7, b6), T4 = n4.add(T4, _5), _5 = n4.mul(I5, b6), A5 = n4.mul(w6, A5), A5 = n4.sub(A5, _5), _5 = n4.mul(w6, j7), S7 = n4.mul(I5, S7), S7 = n4.add(S7, _5), new h7(A5, T4, S7);
    }
    subtract(d5) {
      return this.add(d5.negate());
    }
    is0() {
      return this.equals(h7.ZERO);
    }
    wNAF(d5) {
      return E6.wNAFCached(this, d5, h7.normalizeZ);
    }
    multiplyUnsafe(d5) {
      const { endo: v7, n: m2 } = e;
      ft("scalar", d5, dt, m2);
      const O8 = h7.ZERO;
      if (d5 === dt) return O8;
      if (this.is0() || d5 === K2) return this;
      if (!v7 || E6.hasPrecomputes(this)) return E6.wNAFCachedUnsafe(this, d5, h7.normalizeZ);
      let { k1neg: N4, k1: $5, k2neg: B5, k2: A5 } = v7.splitScalar(d5), T4 = O8, S7 = O8, L4 = this;
      for (; $5 > dt || A5 > dt; ) $5 & K2 && (T4 = T4.add(L4)), A5 & K2 && (S7 = S7.add(L4)), L4 = L4.double(), $5 >>= K2, A5 >>= K2;
      return N4 && (T4 = T4.negate()), B5 && (S7 = S7.negate()), S7 = new h7(n4.mul(S7.px, v7.beta), S7.py, S7.pz), T4.add(S7);
    }
    multiply(d5) {
      const { endo: v7, n: m2 } = e;
      ft("scalar", d5, K2, m2);
      let O8, N4;
      if (v7) {
        const { k1neg: $5, k1: B5, k2neg: A5, k2: T4 } = v7.splitScalar(d5);
        let { p: S7, f: L4 } = this.wNAF(B5), { p: U5, f: _5 } = this.wNAF(T4);
        S7 = E6.constTimeNegate($5, S7), U5 = E6.constTimeNegate(A5, U5), U5 = new h7(n4.mul(U5.px, v7.beta), U5.py, U5.pz), O8 = S7.add(U5), N4 = L4.add(_5);
      } else {
        const { p: $5, f: B5 } = this.wNAF(d5);
        O8 = $5, N4 = B5;
      }
      return h7.normalizeZ([O8, N4])[0];
    }
    multiplyAndAddUnsafe(d5, v7, m2) {
      const O8 = h7.BASE, N4 = (B5, A5) => A5 === dt || A5 === K2 || !B5.equals(O8) ? B5.multiplyUnsafe(A5) : B5.multiply(A5), $5 = N4(this, v7).add(N4(d5, m2));
      return $5.is0() ? void 0 : $5;
    }
    toAffine(d5) {
      return l7(this, d5);
    }
    isTorsionFree() {
      const { h: d5, isTorsionFree: v7 } = e;
      if (d5 === K2) return true;
      if (v7) return v7(h7, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: d5, clearCofactor: v7 } = e;
      return d5 === K2 ? this : v7 ? v7(h7, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(d5 = true) {
      return jt("isCompressed", d5), this.assertValidity(), o4(h7, this, d5);
    }
    toHex(d5 = true) {
      return jt("isCompressed", d5), Ct(this.toRawBytes(d5));
    }
  }
  h7.BASE = new h7(e.Gx, e.Gy, n4.ONE), h7.ZERO = new h7(n4.ZERO, n4.ONE, n4.ZERO);
  const y10 = e.nBitLength, E6 = dc(h7, e.endo ? Math.ceil(y10 / 2) : y10);
  return { CURVE: e, ProjectivePoint: h7, normPrivateKeyToScalar: a5, weierstrassEquation: s2, isWithinCurveOrder: c7 };
}
function Bc(t) {
  const e = Wr(t);
  return Mt(e, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: true, ...e });
}
function Ic(t) {
  const e = Bc(t), { Fp: n4, n: r3 } = e, o4 = n4.BYTES + 1, i3 = 2 * n4.BYTES + 1;
  function s2(g4) {
    return X(g4, r3);
  }
  function c7(g4) {
    return en(g4, r3);
  }
  const { ProjectivePoint: a5, normPrivateKeyToScalar: u4, weierstrassEquation: l7, isWithinCurveOrder: f6 } = Ac({ ...e, toBytes(g4, w6, b6) {
    const I5 = w6.toAffine(), R6 = n4.toBytes(I5.x), x7 = ee;
    return jt("isCompressed", b6), b6 ? x7(Uint8Array.from([w6.hasEvenY() ? 2 : 3]), R6) : x7(Uint8Array.from([4]), R6, n4.toBytes(I5.y));
  }, fromBytes(g4) {
    const w6 = g4.length, b6 = g4[0], I5 = g4.subarray(1);
    if (w6 === o4 && (b6 === 2 || b6 === 3)) {
      const R6 = Ot(I5);
      if (!we(R6, K2, n4.ORDER)) throw new Error("Point is not on curve");
      const x7 = l7(R6);
      let C5;
      try {
        C5 = n4.sqrt(x7);
      } catch (M6) {
        const D5 = M6 instanceof Error ? ": " + M6.message : "";
        throw new Error("Point is not on curve" + D5);
      }
      const P5 = (C5 & K2) === K2;
      return (b6 & 1) === 1 !== P5 && (C5 = n4.neg(C5)), { x: R6, y: C5 };
    } else if (w6 === i3 && b6 === 4) {
      const R6 = n4.fromBytes(I5.subarray(0, n4.BYTES)), x7 = n4.fromBytes(I5.subarray(n4.BYTES, 2 * n4.BYTES));
      return { x: R6, y: x7 };
    } else {
      const R6 = o4, x7 = i3;
      throw new Error("invalid Point, expected length of " + R6 + ", or uncompressed " + x7 + ", got " + w6);
    }
  } }), h7 = (g4) => Ct(Vt(g4, e.nByteLength));
  function y10(g4) {
    const w6 = r3 >> K2;
    return g4 > w6;
  }
  function E6(g4) {
    return y10(g4) ? s2(-g4) : g4;
  }
  const p5 = (g4, w6, b6) => Ot(g4.slice(w6, b6));
  class d5 {
    constructor(w6, b6, I5) {
      this.r = w6, this.s = b6, this.recovery = I5, this.assertValidity();
    }
    static fromCompact(w6) {
      const b6 = e.nByteLength;
      return w6 = et("compactSignature", w6, b6 * 2), new d5(p5(w6, 0, b6), p5(w6, b6, 2 * b6));
    }
    static fromDER(w6) {
      const { r: b6, s: I5 } = lt.toSig(et("DER", w6));
      return new d5(b6, I5);
    }
    assertValidity() {
      ft("r", this.r, K2, r3), ft("s", this.s, K2, r3);
    }
    addRecoveryBit(w6) {
      return new d5(this.r, this.s, w6);
    }
    recoverPublicKey(w6) {
      const { r: b6, s: I5, recovery: R6 } = this, x7 = B5(et("msgHash", w6));
      if (R6 == null || ![0, 1, 2, 3].includes(R6)) throw new Error("recovery id invalid");
      const C5 = R6 === 2 || R6 === 3 ? b6 + e.n : b6;
      if (C5 >= n4.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const P5 = (R6 & 1) === 0 ? "02" : "03", k6 = a5.fromHex(P5 + h7(C5)), M6 = c7(C5), D5 = s2(-x7 * M6), z9 = s2(I5 * M6), Z5 = a5.BASE.multiplyAndAddUnsafe(k6, D5, z9);
      if (!Z5) throw new Error("point at infinify");
      return Z5.assertValidity(), Z5;
    }
    hasHighS() {
      return y10(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new d5(this.r, s2(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return kt(this.toDERHex());
    }
    toDERHex() {
      return lt.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return kt(this.toCompactHex());
    }
    toCompactHex() {
      return h7(this.r) + h7(this.s);
    }
  }
  const v7 = { isValidPrivateKey(g4) {
    try {
      return u4(g4), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: u4, randomPrivateKey: () => {
    const g4 = zr(e.n);
    return uc(e.randomBytes(g4), e.n);
  }, precompute(g4 = 8, w6 = a5.BASE) {
    return w6._setWindowSize(g4), w6.multiply(BigInt(3)), w6;
  } };
  function m2(g4, w6 = true) {
    return a5.fromPrivateKey(g4).toRawBytes(w6);
  }
  function O8(g4) {
    const w6 = St(g4), b6 = typeof g4 == "string", I5 = (w6 || b6) && g4.length;
    return w6 ? I5 === o4 || I5 === i3 : b6 ? I5 === 2 * o4 || I5 === 2 * i3 : g4 instanceof a5;
  }
  function N4(g4, w6, b6 = true) {
    if (O8(g4)) throw new Error("first arg must be private key");
    if (!O8(w6)) throw new Error("second arg must be public key");
    return a5.fromHex(w6).multiply(u4(g4)).toRawBytes(b6);
  }
  const $5 = e.bits2int || function(g4) {
    if (g4.length > 8192) throw new Error("input is too large");
    const w6 = Ot(g4), b6 = g4.length * 8 - e.nBitLength;
    return b6 > 0 ? w6 >> BigInt(b6) : w6;
  }, B5 = e.bits2int_modN || function(g4) {
    return s2($5(g4));
  }, A5 = Xe(e.nBitLength);
  function T4(g4) {
    return ft("num < 2^" + e.nBitLength, g4, dt, A5), Vt(g4, e.nByteLength);
  }
  function S7(g4, w6, b6 = L4) {
    if (["recovered", "canonical"].some((W3) => W3 in b6)) throw new Error("sign() legacy options not supported");
    const { hash: I5, randomBytes: R6 } = e;
    let { lowS: x7, prehash: C5, extraEntropy: P5 } = b6;
    x7 == null && (x7 = true), g4 = et("msgHash", g4), Jr(b6), C5 && (g4 = et("prehashed msgHash", I5(g4)));
    const k6 = B5(g4), M6 = u4(w6), D5 = [T4(M6), T4(k6)];
    if (P5 != null && P5 !== false) {
      const W3 = P5 === true ? R6(n4.BYTES) : P5;
      D5.push(et("extraEntropy", W3));
    }
    const z9 = ee(...D5), Z5 = k6;
    function it5(W3) {
      const J2 = $5(W3);
      if (!f6(J2)) return;
      const Oe2 = c7(J2), Ft5 = a5.BASE.multiply(J2).toAffine(), vt3 = s2(Ft5.x);
      if (vt3 === dt) return;
      const zt5 = s2(Oe2 * s2(Z5 + vt3 * M6));
      if (zt5 === dt) return;
      let Ut5 = (Ft5.x === vt3 ? 0 : 2) | Number(Ft5.y & K2), vn4 = zt5;
      return x7 && y10(zt5) && (vn4 = E6(zt5), Ut5 ^= 1), new d5(vt3, vn4, Ut5);
    }
    return { seed: z9, k2sig: it5 };
  }
  const L4 = { lowS: e.lowS, prehash: false }, U5 = { lowS: e.lowS, prehash: false };
  function _5(g4, w6, b6 = L4) {
    const { seed: I5, k2sig: R6 } = S7(g4, w6, b6), x7 = e;
    return Vr(x7.hash.outputLen, x7.nByteLength, x7.hmac)(I5, R6);
  }
  a5.BASE._setWindowSize(8);
  function j7(g4, w6, b6, I5 = U5) {
    var _a2;
    const R6 = g4;
    w6 = et("msgHash", w6), b6 = et("publicKey", b6);
    const { lowS: x7, prehash: C5, format: P5 } = I5;
    if (Jr(I5), "strict" in I5) throw new Error("options.strict was renamed to lowS");
    if (P5 !== void 0 && P5 !== "compact" && P5 !== "der") throw new Error("format must be compact or der");
    const k6 = typeof R6 == "string" || St(R6), M6 = !k6 && !P5 && typeof R6 == "object" && R6 !== null && typeof R6.r == "bigint" && typeof R6.s == "bigint";
    if (!k6 && !M6) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let D5, z9;
    try {
      if (M6 && (D5 = new d5(R6.r, R6.s)), k6) {
        try {
          P5 !== "compact" && (D5 = d5.fromDER(R6));
        } catch (Ut5) {
          if (!(Ut5 instanceof lt.Err)) throw Ut5;
        }
        !D5 && P5 !== "der" && (D5 = d5.fromCompact(R6));
      }
      z9 = a5.fromHex(b6);
    } catch {
      return false;
    }
    if (!D5 || x7 && D5.hasHighS()) return false;
    C5 && (w6 = e.hash(w6));
    const { r: Z5, s: it5 } = D5, W3 = B5(w6), J2 = c7(it5), Oe2 = s2(W3 * J2), Ft5 = s2(Z5 * J2), vt3 = (_a2 = a5.BASE.multiplyAndAddUnsafe(z9, Oe2, Ft5)) == null ? void 0 : _a2.toAffine();
    return vt3 ? s2(vt3.x) === Z5 : false;
  }
  return { CURVE: e, getPublicKey: m2, getSharedSecret: N4, sign: _5, verify: j7, ProjectivePoint: a5, Signature: d5, utils: v7 };
}
function Nc(t) {
  return { hash: t, hmac: (e, ...n4) => pe(t, e, Vi(...n4)), randomBytes: $t };
}
function Uc(t, e) {
  const n4 = (r3) => Ic({ ...t, ...Nc(r3) });
  return { ...n4(e), create: n4 };
}
var to = Kr(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var Tc = to.create(BigInt("-3"));
var Rc = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var _c = Uc({ a: Tc, b: Rc, Fp: to, n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"), h: BigInt(1), lowS: false }, Jt);
var fn = "base10";
var G = "base16";
var Ht = "base64pad";
var Ee = "base64url";
var qt = "utf8";
var ln = 0;
var Kt = 1;
var ne = 2;
var $c = 0;
var eo = 1;
var re = 12;
var dn = 32;
function Lc() {
  const t = un.utils.randomPrivateKey(), e = un.getPublicKey(t);
  return { privateKey: toString(t, G), publicKey: toString(e, G) };
}
function jc() {
  const t = $t(dn);
  return toString(t, G);
}
function Cc(t, e) {
  const n4 = un.getSharedSecret(fromString(t, G), fromString(e, G)), r3 = Vs(Jt, n4, void 0, void 0, dn);
  return toString(r3, G);
}
function Pc(t) {
  const e = Jt(fromString(t, G));
  return toString(e, G);
}
function kc(t) {
  const e = Jt(fromString(t, qt));
  return toString(e, G);
}
function hn(t) {
  return fromString(`${t}`, fn);
}
function Bt(t) {
  return Number(toString(t, fn));
}
function no(t) {
  return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function ro(t) {
  const e = t.replace(/-/g, "+").replace(/_/g, "/"), n4 = (4 - e.length % 4) % 4;
  return e + "=".repeat(n4);
}
function Vc(t) {
  const e = hn(typeof t.type < "u" ? t.type : ln);
  if (Bt(e) === Kt && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n4 = typeof t.senderPublicKey < "u" ? fromString(t.senderPublicKey, G) : void 0, r3 = typeof t.iv < "u" ? fromString(t.iv, G) : $t(re), o4 = fromString(t.symKey, G), i3 = $r(o4, r3).encrypt(fromString(t.message, qt)), s2 = pn({ type: e, sealed: i3, iv: r3, senderPublicKey: n4 });
  return t.encoding === Ee ? no(s2) : s2;
}
function Mc(t) {
  const e = fromString(t.symKey, G), { sealed: n4, iv: r3 } = ve({ encoded: t.encoded, encoding: t.encoding }), o4 = $r(e, r3).decrypt(n4);
  if (o4 === null) throw new Error("Failed to decrypt");
  return toString(o4, qt);
}
function Dc(t, e) {
  const n4 = hn(ne), r3 = $t(re), o4 = fromString(t, qt), i3 = pn({ type: n4, sealed: o4, iv: r3 });
  return e === Ee ? no(i3) : i3;
}
function Hc(t, e) {
  const { sealed: n4 } = ve({ encoded: t, encoding: e });
  return toString(n4, qt);
}
function pn(t) {
  if (Bt(t.type) === ne) return toString(concat([t.type, t.sealed]), Ht);
  if (Bt(t.type) === Kt) {
    if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([t.type, t.senderPublicKey, t.iv, t.sealed]), Ht);
  }
  return toString(concat([t.type, t.iv, t.sealed]), Ht);
}
function ve(t) {
  const e = (t.encoding || Ht) === Ee ? ro(t.encoded) : t.encoded, n4 = fromString(e, Ht), r3 = n4.slice($c, eo), o4 = eo;
  if (Bt(r3) === Kt) {
    const a5 = o4 + dn, u4 = a5 + re, l7 = n4.slice(o4, a5), f6 = n4.slice(a5, u4), h7 = n4.slice(u4);
    return { type: r3, sealed: h7, iv: f6, senderPublicKey: l7 };
  }
  if (Bt(r3) === ne) {
    const a5 = n4.slice(o4), u4 = $t(re);
    return { type: r3, sealed: a5, iv: u4 };
  }
  const i3 = o4 + re, s2 = n4.slice(o4, i3), c7 = n4.slice(i3);
  return { type: r3, sealed: c7, iv: s2 };
}
function qc(t, e) {
  const n4 = ve({ encoded: t, encoding: e == null ? void 0 : e.encoding });
  return oo({ type: Bt(n4.type), senderPublicKey: typeof n4.senderPublicKey < "u" ? toString(n4.senderPublicKey, G) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function oo(t) {
  const e = (t == null ? void 0 : t.type) || ln;
  if (e === Kt) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t == null ? void 0 : t.senderPublicKey, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey };
}
function Kc(t) {
  return t.type === Kt && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
function Fc(t) {
  return t.type === ne;
}
function io(t) {
  const e = Buffer.from(t.x, "base64"), n4 = Buffer.from(t.y, "base64");
  return concat([new Uint8Array([4]), e, n4]);
}
function zc(t, e) {
  const [n4, r3, o4] = t.split("."), i3 = Buffer.from(ro(o4), "base64");
  if (i3.length !== 64) throw new Error("Invalid signature length");
  const s2 = i3.slice(0, 32), c7 = i3.slice(32, 64), a5 = `${n4}.${r3}`, u4 = Jt(a5), l7 = io(e);
  if (!_c.verify(concat([s2, c7]), u4, l7)) throw new Error("Invalid signature");
  return sn(t).payload;
}
var so = "irn";
function Zc(t) {
  return (t == null ? void 0 : t.relay) || { protocol: so };
}
function Yc(t) {
  const e = C[t];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
function co(t, e = "-") {
  const n4 = {}, r3 = "relay" + e;
  return Object.keys(t).forEach((o4) => {
    if (o4.startsWith(r3)) {
      const i3 = o4.replace(r3, ""), s2 = t[o4];
      n4[i3] = s2;
    }
  }), n4;
}
function Gc(t) {
  if (!t.includes("wc:")) {
    const u4 = Le(t);
    u4 != null && u4.includes("wc:") && (t = u4);
  }
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), n4 = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, r3 = t.substring(0, e), o4 = t.substring(e + 1, n4).split("@"), i3 = typeof n4 < "u" ? t.substring(n4) : "", s2 = new URLSearchParams(i3), c7 = {};
  s2.forEach((u4, l7) => {
    c7[l7] = u4;
  });
  const a5 = typeof c7.methods == "string" ? c7.methods.split(",") : void 0;
  return { protocol: r3, topic: ao(o4[0]), version: parseInt(o4[1], 10), symKey: c7.symKey, relay: co(c7), methods: a5, expiryTimestamp: c7.expiryTimestamp ? parseInt(c7.expiryTimestamp, 10) : void 0 };
}
function ao(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function uo(t, e = "-") {
  const n4 = "relay", r3 = {};
  return Object.keys(t).forEach((o4) => {
    const i3 = o4, s2 = n4 + e + i3;
    t[i3] && (r3[s2] = t[i3]);
  }), r3;
}
function Wc(t) {
  const e = new URLSearchParams(), n4 = uo(t.relay);
  Object.keys(n4).sort().forEach((o4) => {
    e.set(o4, n4[o4]);
  }), e.set("symKey", t.symKey), t.expiryTimestamp && e.set("expiryTimestamp", t.expiryTimestamp.toString()), t.methods && e.set("methods", t.methods.join(","));
  const r3 = e.toString();
  return `${t.protocol}:${t.topic}@${t.version}?${r3}`;
}
var wo = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var bo = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function ht(t, e) {
  const { message: n4, code: r3 } = bo[t];
  return { message: e ? `${n4} ${e}` : n4, code: r3 };
}
function Nt(t, e) {
  const { message: n4, code: r3 } = wo[t];
  return { message: e ? `${n4} ${e}` : n4, code: r3 };
}
function Et(t) {
  return typeof t > "u";
}
function nt(t, e) {
  return e && Et(t) ? true : typeof t == "string" && !!t.trim().length;
}
function Se(t, e) {
  return e && Et(t) ? true : typeof t == "number" && !isNaN(t);
}
function ua(t) {
  function e(n4) {
    try {
      return typeof new URL(n4) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (nt(t, false)) {
      if (e(t)) return true;
      const n4 = Le(t);
      return e(n4);
    }
  } catch {
  }
  return false;
}
function fa(t) {
  var e;
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function la(t) {
  return t == null ? void 0 : t.topic;
}
function ya(t) {
  return typeof t < "u" && typeof t !== null;
}
function Ba(t, e) {
  return Se(t, false) && t <= e.max && t >= e.min;
}
function Ia() {
  const t = xt();
  return new Promise((e) => {
    switch (t) {
      case Y.browser:
        e(To());
        break;
      case Y.reactNative:
        e(Ro());
        break;
      case Y.node:
        e(_o());
        break;
      default:
        e(true);
    }
  });
}
function To() {
  return Yt() && (navigator == null ? void 0 : navigator.onLine);
}
async function Ro() {
  if (pt() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t == null ? void 0 : t.isConnected;
  }
  return true;
}
function _o() {
  return true;
}
function Na(t) {
  switch (xt()) {
    case Y.browser:
      $o(t);
      break;
    case Y.reactNative:
      Lo(t);
      break;
    case Y.node:
      break;
  }
}
function $o(t) {
  !pt() && Yt() && (window.addEventListener("online", () => t(true)), window.addEventListener("offline", () => t(false)));
}
function Lo(t) {
  pt() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((e) => t(e == null ? void 0 : e.isConnected)));
}

// node_modules/@walletconnect/core/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe2(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return globalThis.Buffer.allocUnsafe(size);
  }
  return new Uint8Array(size);
}

// node_modules/@walletconnect/core/node_modules/uint8arrays/esm/src/util/bases.js
init_basics();
function createCodec2(name, prefix, encode, decode) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode
    },
    decoder: { decode }
  };
}
var string2 = createCodec2("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii2 = createCodec2("ascii", "a", (buf) => {
  let string4 = "a";
  for (let i3 = 0; i3 < buf.length; i3++) {
    string4 += String.fromCharCode(buf[i3]);
  }
  return string4;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe2(str.length);
  for (let i3 = 0; i3 < str.length; i3++) {
    buf[i3] = str.charCodeAt(i3);
  }
  return buf;
});
var BASES2 = {
  utf8: string2,
  "utf-8": string2,
  hex: bases.base16,
  latin1: ascii2,
  ascii: ascii2,
  binary: ascii2,
  ...bases
};
var bases_default2 = BASES2;

// node_modules/@walletconnect/core/node_modules/uint8arrays/esm/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base2 = bases_default2[encoding];
  if (!base2) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base2.encoder.encode(array).substring(1);
}

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var import_events5 = __toESM(require_events());
var o2 = class extends r {
  constructor(t) {
    super(t), this.events = new import_events5.EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, e) {
    this.events.on(t, e);
  }
  once(t, e) {
    this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  removeListener(t, e) {
    this.events.removeListener(t, e);
  }
  async request(t, e) {
    return this.requestStrict(formatJsonRpcRequest(t.method, t.params || [], t.id || getBigIntRpcId().toString()), e);
  }
  async requestStrict(t, e) {
    return new Promise(async (i3, s2) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (n4) {
        s2(n4);
      }
      this.events.on(`${t.id}`, (n4) => {
        isJsonRpcError(n4) ? s2(n4.error) : i3(n4.result);
      });
      try {
        await this.connection.send(t, e);
      } catch (n4) {
        s2(n4);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), isJsonRpcResponse(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", { type: t.method, data: t.params });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = true);
  }
};

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events6 = __toESM(require_events());
var v2 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser2();
var w = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var d2 = (r3) => r3.split("?")[0];
var h3 = 10;
var b2 = v2();
var f2 = class {
  constructor(e) {
    if (this.url = e, this.events = new import_events6.EventEmitter(), this.registering = false, !isWsUrl(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n4) => {
        this.onClose(n4), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e));
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  register(e = this.url) {
    if (!isWsUrl(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n4, s2) => {
        this.events.once("register_error", (o4) => {
          this.resetMaxListeners(), s2(o4);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return s2(new Error("WebSocket connection is missing or invalid"));
          n4(this.socket);
        });
      });
    }
    return this.url = e, this.registering = true, new Promise((t, n4) => {
      const s2 = (0, esm_exports.isReactNative)() ? void 0 : { rejectUnauthorized: !isLocalhostUrl(e) }, o4 = new b2(e, [], s2);
      w() ? o4.onerror = (i3) => {
        const a5 = i3;
        n4(this.emitError(a5.error));
      } : o4.on("error", (i3) => {
        n4(this.emitError(i3));
      }), o4.onopen = () => {
        this.onOpen(o4), t(o4);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = false, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const t = typeof e.data == "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n4 = this.parseError(t), s2 = n4.message || n4.toString(), o4 = formatJsonRpcError(e, s2);
    this.events.emit("payload", o4);
  }
  parseError(e, t = this.url) {
    return parseConnectionError(e, d2(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h3 && this.events.setMaxListeners(h3);
  }
  emitError(e) {
    const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${d2(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_window_getters2 = __toESM(require_cjs2());
var ze2 = "wc";
var Le2 = 2;
var he2 = "core";
var B = `${ze2}@2:${he2}:`;
var Et2 = { name: he2, logger: "error" };
var It = { database: ":memory:" };
var Tt2 = "crypto";
var ke = "client_ed25519_seed";
var Ct2 = import_time3.ONE_DAY;
var Pt2 = "keychain";
var St2 = "0.3";
var Rt2 = "messages";
var Ot2 = "0.3";
var je2 = import_time3.SIX_HOURS;
var At2 = "publisher";
var xt2 = "irn";
var Nt2 = "error";
var Ue = "wss://relay.walletconnect.org";
var $t2 = "relayer";
var C2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var zt = "_subscription";
var L = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var Lt2 = 0.1;
var _e2 = "2.19.2";
var Q = { link_mode: "link_mode", relay: "relay" };
var le = { inbound: "inbound", outbound: "outbound" };
var kt2 = "0.3";
var jt2 = "WALLETCONNECT_CLIENT_ID";
var Fe2 = "WALLETCONNECT_LINK_MODE_APPS";
var $ = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Ut = "subscription";
var Ft = "0.3";
var Hs2 = import_time3.FIVE_SECONDS * 1e3;
var Mt2 = "pairing";
var Kt2 = "0.3";
var ie = { wc_pairingDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 } } };
var se = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var F2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Bt2 = "history";
var Vt2 = "0.3";
var qt2 = "expirer";
var M2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Gt2 = "0.3";
var Wt2 = "verify-api";
var Xs2 = "https://verify.walletconnect.com";
var Ht2 = "https://verify.walletconnect.org";
var ue2 = Ht2;
var Yt2 = `${ue2}/v3`;
var Jt2 = [Xs2, Ht2];
var Xt2 = "echo";
var Zt = "https://echo.walletconnect.com";
var G2 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var Y2 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var Qt2 = 0.1;
var ei2 = "event-client";
var ti = 86400;
var ii = "https://pulse.walletconnect.org/batch";
function sr(r3, e) {
  if (r3.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i3 = 0; i3 < t.length; i3++) t[i3] = 255;
  for (var s2 = 0; s2 < r3.length; s2++) {
    var n4 = r3.charAt(s2), o4 = n4.charCodeAt(0);
    if (t[o4] !== 255) throw new TypeError(n4 + " is ambiguous");
    t[o4] = s2;
  }
  var a5 = r3.length, c7 = r3.charAt(0), h7 = Math.log(a5) / Math.log(256), l7 = Math.log(256) / Math.log(a5);
  function d5(u4) {
    if (u4 instanceof Uint8Array || (ArrayBuffer.isView(u4) ? u4 = new Uint8Array(u4.buffer, u4.byteOffset, u4.byteLength) : Array.isArray(u4) && (u4 = Uint8Array.from(u4))), !(u4 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u4.length === 0) return "";
    for (var b6 = 0, x7 = 0, I5 = 0, D5 = u4.length; I5 !== D5 && u4[I5] === 0; ) I5++, b6++;
    for (var j7 = (D5 - I5) * l7 + 1 >>> 0, T4 = new Uint8Array(j7); I5 !== D5; ) {
      for (var q4 = u4[I5], J2 = 0, K8 = j7 - 1; (q4 !== 0 || J2 < x7) && K8 !== -1; K8--, J2++) q4 += 256 * T4[K8] >>> 0, T4[K8] = q4 % a5 >>> 0, q4 = q4 / a5 >>> 0;
      if (q4 !== 0) throw new Error("Non-zero carry");
      x7 = J2, I5++;
    }
    for (var H3 = j7 - x7; H3 !== j7 && T4[H3] === 0; ) H3++;
    for (var me5 = c7.repeat(b6); H3 < j7; ++H3) me5 += r3.charAt(T4[H3]);
    return me5;
  }
  function g4(u4) {
    if (typeof u4 != "string") throw new TypeError("Expected String");
    if (u4.length === 0) return new Uint8Array();
    var b6 = 0;
    if (u4[b6] !== " ") {
      for (var x7 = 0, I5 = 0; u4[b6] === c7; ) x7++, b6++;
      for (var D5 = (u4.length - b6) * h7 + 1 >>> 0, j7 = new Uint8Array(D5); u4[b6]; ) {
        var T4 = t[u4.charCodeAt(b6)];
        if (T4 === 255) return;
        for (var q4 = 0, J2 = D5 - 1; (T4 !== 0 || q4 < I5) && J2 !== -1; J2--, q4++) T4 += a5 * j7[J2] >>> 0, j7[J2] = T4 % 256 >>> 0, T4 = T4 / 256 >>> 0;
        if (T4 !== 0) throw new Error("Non-zero carry");
        I5 = q4, b6++;
      }
      if (u4[b6] !== " ") {
        for (var K8 = D5 - I5; K8 !== D5 && j7[K8] === 0; ) K8++;
        for (var H3 = new Uint8Array(x7 + (D5 - K8)), me5 = x7; K8 !== D5; ) H3[me5++] = j7[K8++];
        return H3;
      }
    }
  }
  function _5(u4) {
    var b6 = g4(u4);
    if (b6) return b6;
    throw new Error(`Non-${e} character`);
  }
  return { encode: d5, decodeUnsafe: g4, decode: _5 };
}
var rr2 = sr;
var nr2 = rr2;
var si2 = (r3) => {
  if (r3 instanceof Uint8Array && r3.constructor.name === "Uint8Array") return r3;
  if (r3 instanceof ArrayBuffer) return new Uint8Array(r3);
  if (ArrayBuffer.isView(r3)) return new Uint8Array(r3.buffer, r3.byteOffset, r3.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var or2 = (r3) => new TextEncoder().encode(r3);
var ar = (r3) => new TextDecoder().decode(r3);
var cr = class {
  constructor(e, t, i3) {
    this.name = e, this.prefix = t, this.baseEncode = i3;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var hr = class {
  constructor(e, t, i3) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i3;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ri2(this, e);
  }
};
var lr = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ri2(this, e);
  }
  decode(e) {
    const t = e[0], i3 = this.decoders[t];
    if (i3) return i3.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ri2 = (r3, e) => new lr({ ...r3.decoders || { [r3.prefix]: r3 }, ...e.decoders || { [e.prefix]: e } });
var ur = class {
  constructor(e, t, i3, s2) {
    this.name = e, this.prefix = t, this.baseEncode = i3, this.baseDecode = s2, this.encoder = new cr(e, t, i3), this.decoder = new hr(e, t, s2);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Ee2 = ({ name: r3, prefix: e, encode: t, decode: i3 }) => new ur(r3, e, t, i3);
var de = ({ prefix: r3, name: e, alphabet: t }) => {
  const { encode: i3, decode: s2 } = nr2(t, e);
  return Ee2({ prefix: r3, name: e, encode: i3, decode: (n4) => si2(s2(n4)) });
};
var dr = (r3, e, t, i3) => {
  const s2 = {};
  for (let l7 = 0; l7 < e.length; ++l7) s2[e[l7]] = l7;
  let n4 = r3.length;
  for (; r3[n4 - 1] === "="; ) --n4;
  const o4 = new Uint8Array(n4 * t / 8 | 0);
  let a5 = 0, c7 = 0, h7 = 0;
  for (let l7 = 0; l7 < n4; ++l7) {
    const d5 = s2[r3[l7]];
    if (d5 === void 0) throw new SyntaxError(`Non-${i3} character`);
    c7 = c7 << t | d5, a5 += t, a5 >= 8 && (a5 -= 8, o4[h7++] = 255 & c7 >> a5);
  }
  if (a5 >= t || 255 & c7 << 8 - a5) throw new SyntaxError("Unexpected end of data");
  return o4;
};
var gr = (r3, e, t) => {
  const i3 = e[e.length - 1] === "=", s2 = (1 << t) - 1;
  let n4 = "", o4 = 0, a5 = 0;
  for (let c7 = 0; c7 < r3.length; ++c7) for (a5 = a5 << 8 | r3[c7], o4 += 8; o4 > t; ) o4 -= t, n4 += e[s2 & a5 >> o4];
  if (o4 && (n4 += e[s2 & a5 << t - o4]), i3) for (; n4.length * t & 7; ) n4 += "=";
  return n4;
};
var P2 = ({ name: r3, prefix: e, bitsPerChar: t, alphabet: i3 }) => Ee2({ prefix: e, name: r3, encode(s2) {
  return gr(s2, i3, t);
}, decode(s2) {
  return dr(s2, i3, t, r3);
} });
var pr = Ee2({ prefix: "\0", name: "identity", encode: (r3) => ar(r3), decode: (r3) => or2(r3) });
var yr = Object.freeze({ __proto__: null, identity: pr });
var br = P2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var mr = Object.freeze({ __proto__: null, base2: br });
var fr = P2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Dr2 = Object.freeze({ __proto__: null, base8: fr });
var vr = de({ prefix: "9", name: "base10", alphabet: "0123456789" });
var wr = Object.freeze({ __proto__: null, base10: vr });
var _r2 = P2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Er = P2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ir2 = Object.freeze({ __proto__: null, base16: _r2, base16upper: Er });
var Tr2 = P2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Cr2 = P2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Pr2 = P2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Sr2 = P2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Rr2 = P2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Or2 = P2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Ar2 = P2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var xr = P2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var Nr2 = P2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var $r2 = Object.freeze({ __proto__: null, base32: Tr2, base32upper: Cr2, base32pad: Pr2, base32padupper: Sr2, base32hex: Rr2, base32hexupper: Or2, base32hexpad: Ar2, base32hexpadupper: xr, base32z: Nr2 });
var zr2 = de({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Lr2 = de({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var kr2 = Object.freeze({ __proto__: null, base36: zr2, base36upper: Lr2 });
var jr2 = de({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Ur2 = de({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Fr2 = Object.freeze({ __proto__: null, base58btc: jr2, base58flickr: Ur2 });
var Mr2 = P2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Kr2 = P2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Br3 = P2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Vr2 = P2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var qr2 = Object.freeze({ __proto__: null, base64: Mr2, base64pad: Kr2, base64url: Br3, base64urlpad: Vr2 });
var ni2 = Array.from("");
var Gr2 = ni2.reduce((r3, e, t) => (r3[t] = e, r3), []);
var Wr2 = ni2.reduce((r3, e, t) => (r3[e.codePointAt(0)] = t, r3), []);
function Hr2(r3) {
  return r3.reduce((e, t) => (e += Gr2[t], e), "");
}
function Yr2(r3) {
  const e = [];
  for (const t of r3) {
    const i3 = Wr2[t.codePointAt(0)];
    if (i3 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i3);
  }
  return new Uint8Array(e);
}
var Jr2 = Ee2({ prefix: "", name: "base256emoji", encode: Hr2, decode: Yr2 });
var Xr2 = Object.freeze({ __proto__: null, base256emoji: Jr2 });
var Zr2 = ai;
var oi = 128;
var Qr2 = 127;
var en2 = ~Qr2;
var tn2 = Math.pow(2, 31);
function ai(r3, e, t) {
  e = e || [], t = t || 0;
  for (var i3 = t; r3 >= tn2; ) e[t++] = r3 & 255 | oi, r3 /= 128;
  for (; r3 & en2; ) e[t++] = r3 & 255 | oi, r3 >>>= 7;
  return e[t] = r3 | 0, ai.bytes = t - i3 + 1, e;
}
var sn3 = Me;
var rn2 = 128;
var ci = 127;
function Me(r3, i3) {
  var t = 0, i3 = i3 || 0, s2 = 0, n4 = i3, o4, a5 = r3.length;
  do {
    if (n4 >= a5) throw Me.bytes = 0, new RangeError("Could not decode varint");
    o4 = r3[n4++], t += s2 < 28 ? (o4 & ci) << s2 : (o4 & ci) * Math.pow(2, s2), s2 += 7;
  } while (o4 >= rn2);
  return Me.bytes = n4 - i3, t;
}
var nn2 = Math.pow(2, 7);
var on2 = Math.pow(2, 14);
var an2 = Math.pow(2, 21);
var cn2 = Math.pow(2, 28);
var hn2 = Math.pow(2, 35);
var ln2 = Math.pow(2, 42);
var un2 = Math.pow(2, 49);
var dn2 = Math.pow(2, 56);
var gn = Math.pow(2, 63);
var pn2 = function(r3) {
  return r3 < nn2 ? 1 : r3 < on2 ? 2 : r3 < an2 ? 3 : r3 < cn2 ? 4 : r3 < hn2 ? 5 : r3 < ln2 ? 6 : r3 < un2 ? 7 : r3 < dn2 ? 8 : r3 < gn ? 9 : 10;
};
var yn = { encode: Zr2, decode: sn3, encodingLength: pn2 };
var hi = yn;
var li2 = (r3, e, t = 0) => (hi.encode(r3, e, t), e);
var ui = (r3) => hi.encodingLength(r3);
var Ke2 = (r3, e) => {
  const t = e.byteLength, i3 = ui(r3), s2 = i3 + ui(t), n4 = new Uint8Array(s2 + t);
  return li2(r3, n4, 0), li2(t, n4, i3), n4.set(e, s2), new bn(r3, t, e, n4);
};
var bn = class {
  constructor(e, t, i3, s2) {
    this.code = e, this.size = t, this.digest = i3, this.bytes = s2;
  }
};
var di = ({ name: r3, code: e, encode: t }) => new mn(r3, e, t);
var mn = class {
  constructor(e, t, i3) {
    this.name = e, this.code = t, this.encode = i3;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? Ke2(this.code, t) : t.then((i3) => Ke2(this.code, i3));
    } else throw Error("Unknown type, must be binary type");
  }
};
var gi2 = (r3) => async (e) => new Uint8Array(await crypto.subtle.digest(r3, e));
var fn2 = di({ name: "sha2-256", code: 18, encode: gi2("SHA-256") });
var Dn = di({ name: "sha2-512", code: 19, encode: gi2("SHA-512") });
var vn = Object.freeze({ __proto__: null, sha256: fn2, sha512: Dn });
var pi = 0;
var wn = "identity";
var yi2 = si2;
var _n = (r3) => Ke2(pi, yi2(r3));
var En2 = { code: pi, name: wn, encode: yi2, digest: _n };
var In = Object.freeze({ __proto__: null, identity: En2 });
new TextEncoder(), new TextDecoder();
var bi2 = { ...yr, ...mr, ...Dr2, ...wr, ...Ir2, ...$r2, ...kr2, ...Fr2, ...qr2, ...Xr2 };
({ ...vn, ...In });
function Tn(r3 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r3) : new Uint8Array(r3);
}
function mi2(r3, e, t, i3) {
  return { name: r3, prefix: e, encoder: { name: r3, prefix: e, encode: t }, decoder: { decode: i3 } };
}
var fi2 = mi2("utf8", "u", (r3) => "u" + new TextDecoder("utf8").decode(r3), (r3) => new TextEncoder().encode(r3.substring(1)));
var Be2 = mi2("ascii", "a", (r3) => {
  let e = "a";
  for (let t = 0; t < r3.length; t++) e += String.fromCharCode(r3[t]);
  return e;
}, (r3) => {
  r3 = r3.substring(1);
  const e = Tn(r3.length);
  for (let t = 0; t < r3.length; t++) e[t] = r3.charCodeAt(t);
  return e;
});
var Cn2 = { utf8: fi2, "utf-8": fi2, hex: bi2.base16, latin1: Be2, ascii: Be2, binary: Be2, ...bi2 };
function Pn2(r3, e = "utf8") {
  const t = Cn2[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r3, "utf8") : t.decoder.decode(`${t.prefix}${r3}`);
}
var Sn2 = Object.defineProperty;
var Rn = (r3, e, t) => e in r3 ? Sn2(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var W = (r3, e, t) => Rn(r3, typeof e != "symbol" ? e + "" : e, t);
var Di2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, W(this, "keychain", /* @__PURE__ */ new Map()), W(this, "name", Pt2), W(this, "version", St2), W(this, "initialized", false), W(this, "storagePrefix", B), W(this, "init", async () => {
      if (!this.initialized) {
        const i3 = await this.getKeyChain();
        typeof i3 < "u" && (this.keychain = i3), this.initialized = true;
      }
    }), W(this, "has", (i3) => (this.isInitialized(), this.keychain.has(i3))), W(this, "set", async (i3, s2) => {
      this.isInitialized(), this.keychain.set(i3, s2), await this.persist();
    }), W(this, "get", (i3) => {
      this.isInitialized();
      const s2 = this.keychain.get(i3);
      if (typeof s2 > "u") {
        const { message: n4 } = ht("NO_MATCHING_KEY", `${this.name}: ${i3}`);
        throw new Error(n4);
      }
      return s2;
    }), W(this, "del", async (i3) => {
      this.isInitialized(), this.keychain.delete(i3), await this.persist();
    }), this.core = e, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, fi(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? li(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var On2 = Object.defineProperty;
var An = (r3, e, t) => e in r3 ? On2(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var S2 = (r3, e, t) => An(r3, typeof e != "symbol" ? e + "" : e, t);
var vi2 = class {
  constructor(e, t, i3) {
    this.core = e, this.logger = t, S2(this, "name", Tt2), S2(this, "keychain"), S2(this, "randomSessionIdentifier", jc()), S2(this, "initialized", false), S2(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), S2(this, "hasKeys", (s2) => (this.isInitialized(), this.keychain.has(s2))), S2(this, "getClientId", async () => {
      this.isInitialized();
      const s2 = await this.getClientSeed(), n4 = Po(s2);
      return Qe(n4.publicKey);
    }), S2(this, "generateKeyPair", () => {
      this.isInitialized();
      const s2 = Lc();
      return this.setPrivateKey(s2.publicKey, s2.privateKey);
    }), S2(this, "signJWT", async (s2) => {
      this.isInitialized();
      const n4 = await this.getClientSeed(), o4 = Po(n4), a5 = this.randomSessionIdentifier, c7 = Ct2;
      return await Qo(a5, s2, c7, o4);
    }), S2(this, "generateSharedKey", (s2, n4, o4) => {
      this.isInitialized();
      const a5 = this.getPrivateKey(s2), c7 = Cc(a5, n4);
      return this.setSymKey(c7, o4);
    }), S2(this, "setSymKey", async (s2, n4) => {
      this.isInitialized();
      const o4 = n4 || Pc(s2);
      return await this.keychain.set(o4, s2), o4;
    }), S2(this, "deleteKeyPair", async (s2) => {
      this.isInitialized(), await this.keychain.del(s2);
    }), S2(this, "deleteSymKey", async (s2) => {
      this.isInitialized(), await this.keychain.del(s2);
    }), S2(this, "encode", async (s2, n4, o4) => {
      this.isInitialized();
      const a5 = oo(o4), c7 = safeJsonStringify(n4);
      if (Fc(a5)) return Dc(c7, o4 == null ? void 0 : o4.encoding);
      if (Kc(a5)) {
        const g4 = a5.senderPublicKey, _5 = a5.receiverPublicKey;
        s2 = await this.generateSharedKey(g4, _5);
      }
      const h7 = this.getSymKey(s2), { type: l7, senderPublicKey: d5 } = a5;
      return Vc({ type: l7, symKey: h7, message: c7, senderPublicKey: d5, encoding: o4 == null ? void 0 : o4.encoding });
    }), S2(this, "decode", async (s2, n4, o4) => {
      this.isInitialized();
      const a5 = qc(n4, o4);
      if (Fc(a5)) {
        const c7 = Hc(n4, o4 == null ? void 0 : o4.encoding);
        return safeJsonParse(c7);
      }
      if (Kc(a5)) {
        const c7 = a5.receiverPublicKey, h7 = a5.senderPublicKey;
        s2 = await this.generateSharedKey(c7, h7);
      }
      try {
        const c7 = this.getSymKey(s2), h7 = Mc({ symKey: c7, encoded: n4, encoding: o4 == null ? void 0 : o4.encoding });
        return safeJsonParse(h7);
      } catch (c7) {
        this.logger.error(`Failed to decode message from topic: '${s2}', clientId: '${await this.getClientId()}'`), this.logger.error(c7);
      }
    }), S2(this, "getPayloadType", (s2, n4 = Ht) => {
      const o4 = ve({ encoded: s2, encoding: n4 });
      return Bt(o4.type);
    }), S2(this, "getPayloadSenderPublicKey", (s2, n4 = Ht) => {
      const o4 = ve({ encoded: s2, encoding: n4 });
      return o4.senderPublicKey ? toString2(o4.senderPublicKey, G) : void 0;
    }), this.core = e, this.logger = E(t, this.name), this.keychain = i3 || new Di2(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(ke);
    } catch {
      e = jc(), await this.keychain.set(ke, e);
    }
    return Pn2(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var xn2 = Object.defineProperty;
var Nn = Object.defineProperties;
var $n2 = Object.getOwnPropertyDescriptors;
var wi2 = Object.getOwnPropertySymbols;
var zn = Object.prototype.hasOwnProperty;
var Ln = Object.prototype.propertyIsEnumerable;
var Ve = (r3, e, t) => e in r3 ? xn2(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var kn2 = (r3, e) => {
  for (var t in e || (e = {})) zn.call(e, t) && Ve(r3, t, e[t]);
  if (wi2) for (var t of wi2(e)) Ln.call(e, t) && Ve(r3, t, e[t]);
  return r3;
};
var jn2 = (r3, e) => Nn(r3, $n2(e));
var k3 = (r3, e, t) => Ve(r3, typeof e != "symbol" ? e + "" : e, t);
var _i2 = class extends y3 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, k3(this, "messages", /* @__PURE__ */ new Map()), k3(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), k3(this, "name", Rt2), k3(this, "version", Ot2), k3(this, "initialized", false), k3(this, "storagePrefix", B), k3(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i3 = await this.getRelayerMessages();
          typeof i3 < "u" && (this.messages = i3);
          const s2 = await this.getRelayerMessagesWithoutClientAck();
          typeof s2 < "u" && (this.messagesWithoutClientAck = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i3) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i3);
        } finally {
          this.initialized = true;
        }
      }
    }), k3(this, "set", async (i3, s2, n4) => {
      this.isInitialized();
      const o4 = kc(s2);
      let a5 = this.messages.get(i3);
      if (typeof a5 > "u" && (a5 = {}), typeof a5[o4] < "u") return o4;
      if (a5[o4] = s2, this.messages.set(i3, a5), n4 === le.inbound) {
        const c7 = this.messagesWithoutClientAck.get(i3) || {};
        this.messagesWithoutClientAck.set(i3, jn2(kn2({}, c7), { [o4]: s2 }));
      }
      return await this.persist(), o4;
    }), k3(this, "get", (i3) => {
      this.isInitialized();
      let s2 = this.messages.get(i3);
      return typeof s2 > "u" && (s2 = {}), s2;
    }), k3(this, "getWithoutAck", (i3) => {
      this.isInitialized();
      const s2 = {};
      for (const n4 of i3) {
        const o4 = this.messagesWithoutClientAck.get(n4) || {};
        s2[n4] = Object.values(o4);
      }
      return s2;
    }), k3(this, "has", (i3, s2) => {
      this.isInitialized();
      const n4 = this.get(i3), o4 = kc(s2);
      return typeof n4[o4] < "u";
    }), k3(this, "ack", async (i3, s2) => {
      this.isInitialized();
      const n4 = this.messagesWithoutClientAck.get(i3);
      if (typeof n4 > "u") return;
      const o4 = kc(s2);
      delete n4[o4], Object.keys(n4).length === 0 ? this.messagesWithoutClientAck.delete(i3) : this.messagesWithoutClientAck.set(i3, n4), await this.persist();
    }), k3(this, "del", async (i3) => {
      this.isInitialized(), this.messages.delete(i3), this.messagesWithoutClientAck.delete(i3), await this.persist();
    }), this.logger = E(e, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, fi(e));
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, fi(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? li(e) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e < "u" ? li(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Un = Object.defineProperty;
var Fn = Object.defineProperties;
var Mn2 = Object.getOwnPropertyDescriptors;
var Ei2 = Object.getOwnPropertySymbols;
var Kn = Object.prototype.hasOwnProperty;
var Bn = Object.prototype.propertyIsEnumerable;
var qe = (r3, e, t) => e in r3 ? Un(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var Ie = (r3, e) => {
  for (var t in e || (e = {})) Kn.call(e, t) && qe(r3, t, e[t]);
  if (Ei2) for (var t of Ei2(e)) Bn.call(e, t) && qe(r3, t, e[t]);
  return r3;
};
var Ge2 = (r3, e) => Fn(r3, Mn2(e));
var V2 = (r3, e, t) => qe(r3, typeof e != "symbol" ? e + "" : e, t);
var Vn2 = class extends m {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, V2(this, "events", new import_events7.EventEmitter()), V2(this, "name", At2), V2(this, "queue", /* @__PURE__ */ new Map()), V2(this, "publishTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE)), V2(this, "initialPublishTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15)), V2(this, "needsTransportRestart", false), V2(this, "publish", async (i3, s2, n4) => {
      var o4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s2, opts: n4 } });
      const a5 = (n4 == null ? void 0 : n4.ttl) || je2, c7 = Zc(n4), h7 = (n4 == null ? void 0 : n4.prompt) || false, l7 = (n4 == null ? void 0 : n4.tag) || 0, d5 = (n4 == null ? void 0 : n4.id) || getBigIntRpcId().toString(), g4 = { topic: i3, message: s2, opts: { ttl: a5, relay: c7, prompt: h7, tag: l7, id: d5, attestation: n4 == null ? void 0 : n4.attestation, tvf: n4 == null ? void 0 : n4.tvf } }, _5 = `Failed to publish payload, please try again. id:${d5} tag:${l7}`;
      try {
        const u4 = new Promise(async (b6) => {
          const x7 = ({ id: D5 }) => {
            g4.opts.id === D5 && (this.removeRequestFromQueue(D5), this.relayer.events.removeListener(C2.publish, x7), b6(g4));
          };
          this.relayer.events.on(C2.publish, x7);
          const I5 = yi(new Promise((D5, j7) => {
            this.rpcPublish({ topic: i3, message: s2, ttl: a5, prompt: h7, tag: l7, id: d5, attestation: n4 == null ? void 0 : n4.attestation, tvf: n4 == null ? void 0 : n4.tvf }).then(D5).catch((T4) => {
              this.logger.warn(T4, T4 == null ? void 0 : T4.message), j7(T4);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d5} tag:${l7}`);
          try {
            await I5, this.events.removeListener(C2.publish, x7);
          } catch (D5) {
            this.queue.set(d5, Ge2(Ie({}, g4), { attempt: 1 })), this.logger.warn(D5, D5 == null ? void 0 : D5.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: d5, topic: i3, message: s2, opts: n4 } }), await yi(u4, this.publishTimeout, _5);
      } catch (u4) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(u4), (o4 = n4 == null ? void 0 : n4.internal) != null && o4.throwOnFailedPublish) throw u4;
      } finally {
        this.queue.delete(d5);
      }
    }), V2(this, "on", (i3, s2) => {
      this.events.on(i3, s2);
    }), V2(this, "once", (i3, s2) => {
      this.events.once(i3, s2);
    }), V2(this, "off", (i3, s2) => {
      this.events.off(i3, s2);
    }), V2(this, "removeListener", (i3, s2) => {
      this.events.removeListener(i3, s2);
    }), this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  async rpcPublish(e) {
    var t, i3, s2, n4;
    const { topic: o4, message: a5, ttl: c7 = je2, prompt: h7, tag: l7, id: d5, attestation: g4, tvf: _5 } = e, u4 = { method: Yc(Zc().protocol).publish, params: Ie({ topic: o4, message: a5, ttl: c7, prompt: h7, tag: l7, attestation: g4 }, _5), id: d5 };
    Et((t = u4.params) == null ? void 0 : t.prompt) && ((i3 = u4.params) == null || delete i3.prompt), Et((s2 = u4.params) == null ? void 0 : s2.tag) && ((n4 = u4.params) == null || delete n4.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: u4 });
    const b6 = await this.relayer.request(u4);
    return this.relayer.events.emit(C2.publish, e), this.logger.debug("Successfully Published Payload"), b6;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, t) => {
      const i3 = e.attempt + 1;
      this.queue.set(t, Ge2(Ie({}, e), { attempt: i3 }));
      const { topic: s2, message: n4, opts: o4, attestation: a5 } = e;
      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${i3}`), await this.rpcPublish(Ge2(Ie({}, e), { topic: s2, message: n4, ttl: o4.ttl, prompt: o4.prompt, tag: o4.tag, id: o4.id, attestation: a5, tvf: o4.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r2.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(C2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(C2.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var qn = Object.defineProperty;
var Gn2 = (r3, e, t) => e in r3 ? qn(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var re2 = (r3, e, t) => Gn2(r3, typeof e != "symbol" ? e + "" : e, t);
var Wn2 = class {
  constructor() {
    re2(this, "map", /* @__PURE__ */ new Map()), re2(this, "set", (e, t) => {
      const i3 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i3, t]);
    }), re2(this, "get", (e) => this.map.get(e) || []), re2(this, "exists", (e, t) => this.get(e).includes(t)), re2(this, "delete", (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const i3 = this.get(e);
      if (!this.exists(e, t)) return;
      const s2 = i3.filter((n4) => n4 !== t);
      if (!s2.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s2);
    }), re2(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Hn = Object.defineProperty;
var Yn = Object.defineProperties;
var Jn2 = Object.getOwnPropertyDescriptors;
var Ii2 = Object.getOwnPropertySymbols;
var Xn2 = Object.prototype.hasOwnProperty;
var Zn = Object.prototype.propertyIsEnumerable;
var We2 = (r3, e, t) => e in r3 ? Hn(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var ge2 = (r3, e) => {
  for (var t in e || (e = {})) Xn2.call(e, t) && We2(r3, t, e[t]);
  if (Ii2) for (var t of Ii2(e)) Zn.call(e, t) && We2(r3, t, e[t]);
  return r3;
};
var He = (r3, e) => Yn(r3, Jn2(e));
var f3 = (r3, e, t) => We2(r3, typeof e != "symbol" ? e + "" : e, t);
var Ti2 = class extends P {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, f3(this, "subscriptions", /* @__PURE__ */ new Map()), f3(this, "topicMap", new Wn2()), f3(this, "events", new import_events7.EventEmitter()), f3(this, "name", Ut), f3(this, "version", Ft), f3(this, "pending", /* @__PURE__ */ new Map()), f3(this, "cached", []), f3(this, "initialized", false), f3(this, "storagePrefix", B), f3(this, "subscribeTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE)), f3(this, "initialSubscribeTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15)), f3(this, "clientId"), f3(this, "batchSubscribeTopicsLimit", 500), f3(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), f3(this, "subscribe", async (i3, s2) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s2 } });
      try {
        const n4 = Zc(s2), o4 = { topic: i3, relay: n4, transportType: s2 == null ? void 0 : s2.transportType };
        this.pending.set(i3, o4);
        const a5 = await this.rpcSubscribe(i3, n4, s2);
        return typeof a5 == "string" && (this.onSubscribe(a5, o4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s2 } })), a5;
      } catch (n4) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n4), n4;
      }
    }), f3(this, "unsubscribe", async (i3, s2) => {
      this.isInitialized(), typeof (s2 == null ? void 0 : s2.id) < "u" ? await this.unsubscribeById(i3, s2.id, s2) : await this.unsubscribeByTopic(i3, s2);
    }), f3(this, "isSubscribed", (i3) => new Promise((s2) => {
      s2(this.topicMap.topics.includes(i3));
    })), f3(this, "isKnownTopic", (i3) => new Promise((s2) => {
      s2(this.topicMap.topics.includes(i3) || this.pending.has(i3) || this.cached.some((n4) => n4.topic === i3));
    })), f3(this, "on", (i3, s2) => {
      this.events.on(i3, s2);
    }), f3(this, "once", (i3, s2) => {
      this.events.once(i3, s2);
    }), f3(this, "off", (i3, s2) => {
      this.events.off(i3, s2);
    }), f3(this, "removeListener", (i3, s2) => {
      this.events.removeListener(i3, s2);
    }), f3(this, "start", async () => {
      await this.onConnect();
    }), f3(this, "stop", async () => {
      await this.onDisconnect();
    }), f3(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), f3(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const i3 = [];
      this.pending.forEach((s2) => {
        i3.push(s2);
      }), await this.batchSubscribe(i3);
    }), f3(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r2.pulse, async () => {
        await this.checkPending();
      }), this.events.on($.created, async (i3) => {
        const s2 = $.created;
        this.logger.info(`Emitting ${s2}`), this.logger.debug({ type: "event", event: s2, data: i3 }), await this.persist();
      }), this.events.on($.deleted, async (i3) => {
        const s2 = $.deleted;
        this.logger.info(`Emitting ${s2}`), this.logger.debug({ type: "event", event: s2, data: i3 }), await this.persist();
      });
    }), this.relayer = e, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e, t) {
    let i3 = false;
    try {
      i3 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i3;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i3 = this.topicMap.get(e);
    await Promise.all(i3.map(async (s2) => await this.unsubscribeById(e, s2, t)));
  }
  async unsubscribeById(e, t, i3) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    try {
      const s2 = Zc(i3);
      await this.restartToComplete({ topic: e, id: t, relay: s2 }), await this.rpcUnsubscribe(e, t, s2);
      const n4 = Nt("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n4), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    } catch (s2) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s2), s2;
    }
  }
  async rpcSubscribe(e, t, i3) {
    var s2;
    (!i3 || (i3 == null ? void 0 : i3.transportType) === Q.relay) && await this.restartToComplete({ topic: e, id: e, relay: t });
    const n4 = { method: Yc(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n4 });
    const o4 = (s2 = i3 == null ? void 0 : i3.internal) == null ? void 0 : s2.throwOnFailedPublish;
    try {
      const a5 = await this.getSubscriptionId(e);
      if ((i3 == null ? void 0 : i3.transportType) === Q.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(n4).catch((l7) => this.logger.warn(l7));
      }, (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND)), a5;
      const c7 = new Promise(async (l7) => {
        const d5 = (g4) => {
          g4.topic === e && (this.events.removeListener($.created, d5), l7(g4.id));
        };
        this.events.on($.created, d5);
        try {
          const g4 = await yi(new Promise((_5, u4) => {
            this.relayer.request(n4).catch((b6) => {
              this.logger.warn(b6, b6 == null ? void 0 : b6.message), u4(b6);
            }).then(_5);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener($.created, d5), l7(g4);
        } catch {
        }
      }), h7 = await yi(c7, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!h7 && o4) throw new Error(`Subscribing to ${e} failed, please try again`);
      return h7 ? a5 : null;
    } catch (a5) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(C2.connection_stalled), o4) throw a5;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, i3 = { method: Yc(t.protocol).batchSubscribe, params: { topics: e.map((s2) => s2.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      await await yi(new Promise((s2) => {
        this.relayer.request(i3).catch((n4) => this.logger.warn(n4)).then(s2);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(C2.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, i3 = { method: Yc(t.protocol).batchFetchMessages, params: { topics: e.map((n4) => n4.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    let s2;
    try {
      s2 = await await yi(new Promise((n4, o4) => {
        this.relayer.request(i3).catch((a5) => {
          this.logger.warn(a5), o4(a5);
        }).then(n4);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(C2.connection_stalled);
    }
    return s2;
  }
  rpcUnsubscribe(e, t, i3) {
    const s2 = { method: Yc(i3.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 }), this.relayer.request(s2);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, He(ge2({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, ge2({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i3) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i3), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, ge2({}, t)), this.topicMap.set(t.topic, e), this.events.emit($.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i3 } = ht("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i3 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i3.topic, e), this.events.emit($.deleted, He(ge2({}, i3), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit($.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let i3 = 0; i3 < t; i3++) {
        const s2 = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s2);
      }
    }
    this.events.emit($.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: t } = ht("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t) => He(ge2({}, t), { id: await this.getSubscriptionId(t.topic) })))));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (await Ni((0, import_time3.toMiliseconds)(import_time3.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e) {
    return kc(e + await this.getClientId());
  }
};
var Qn2 = Object.defineProperty;
var Ci2 = Object.getOwnPropertySymbols;
var eo2 = Object.prototype.hasOwnProperty;
var to2 = Object.prototype.propertyIsEnumerable;
var Ye2 = (r3, e, t) => e in r3 ? Qn2(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var Pi2 = (r3, e) => {
  for (var t in e || (e = {})) eo2.call(e, t) && Ye2(r3, t, e[t]);
  if (Ci2) for (var t of Ci2(e)) to2.call(e, t) && Ye2(r3, t, e[t]);
  return r3;
};
var y4 = (r3, e, t) => Ye2(r3, typeof e != "symbol" ? e + "" : e, t);
var Si = class extends d {
  constructor(e) {
    super(e), y4(this, "protocol", "wc"), y4(this, "version", 2), y4(this, "core"), y4(this, "logger"), y4(this, "events", new import_events7.EventEmitter()), y4(this, "provider"), y4(this, "messages"), y4(this, "subscriber"), y4(this, "publisher"), y4(this, "name", $t2), y4(this, "transportExplicitlyClosed", false), y4(this, "initialized", false), y4(this, "connectionAttemptInProgress", false), y4(this, "relayUrl"), y4(this, "projectId"), y4(this, "packageName"), y4(this, "bundleId"), y4(this, "hasExperiencedNetworkDisruption", false), y4(this, "pingTimeout"), y4(this, "heartBeatTimeout", (0, import_time3.toMiliseconds)(import_time3.THIRTY_SECONDS + import_time3.FIVE_SECONDS)), y4(this, "reconnectTimeout"), y4(this, "connectPromise"), y4(this, "reconnectInProgress", false), y4(this, "requestsInFlight", []), y4(this, "connectTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15)), y4(this, "request", async (t) => {
      var i3, s2;
      this.logger.debug("Publishing Request Payload");
      const n4 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: n4, method: t.method, topic: (i3 = t.params) == null ? void 0 : i3.topic }, "relayer.request - publishing...");
        const o4 = `${n4}:${((s2 = t.params) == null ? void 0 : s2.tag) || ""}`;
        this.requestsInFlight.push(o4);
        const a5 = await this.provider.request(t);
        return this.requestsInFlight = this.requestsInFlight.filter((c7) => c7 !== o4), a5;
      } catch (o4) {
        throw this.logger.debug(`Failed to Publish Request: ${n4}`), o4;
      }
    }), y4(this, "resetPingTimeout", () => {
      Re() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var t, i3, s2, n4;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n4 = (s2 = (i3 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : i3.socket) == null ? void 0 : s2.terminate) == null || n4.call(s2);
        } catch (o4) {
          this.logger.warn(o4, o4 == null ? void 0 : o4.message);
        }
      }, this.heartBeatTimeout));
    }), y4(this, "onPayloadHandler", (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }), y4(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(C2.connect);
    }), y4(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), y4(this, "onProviderErrorHandler", (t) => {
      this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(C2.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), y4(this, "registerProviderListeners", () => {
      this.provider.on(L.payload, this.onPayloadHandler), this.provider.on(L.connect, this.onConnectHandler), this.provider.on(L.disconnect, this.onDisconnectHandler), this.provider.on(L.error, this.onProviderErrorHandler);
    }), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E(e.logger, this.name) : (0, import_pino.default)(k({ level: e.logger || Nt2 })), this.messages = new _i2(this.logger, e.core), this.subscriber = new Ti2(this, this.logger), this.publisher = new Vn2(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ue, this.projectId = e.projectId, ei() ? this.packageName = ri() : ni() && (this.bundleId = ri()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.hasAnyTopics) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e, e == null ? void 0 : e.message);
    }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e, t, i3;
    return ((i3 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i3.readyState) === 1 || false;
  }
  get connecting() {
    var e, t, i3;
    return ((i3 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i3.readyState) === 0 || this.connectPromise !== void 0 || false;
  }
  async publish(e, t, i3) {
    this.isInitialized(), await this.publisher.publish(e, t, i3), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: Q.relay }, le.outbound);
  }
  async subscribe(e, t) {
    var i3, s2, n4;
    this.isInitialized(), (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
    const o4 = typeof ((i3 = t == null ? void 0 : t.internal) == null ? void 0 : i3.throwOnFailedPublish) > "u" ? true : (s2 = t == null ? void 0 : t.internal) == null ? void 0 : s2.throwOnFailedPublish;
    let a5 = ((n4 = this.subscriber.topicMap.get(e)) == null ? void 0 : n4[0]) || "", c7;
    const h7 = (l7) => {
      l7.topic === e && (this.subscriber.off($.created, h7), c7());
    };
    return await Promise.all([new Promise((l7) => {
      c7 = l7, this.subscriber.on($.created, h7);
    }), new Promise(async (l7, d5) => {
      a5 = await this.subscriber.subscribe(e, Pi2({ internal: { throwOnFailedPublish: o4 } }, t)).catch((g4) => {
        o4 && d5(g4);
      }) || a5, l7();
    })]), a5;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await yi(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, i3) => {
      await this.connect(e).then(t).catch(i3).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Ia()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((i3, s2) => i3.publishedAt - s2.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const i3 of t) try {
      await this.onMessageEvent(i3);
    } catch (s2) {
      this.logger.warn(s2, "Error while processing batch message event: " + (s2 == null ? void 0 : s2.message));
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: i3 } = e;
    if (!t.sessionExists) {
      const s2 = Ei(import_time3.FIVE_MINUTES), n4 = { topic: i3, expiry: s2, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(i3, n4);
    }
    this.events.emit(C2.message, e), await this.recordMessageEvent(e, le.inbound);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t = 1;
    for (; t < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (i3, s2) => {
          const n4 = () => {
            s2(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(L.disconnect, n4), await yi(new Promise((o4, a5) => {
            this.provider.connect().then(o4).catch(a5);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o4) => {
            s2(o4);
          }).finally(() => {
            this.provider.off(L.disconnect, n4), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o4, a5) => {
            const c7 = () => {
              a5(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(L.disconnect, c7), await this.subscriber.start().then(o4).catch(a5).finally(() => {
              this.provider.off(L.disconnect, c7);
            });
          }), this.hasExperiencedNetworkDisruption = false, i3();
        });
      } catch (i3) {
        await this.subscriber.stop();
        const s2 = i3;
        this.logger.warn({}, s2.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((i3) => setTimeout(i3, (0, import_time3.toMiliseconds)(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e, t, i3, s2, n4;
    if (Re()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((n4 = (s2 = (i3 = this.provider) == null ? void 0 : i3.connection) == null ? void 0 : s2.socket) == null || n4.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o4) {
      this.logger.warn(o4, o4 == null ? void 0 : o4.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o2(new f2(si({ sdkVersion: _e2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e, t) {
    const { topic: i3, message: s2 } = e;
    await this.messages.set(i3, s2, t);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    if (!i3 || i3.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${i3}`), true;
    if (!await this.subscriber.isKnownTopic(t)) return this.logger.warn(`Ignoring message for unknown topic ${t}`), true;
    const s2 = this.messages.has(t, i3);
    return s2 && this.logger.warn(`Ignoring duplicate message: ${i3}`), s2;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(zt)) return;
      const t = e.params, { topic: i3, message: s2, publishedAt: n4, attestation: o4 } = t.data, a5 = { topic: i3, message: s2, publishedAt: n4, transportType: Q.relay, attestation: o4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Pi2({ type: "event", event: t.id }, a5)), this.events.emit(t.id, a5), await this.acknowledgePayload(e), await this.onMessageEvent(a5);
    } else isJsonRpcResponse(e) && this.events.emit(C2.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, le.inbound), this.events.emit(C2.message, e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(L.payload, this.onPayloadHandler), this.provider.off(L.connect, this.onConnectHandler), this.provider.off(L.disconnect, this.onDisconnectHandler), this.provider.off(L.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await Ia();
    Na(async (t) => {
      e !== t && (e = t, t ? await this.transportOpen().catch((i3) => this.logger.error(i3, i3 == null ? void 0 : i3.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(C2.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e, e == null ? void 0 : e.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
    }, (0, import_time3.toMiliseconds)(Lt2)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && await this.connect();
  }
};
function io2() {
}
function Ri2(r3) {
  if (!r3 || typeof r3 != "object") return false;
  const e = Object.getPrototypeOf(r3);
  return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(r3) === "[object Object]" : false;
}
function Oi(r3) {
  return Object.getOwnPropertySymbols(r3).filter((e) => Object.prototype.propertyIsEnumerable.call(r3, e));
}
function Ai(r3) {
  return r3 == null ? r3 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r3);
}
var so2 = "[object RegExp]";
var ro2 = "[object String]";
var no2 = "[object Number]";
var oo2 = "[object Boolean]";
var xi2 = "[object Arguments]";
var ao2 = "[object Symbol]";
var co2 = "[object Date]";
var ho = "[object Map]";
var lo = "[object Set]";
var uo2 = "[object Array]";
var go = "[object Function]";
var po = "[object ArrayBuffer]";
var Je2 = "[object Object]";
var yo = "[object Error]";
var bo2 = "[object DataView]";
var mo = "[object Uint8Array]";
var fo = "[object Uint8ClampedArray]";
var Do = "[object Uint16Array]";
var vo = "[object Uint32Array]";
var wo2 = "[object BigUint64Array]";
var _o2 = "[object Int8Array]";
var Eo = "[object Int16Array]";
var Io = "[object Int32Array]";
var To2 = "[object BigInt64Array]";
var Co2 = "[object Float32Array]";
var Po3 = "[object Float64Array]";
function So(r3, e) {
  return r3 === e || Number.isNaN(r3) && Number.isNaN(e);
}
function Ro2(r3, e, t) {
  return pe2(r3, e, void 0, void 0, void 0, void 0, t);
}
function pe2(r3, e, t, i3, s2, n4, o4) {
  const a5 = o4(r3, e, t, i3, s2, n4);
  if (a5 !== void 0) return a5;
  if (typeof r3 == typeof e) switch (typeof r3) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
      return r3 === e;
    case "number":
      return r3 === e || Object.is(r3, e);
    case "function":
      return r3 === e;
    case "object":
      return ye2(r3, e, n4, o4);
  }
  return ye2(r3, e, n4, o4);
}
function ye2(r3, e, t, i3) {
  if (Object.is(r3, e)) return true;
  let s2 = Ai(r3), n4 = Ai(e);
  if (s2 === xi2 && (s2 = Je2), n4 === xi2 && (n4 = Je2), s2 !== n4) return false;
  switch (s2) {
    case ro2:
      return r3.toString() === e.toString();
    case no2: {
      const c7 = r3.valueOf(), h7 = e.valueOf();
      return So(c7, h7);
    }
    case oo2:
    case co2:
    case ao2:
      return Object.is(r3.valueOf(), e.valueOf());
    case so2:
      return r3.source === e.source && r3.flags === e.flags;
    case go:
      return r3 === e;
  }
  t = t ?? /* @__PURE__ */ new Map();
  const o4 = t.get(r3), a5 = t.get(e);
  if (o4 != null && a5 != null) return o4 === e;
  t.set(r3, e), t.set(e, r3);
  try {
    switch (s2) {
      case ho: {
        if (r3.size !== e.size) return false;
        for (const [c7, h7] of r3.entries()) if (!e.has(c7) || !pe2(h7, e.get(c7), c7, r3, e, t, i3)) return false;
        return true;
      }
      case lo: {
        if (r3.size !== e.size) return false;
        const c7 = Array.from(r3.values()), h7 = Array.from(e.values());
        for (let l7 = 0; l7 < c7.length; l7++) {
          const d5 = c7[l7], g4 = h7.findIndex((_5) => pe2(d5, _5, void 0, r3, e, t, i3));
          if (g4 === -1) return false;
          h7.splice(g4, 1);
        }
        return true;
      }
      case uo2:
      case mo:
      case fo:
      case Do:
      case vo:
      case wo2:
      case _o2:
      case Eo:
      case Io:
      case To2:
      case Co2:
      case Po3: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r3) !== Buffer.isBuffer(e) || r3.length !== e.length) return false;
        for (let c7 = 0; c7 < r3.length; c7++) if (!pe2(r3[c7], e[c7], c7, r3, e, t, i3)) return false;
        return true;
      }
      case po:
        return r3.byteLength !== e.byteLength ? false : ye2(new Uint8Array(r3), new Uint8Array(e), t, i3);
      case bo2:
        return r3.byteLength !== e.byteLength || r3.byteOffset !== e.byteOffset ? false : ye2(new Uint8Array(r3), new Uint8Array(e), t, i3);
      case yo:
        return r3.name === e.name && r3.message === e.message;
      case Je2: {
        if (!(ye2(r3.constructor, e.constructor, t, i3) || Ri2(r3) && Ri2(e))) return false;
        const h7 = [...Object.keys(r3), ...Oi(r3)], l7 = [...Object.keys(e), ...Oi(e)];
        if (h7.length !== l7.length) return false;
        for (let d5 = 0; d5 < h7.length; d5++) {
          const g4 = h7[d5], _5 = r3[g4];
          if (!Object.hasOwn(e, g4)) return false;
          const u4 = e[g4];
          if (!pe2(_5, u4, g4, r3, e, t, i3)) return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t.delete(r3), t.delete(e);
  }
}
function Oo(r3, e) {
  return Ro2(r3, e, io2);
}
var Ao = Object.defineProperty;
var Ni2 = Object.getOwnPropertySymbols;
var xo = Object.prototype.hasOwnProperty;
var No = Object.prototype.propertyIsEnumerable;
var Xe2 = (r3, e, t) => e in r3 ? Ao(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var $i2 = (r3, e) => {
  for (var t in e || (e = {})) xo.call(e, t) && Xe2(r3, t, e[t]);
  if (Ni2) for (var t of Ni2(e)) No.call(e, t) && Xe2(r3, t, e[t]);
  return r3;
};
var z2 = (r3, e, t) => Xe2(r3, typeof e != "symbol" ? e + "" : e, t);
var zi2 = class extends f {
  constructor(e, t, i3, s2 = B, n4 = void 0) {
    super(e, t, i3, s2), this.core = e, this.logger = t, this.name = i3, z2(this, "map", /* @__PURE__ */ new Map()), z2(this, "version", kt2), z2(this, "cached", []), z2(this, "initialized", false), z2(this, "getKey"), z2(this, "storagePrefix", B), z2(this, "recentlyDeleted", []), z2(this, "recentlyDeletedLimit", 200), z2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o4) => {
        this.getKey && o4 !== null && !Et(o4) ? this.map.set(this.getKey(o4), o4) : fa(o4) ? this.map.set(o4.id, o4) : la(o4) && this.map.set(o4.topic, o4);
      }), this.cached = [], this.initialized = true);
    }), z2(this, "set", async (o4, a5) => {
      this.isInitialized(), this.map.has(o4) ? await this.update(o4, a5) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o4, value: a5 }), this.map.set(o4, a5), await this.persist());
    }), z2(this, "get", (o4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o4 }), this.getData(o4))), z2(this, "getAll", (o4) => (this.isInitialized(), o4 ? this.values.filter((a5) => Object.keys(o4).every((c7) => Oo(a5[c7], o4[c7]))) : this.values)), z2(this, "update", async (o4, a5) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o4, update: a5 });
      const c7 = $i2($i2({}, this.getData(o4)), a5);
      this.map.set(o4, c7), await this.persist();
    }), z2(this, "delete", async (o4, a5) => {
      this.isInitialized(), this.map.has(o4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o4, reason: a5 }), this.map.delete(o4), this.addToRecentlyDeleted(o4), await this.persist());
    }), this.logger = E(t, this.name), this.storagePrefix = s2, this.getKey = n4;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: s2 } = ht("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(s2), new Error(s2);
      }
      const { message: i3 } = ht("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = ht("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var $o2 = Object.defineProperty;
var zo = (r3, e, t) => e in r3 ? $o2(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var p2 = (r3, e, t) => zo(r3, typeof e != "symbol" ? e + "" : e, t);
var Li2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, p2(this, "name", Mt2), p2(this, "version", Kt2), p2(this, "events", new import_events7.default()), p2(this, "pairings"), p2(this, "initialized", false), p2(this, "storagePrefix", B), p2(this, "ignoredPayloadTypes", [Kt]), p2(this, "registeredMethods", []), p2(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), p2(this, "register", ({ methods: i3 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i3])];
    }), p2(this, "create", async (i3) => {
      this.isInitialized();
      const s2 = jc(), n4 = await this.core.crypto.setSymKey(s2), o4 = Ei(import_time3.FIVE_MINUTES), a5 = { protocol: xt2 }, c7 = { topic: n4, expiry: o4, relay: a5, active: false, methods: i3 == null ? void 0 : i3.methods }, h7 = Wc({ protocol: this.core.protocol, version: this.core.version, topic: n4, symKey: s2, relay: a5, expiryTimestamp: o4, methods: i3 == null ? void 0 : i3.methods });
      return this.events.emit(se.create, c7), this.core.expirer.set(n4, o4), await this.pairings.set(n4, c7), await this.core.relayer.subscribe(n4, { transportType: i3 == null ? void 0 : i3.transportType }), { topic: n4, uri: h7 };
    }), p2(this, "pair", async (i3) => {
      this.isInitialized();
      const s2 = this.core.eventClient.createEvent({ properties: { topic: i3 == null ? void 0 : i3.uri, trace: [G2.pairing_started] } });
      this.isValidPair(i3, s2);
      const { topic: n4, symKey: o4, relay: a5, expiryTimestamp: c7, methods: h7 } = Gc(i3.uri);
      s2.props.properties.topic = n4, s2.addTrace(G2.pairing_uri_validation_success), s2.addTrace(G2.pairing_uri_not_expired);
      let l7;
      if (this.pairings.keys.includes(n4)) {
        if (l7 = this.pairings.get(n4), s2.addTrace(G2.existing_pairing), l7.active) throw s2.setError(Y2.active_pairing_already_exists), new Error(`Pairing already exists: ${n4}. Please try again with a new connection URI.`);
        s2.addTrace(G2.pairing_not_expired);
      }
      const d5 = c7 || Ei(import_time3.FIVE_MINUTES), g4 = { topic: n4, relay: a5, expiry: d5, active: false, methods: h7 };
      this.core.expirer.set(n4, d5), await this.pairings.set(n4, g4), s2.addTrace(G2.store_new_pairing), i3.activatePairing && await this.activate({ topic: n4 }), this.events.emit(se.create, g4), s2.addTrace(G2.emit_inactive_pairing), this.core.crypto.keychain.has(n4) || await this.core.crypto.setSymKey(o4, n4), s2.addTrace(G2.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        s2.setError(Y2.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(n4, { relay: a5 });
      } catch (_5) {
        throw s2.setError(Y2.subscribe_pairing_topic_failure), _5;
      }
      return s2.addTrace(G2.subscribe_pairing_topic_success), g4;
    }), p2(this, "activate", async ({ topic: i3 }) => {
      this.isInitialized();
      const s2 = Ei(import_time3.FIVE_MINUTES);
      this.core.expirer.set(i3, s2), await this.pairings.update(i3, { active: true, expiry: s2 });
    }), p2(this, "ping", async (i3) => {
      this.isInitialized(), await this.isValidPing(i3), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: s2 } = i3;
      if (this.pairings.keys.includes(s2)) {
        const n4 = await this.sendRequest(s2, "wc_pairingPing", {}), { done: o4, resolve: a5, reject: c7 } = gi();
        this.events.once(xi("pairing_ping", n4), ({ error: h7 }) => {
          h7 ? c7(h7) : a5();
        }), await o4();
      }
    }), p2(this, "updateExpiry", async ({ topic: i3, expiry: s2 }) => {
      this.isInitialized(), await this.pairings.update(i3, { expiry: s2 });
    }), p2(this, "updateMetadata", async ({ topic: i3, metadata: s2 }) => {
      this.isInitialized(), await this.pairings.update(i3, { peerMetadata: s2 });
    }), p2(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), p2(this, "disconnect", async (i3) => {
      this.isInitialized(), await this.isValidDisconnect(i3);
      const { topic: s2 } = i3;
      this.pairings.keys.includes(s2) && (await this.sendRequest(s2, "wc_pairingDelete", Nt("USER_DISCONNECTED")), await this.deletePairing(s2));
    }), p2(this, "formatUriFromPairing", (i3) => {
      this.isInitialized();
      const { topic: s2, relay: n4, expiry: o4, methods: a5 } = i3, c7 = this.core.crypto.keychain.get(s2);
      return Wc({ protocol: this.core.protocol, version: this.core.version, topic: s2, symKey: c7, relay: n4, expiryTimestamp: o4, methods: a5 });
    }), p2(this, "sendRequest", async (i3, s2, n4) => {
      const o4 = formatJsonRpcRequest(s2, n4), a5 = await this.core.crypto.encode(i3, o4), c7 = ie[s2].req;
      return this.core.history.set(i3, o4), this.core.relayer.publish(i3, a5, c7), o4.id;
    }), p2(this, "sendResult", async (i3, s2, n4) => {
      const o4 = formatJsonRpcResult(i3, n4), a5 = await this.core.crypto.encode(s2, o4), c7 = (await this.core.history.get(s2, i3)).request.method, h7 = ie[c7].res;
      await this.core.relayer.publish(s2, a5, h7), await this.core.history.resolve(o4);
    }), p2(this, "sendError", async (i3, s2, n4) => {
      const o4 = formatJsonRpcError(i3, n4), a5 = await this.core.crypto.encode(s2, o4), c7 = (await this.core.history.get(s2, i3)).request.method, h7 = ie[c7] ? ie[c7].res : ie.unregistered_method.res;
      await this.core.relayer.publish(s2, a5, h7), await this.core.history.resolve(o4);
    }), p2(this, "deletePairing", async (i3, s2) => {
      await this.core.relayer.unsubscribe(i3), await Promise.all([this.pairings.delete(i3, Nt("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i3), s2 ? Promise.resolve() : this.core.expirer.del(i3)]);
    }), p2(this, "cleanup", async () => {
      const i3 = this.pairings.getAll().filter((s2) => vi(s2.expiry));
      await Promise.all(i3.map((s2) => this.deletePairing(s2.topic)));
    }), p2(this, "onRelayEventRequest", async (i3) => {
      const { topic: s2, payload: n4 } = i3;
      switch (n4.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(s2, n4);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(s2, n4);
        default:
          return await this.onUnknownRpcMethodRequest(s2, n4);
      }
    }), p2(this, "onRelayEventResponse", async (i3) => {
      const { topic: s2, payload: n4 } = i3, o4 = (await this.core.history.get(s2, n4.id)).request.method;
      switch (o4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s2, n4);
        default:
          return this.onUnknownRpcMethodResponse(o4);
      }
    }), p2(this, "onPairingPingRequest", async (i3, s2) => {
      const { id: n4 } = s2;
      try {
        this.isValidPing({ topic: i3 }), await this.sendResult(n4, i3, true), this.events.emit(se.ping, { id: n4, topic: i3 });
      } catch (o4) {
        await this.sendError(n4, i3, o4), this.logger.error(o4);
      }
    }), p2(this, "onPairingPingResponse", (i3, s2) => {
      const { id: n4 } = s2;
      setTimeout(() => {
        isJsonRpcResult(s2) ? this.events.emit(xi("pairing_ping", n4), {}) : isJsonRpcError(s2) && this.events.emit(xi("pairing_ping", n4), { error: s2.error });
      }, 500);
    }), p2(this, "onPairingDeleteRequest", async (i3, s2) => {
      const { id: n4 } = s2;
      try {
        this.isValidDisconnect({ topic: i3 }), await this.deletePairing(i3), this.events.emit(se.delete, { id: n4, topic: i3 });
      } catch (o4) {
        await this.sendError(n4, i3, o4), this.logger.error(o4);
      }
    }), p2(this, "onUnknownRpcMethodRequest", async (i3, s2) => {
      const { id: n4, method: o4 } = s2;
      try {
        if (this.registeredMethods.includes(o4)) return;
        const a5 = Nt("WC_METHOD_UNSUPPORTED", o4);
        await this.sendError(n4, i3, a5), this.logger.error(a5);
      } catch (a5) {
        await this.sendError(n4, i3, a5), this.logger.error(a5);
      }
    }), p2(this, "onUnknownRpcMethodResponse", (i3) => {
      this.registeredMethods.includes(i3) || this.logger.error(Nt("WC_METHOD_UNSUPPORTED", i3));
    }), p2(this, "isValidPair", (i3, s2) => {
      var n4;
      if (!ya(i3)) {
        const { message: a5 } = ht("MISSING_OR_INVALID", `pair() params: ${i3}`);
        throw s2.setError(Y2.malformed_pairing_uri), new Error(a5);
      }
      if (!ua(i3.uri)) {
        const { message: a5 } = ht("MISSING_OR_INVALID", `pair() uri: ${i3.uri}`);
        throw s2.setError(Y2.malformed_pairing_uri), new Error(a5);
      }
      const o4 = Gc(i3 == null ? void 0 : i3.uri);
      if (!((n4 = o4 == null ? void 0 : o4.relay) != null && n4.protocol)) {
        const { message: a5 } = ht("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw s2.setError(Y2.malformed_pairing_uri), new Error(a5);
      }
      if (!(o4 != null && o4.symKey)) {
        const { message: a5 } = ht("MISSING_OR_INVALID", "pair() uri#symKey");
        throw s2.setError(Y2.malformed_pairing_uri), new Error(a5);
      }
      if (o4 != null && o4.expiryTimestamp && (0, import_time3.toMiliseconds)(o4 == null ? void 0 : o4.expiryTimestamp) < Date.now()) {
        s2.setError(Y2.pairing_expired);
        const { message: a5 } = ht("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a5);
      }
    }), p2(this, "isValidPing", async (i3) => {
      if (!ya(i3)) {
        const { message: n4 } = ht("MISSING_OR_INVALID", `ping() params: ${i3}`);
        throw new Error(n4);
      }
      const { topic: s2 } = i3;
      await this.isValidPairingTopic(s2);
    }), p2(this, "isValidDisconnect", async (i3) => {
      if (!ya(i3)) {
        const { message: n4 } = ht("MISSING_OR_INVALID", `disconnect() params: ${i3}`);
        throw new Error(n4);
      }
      const { topic: s2 } = i3;
      await this.isValidPairingTopic(s2);
    }), p2(this, "isValidPairingTopic", async (i3) => {
      if (!nt(i3, false)) {
        const { message: s2 } = ht("MISSING_OR_INVALID", `pairing topic should be a string: ${i3}`);
        throw new Error(s2);
      }
      if (!this.pairings.keys.includes(i3)) {
        const { message: s2 } = ht("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i3}`);
        throw new Error(s2);
      }
      if (vi(this.pairings.get(i3).expiry)) {
        await this.deletePairing(i3);
        const { message: s2 } = ht("EXPIRED", `pairing topic: ${i3}`);
        throw new Error(s2);
      }
    }), this.core = e, this.logger = E(t, this.name), this.pairings = new zi2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(C2.message, async (e) => {
      const { topic: t, message: i3, transportType: s2 } = e;
      if (this.pairings.keys.includes(t) && s2 !== Q.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i3))) try {
        const n4 = await this.core.crypto.decode(t, i3);
        isJsonRpcRequest(n4) ? (this.core.history.set(t, n4), await this.onRelayEventRequest({ topic: t, payload: n4 })) : isJsonRpcResponse(n4) && (await this.core.history.resolve(n4), await this.onRelayEventResponse({ topic: t, payload: n4 }), this.core.history.delete(t, n4.id)), await this.core.relayer.messages.ack(t, i3);
      } catch (n4) {
        this.logger.error(n4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(M2.expired, async (e) => {
      const { topic: t } = bi(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(se.expire, { topic: t }));
    });
  }
};
var Lo2 = Object.defineProperty;
var ko = (r3, e, t) => e in r3 ? Lo2(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var R2 = (r3, e, t) => ko(r3, typeof e != "symbol" ? e + "" : e, t);
var ki2 = class extends I {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, R2(this, "records", /* @__PURE__ */ new Map()), R2(this, "events", new import_events7.EventEmitter()), R2(this, "name", Bt2), R2(this, "version", Vt2), R2(this, "cached", []), R2(this, "initialized", false), R2(this, "storagePrefix", B), R2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.records.set(i3.id, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), R2(this, "set", (i3, s2, n4) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i3, request: s2, chainId: n4 }), this.records.has(s2.id)) return;
      const o4 = { id: s2.id, topic: i3, request: { method: s2.method, params: s2.params || null }, chainId: n4, expiry: Ei(import_time3.THIRTY_DAYS) };
      this.records.set(o4.id, o4), this.persist(), this.events.emit(F2.created, o4);
    }), R2(this, "resolve", async (i3) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i3 }), !this.records.has(i3.id)) return;
      const s2 = await this.getRecord(i3.id);
      typeof s2.response > "u" && (s2.response = isJsonRpcError(i3) ? { error: i3.error } : { result: i3.result }, this.records.set(s2.id, s2), this.persist(), this.events.emit(F2.updated, s2));
    }), R2(this, "get", async (i3, s2) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i3, id: s2 }), await this.getRecord(s2))), R2(this, "delete", (i3, s2) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s2 }), this.values.forEach((n4) => {
        if (n4.topic === i3) {
          if (typeof s2 < "u" && n4.id !== s2) return;
          this.records.delete(n4.id), this.events.emit(F2.deleted, n4);
        }
      }), this.persist();
    }), R2(this, "exists", async (i3, s2) => (this.isInitialized(), this.records.has(s2) ? (await this.getRecord(s2)).topic === i3 : false)), R2(this, "on", (i3, s2) => {
      this.events.on(i3, s2);
    }), R2(this, "once", (i3, s2) => {
      this.events.once(i3, s2);
    }), R2(this, "off", (i3, s2) => {
      this.events.off(i3, s2);
    }), R2(this, "removeListener", (i3, s2) => {
      this.events.removeListener(i3, s2);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const i3 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i3);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i3 } = ht("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(F2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = ht("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(F2.created, (e) => {
      const t = F2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(F2.updated, (e) => {
      const t = F2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(F2.deleted, (e) => {
      const t = F2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r2.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time3.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(F2.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var jo = Object.defineProperty;
var Uo = (r3, e, t) => e in r3 ? jo(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var A2 = (r3, e, t) => Uo(r3, typeof e != "symbol" ? e + "" : e, t);
var ji2 = class extends S {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, A2(this, "expirations", /* @__PURE__ */ new Map()), A2(this, "events", new import_events7.EventEmitter()), A2(this, "name", qt2), A2(this, "version", Gt2), A2(this, "cached", []), A2(this, "initialized", false), A2(this, "storagePrefix", B), A2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.expirations.set(i3.target, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), A2(this, "has", (i3) => {
      try {
        const s2 = this.formatTarget(i3);
        return typeof this.getExpiration(s2) < "u";
      } catch {
        return false;
      }
    }), A2(this, "set", (i3, s2) => {
      this.isInitialized();
      const n4 = this.formatTarget(i3), o4 = { target: n4, expiry: s2 };
      this.expirations.set(n4, o4), this.checkExpiry(n4, o4), this.events.emit(M2.created, { target: n4, expiration: o4 });
    }), A2(this, "get", (i3) => {
      this.isInitialized();
      const s2 = this.formatTarget(i3);
      return this.getExpiration(s2);
    }), A2(this, "del", (i3) => {
      if (this.isInitialized(), this.has(i3)) {
        const s2 = this.formatTarget(i3), n4 = this.getExpiration(s2);
        this.expirations.delete(s2), this.events.emit(M2.deleted, { target: s2, expiration: n4 });
      }
    }), A2(this, "on", (i3, s2) => {
      this.events.on(i3, s2);
    }), A2(this, "once", (i3, s2) => {
      this.events.once(i3, s2);
    }), A2(this, "off", (i3, s2) => {
      this.events.off(i3, s2);
    }), A2(this, "removeListener", (i3, s2) => {
      this.events.removeListener(i3, s2);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return mi(e);
    if (typeof e == "number") return wi(e);
    const { message: t } = ht("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(M2.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = ht("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i3 } = ht("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(i3), new Error(i3);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i3 } = t;
    (0, import_time3.toMiliseconds)(i3) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(M2.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r2.pulse, () => this.checkExpirations()), this.events.on(M2.created, (e) => {
      const t = M2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(M2.expired, (e) => {
      const t = M2.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(M2.deleted, (e) => {
      const t = M2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Fo = Object.defineProperty;
var Mo = (r3, e, t) => e in r3 ? Fo(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var w2 = (r3, e, t) => Mo(r3, typeof e != "symbol" ? e + "" : e, t);
var Ui2 = class extends M {
  constructor(e, t, i3) {
    super(e, t, i3), this.core = e, this.logger = t, this.store = i3, w2(this, "name", Wt2), w2(this, "abortController"), w2(this, "isDevEnv"), w2(this, "verifyUrlV3", Yt2), w2(this, "storagePrefix", B), w2(this, "version", Le2), w2(this, "publicKey"), w2(this, "fetchPromise"), w2(this, "init", async () => {
      var s2;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time3.toMiliseconds)((s2 = this.publicKey) == null ? void 0 : s2.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), w2(this, "register", async (s2) => {
      if (!Yt() || this.isDevEnv) return;
      const n4 = window.location.origin, { id: o4, decryptedId: a5 } = s2, c7 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n4}&id=${o4}&decryptedId=${a5}`;
      try {
        const h7 = (0, import_window_getters2.getDocument)(), l7 = this.startAbortTimer(import_time3.ONE_SECOND * 5), d5 = await new Promise((g4, _5) => {
          const u4 = () => {
            window.removeEventListener("message", x7), h7.body.removeChild(b6), _5("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u4);
          const b6 = h7.createElement("iframe");
          b6.src = c7, b6.style.display = "none", b6.addEventListener("error", u4, { signal: this.abortController.signal });
          const x7 = (I5) => {
            if (I5.data && typeof I5.data == "string") try {
              const D5 = JSON.parse(I5.data);
              if (D5.type === "verify_attestation") {
                if (sn(D5.attestation).payload.id !== o4) return;
                clearInterval(l7), h7.body.removeChild(b6), this.abortController.signal.removeEventListener("abort", u4), window.removeEventListener("message", x7), g4(D5.attestation === null ? "" : D5.attestation);
              }
            } catch (D5) {
              this.logger.warn(D5);
            }
          };
          h7.body.appendChild(b6), window.addEventListener("message", x7, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", d5), d5;
      } catch (h7) {
        this.logger.warn(h7);
      }
      return "";
    }), w2(this, "resolve", async (s2) => {
      if (this.isDevEnv) return "";
      const { attestationId: n4, hash: o4, encryptedId: a5 } = s2;
      if (n4 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (n4) {
        if (sn(n4).payload.id !== a5) return;
        const h7 = await this.isValidJwtAttestation(n4);
        if (h7) {
          if (!h7.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h7;
        }
      }
      if (!o4) return;
      const c7 = this.getVerifyUrl(s2 == null ? void 0 : s2.verifyUrl);
      return this.fetchAttestation(o4, c7);
    }), w2(this, "fetchAttestation", async (s2, n4) => {
      this.logger.debug(`resolving attestation: ${s2} from url: ${n4}`);
      const o4 = this.startAbortTimer(import_time3.ONE_SECOND * 5), a5 = await fetch(`${n4}/attestation/${s2}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o4), a5.status === 200 ? await a5.json() : void 0;
    }), w2(this, "getVerifyUrl", (s2) => {
      let n4 = s2 || ue2;
      return Jt2.includes(n4) || (this.logger.info(`verify url: ${n4}, not included in trusted list, assigning default: ${ue2}`), n4 = ue2), n4;
    }), w2(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const s2 = this.startAbortTimer(import_time3.FIVE_SECONDS), n4 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(s2), await n4.json();
      } catch (s2) {
        this.logger.warn(s2);
      }
    }), w2(this, "persistPublicKey", async (s2) => {
      this.logger.debug("persisting public key to local storage", s2), await this.store.setItem(this.storeKey, s2), this.publicKey = s2;
    }), w2(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), w2(this, "isValidJwtAttestation", async (s2) => {
      const n4 = await this.getPublicKey();
      try {
        if (n4) return this.validateAttestation(s2, n4);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
      const o4 = await this.fetchAndPersistPublicKey();
      try {
        if (o4) return this.validateAttestation(s2, o4);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
    }), w2(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), w2(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (n4) => {
        const o4 = await this.fetchPublicKey();
        o4 && (await this.persistPublicKey(o4), n4(o4));
      });
      const s2 = await this.fetchPromise;
      return this.fetchPromise = void 0, s2;
    }), w2(this, "validateAttestation", (s2, n4) => {
      const o4 = zc(s2, n4.publicKey), a5 = { hasExpired: (0, import_time3.toMiliseconds)(o4.exp) < Date.now(), payload: o4 };
      if (a5.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a5.payload.origin, isScam: a5.payload.isScam, isVerified: a5.payload.isVerified };
    }), this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Ii(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time3.toMiliseconds)(e));
  }
};
var Ko = Object.defineProperty;
var Bo = (r3, e, t) => e in r3 ? Ko(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var Fi2 = (r3, e, t) => Bo(r3, typeof e != "symbol" ? e + "" : e, t);
var Mi2 = class extends O2 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, Fi2(this, "context", Xt2), Fi2(this, "registerDeviceToken", async (i3) => {
      const { clientId: s2, token: n4, notificationType: o4, enableEncrypted: a5 = false } = i3, c7 = `${Zt}/${this.projectId}/clients`;
      await fetch(c7, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s2, type: o4, token: n4, always_raw: a5 }) });
    }), this.logger = E(t, this.context);
  }
};
var Vo = Object.defineProperty;
var Ki2 = Object.getOwnPropertySymbols;
var qo = Object.prototype.hasOwnProperty;
var Go = Object.prototype.propertyIsEnumerable;
var Ze2 = (r3, e, t) => e in r3 ? Vo(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var be2 = (r3, e) => {
  for (var t in e || (e = {})) qo.call(e, t) && Ze2(r3, t, e[t]);
  if (Ki2) for (var t of Ki2(e)) Go.call(e, t) && Ze2(r3, t, e[t]);
  return r3;
};
var E3 = (r3, e, t) => Ze2(r3, typeof e != "symbol" ? e + "" : e, t);
var Bi2 = class extends R {
  constructor(e, t, i3 = true) {
    super(e, t, i3), this.core = e, this.logger = t, E3(this, "context", ei2), E3(this, "storagePrefix", B), E3(this, "storageVersion", Qt2), E3(this, "events", /* @__PURE__ */ new Map()), E3(this, "shouldPersist", false), E3(this, "init", async () => {
      if (!Ii()) try {
        const s2 = { eventId: Bi(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Mn(this.core.relayer.protocol, this.core.relayer.version, _e2) } } };
        await this.sendEvent([s2]);
      } catch (s2) {
        this.logger.warn(s2);
      }
    }), E3(this, "createEvent", (s2) => {
      const { event: n4 = "ERROR", type: o4 = "", properties: { topic: a5, trace: c7 } } = s2, h7 = Bi(), l7 = this.core.projectId || "", d5 = Date.now(), g4 = be2({ eventId: h7, timestamp: d5, props: { event: n4, type: o4, properties: { topic: a5, trace: c7 } }, bundleId: l7, domain: this.getAppDomain() }, this.setMethods(h7));
      return this.telemetryEnabled && (this.events.set(h7, g4), this.shouldPersist = true), g4;
    }), E3(this, "getEvent", (s2) => {
      const { eventId: n4, topic: o4 } = s2;
      if (n4) return this.events.get(n4);
      const a5 = Array.from(this.events.values()).find((c7) => c7.props.properties.topic === o4);
      if (a5) return be2(be2({}, a5), this.setMethods(a5.eventId));
    }), E3(this, "deleteEvent", (s2) => {
      const { eventId: n4 } = s2;
      this.events.delete(n4), this.shouldPersist = true;
    }), E3(this, "setEventListeners", () => {
      this.core.heartbeat.on(r2.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((s2) => {
          (0, import_time3.fromMiliseconds)(Date.now()) - (0, import_time3.fromMiliseconds)(s2.timestamp) > ti && (this.events.delete(s2.eventId), this.shouldPersist = true);
        });
      });
    }), E3(this, "setMethods", (s2) => ({ addTrace: (n4) => this.addTrace(s2, n4), setError: (n4) => this.setError(s2, n4) })), E3(this, "addTrace", (s2, n4) => {
      const o4 = this.events.get(s2);
      o4 && (o4.props.properties.trace.push(n4), this.events.set(s2, o4), this.shouldPersist = true);
    }), E3(this, "setError", (s2, n4) => {
      const o4 = this.events.get(s2);
      o4 && (o4.props.type = n4, o4.timestamp = Date.now(), this.events.set(s2, o4), this.shouldPersist = true);
    }), E3(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), E3(this, "restore", async () => {
      try {
        const s2 = await this.core.storage.getItem(this.storageKey) || [];
        if (!s2.length) return;
        s2.forEach((n4) => {
          this.events.set(n4.eventId, be2(be2({}, n4), this.setMethods(n4.eventId)));
        });
      } catch (s2) {
        this.logger.warn(s2);
      }
    }), E3(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const s2 = [];
      for (const [n4, o4] of this.events) o4.props.type && s2.push(o4);
      if (s2.length !== 0) try {
        if ((await this.sendEvent(s2)).ok) for (const n4 of s2) this.events.delete(n4.eventId), this.shouldPersist = true;
      } catch (n4) {
        this.logger.warn(n4);
      }
    }), E3(this, "sendEvent", async (s2) => {
      const n4 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${ii}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${_e2}${n4}`, { method: "POST", body: JSON.stringify(s2) });
    }), E3(this, "getAppDomain", () => Pn().url), this.logger = E(t, this.context), this.telemetryEnabled = i3, i3 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Wo = Object.defineProperty;
var Vi2 = Object.getOwnPropertySymbols;
var Ho = Object.prototype.hasOwnProperty;
var Yo = Object.prototype.propertyIsEnumerable;
var Qe3 = (r3, e, t) => e in r3 ? Wo(r3, e, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e] = t;
var qi2 = (r3, e) => {
  for (var t in e || (e = {})) Ho.call(e, t) && Qe3(r3, t, e[t]);
  if (Vi2) for (var t of Vi2(e)) Yo.call(e, t) && Qe3(r3, t, e[t]);
  return r3;
};
var v3 = (r3, e, t) => Qe3(r3, typeof e != "symbol" ? e + "" : e, t);
var Te = class _Te extends h2 {
  constructor(e) {
    var t;
    super(e), v3(this, "protocol", ze2), v3(this, "version", Le2), v3(this, "name", he2), v3(this, "relayUrl"), v3(this, "projectId"), v3(this, "customStoragePrefix"), v3(this, "events", new import_events7.EventEmitter()), v3(this, "logger"), v3(this, "heartbeat"), v3(this, "relayer"), v3(this, "crypto"), v3(this, "storage"), v3(this, "history"), v3(this, "expirer"), v3(this, "pairing"), v3(this, "verify"), v3(this, "echoClient"), v3(this, "linkModeSupportedApps"), v3(this, "eventClient"), v3(this, "initialized", false), v3(this, "logChunkController"), v3(this, "on", (a5, c7) => this.events.on(a5, c7)), v3(this, "once", (a5, c7) => this.events.once(a5, c7)), v3(this, "off", (a5, c7) => this.events.off(a5, c7)), v3(this, "removeListener", (a5, c7) => this.events.removeListener(a5, c7)), v3(this, "dispatchEnvelope", ({ topic: a5, message: c7, sessionExists: h7 }) => {
      if (!a5 || !c7) return;
      const l7 = { topic: a5, message: c7, publishedAt: Date.now(), transportType: Q.link_mode };
      this.relayer.onLinkMessageEvent(l7, { sessionExists: h7 });
    });
    const i3 = this.getGlobalCore(e == null ? void 0 : e.customStoragePrefix);
    if (i3) try {
      return this.customStoragePrefix = i3.customStoragePrefix, this.logger = i3.logger, this.heartbeat = i3.heartbeat, this.crypto = i3.crypto, this.history = i3.history, this.expirer = i3.expirer, this.storage = i3.storage, this.relayer = i3.relayer, this.pairing = i3.pairing, this.verify = i3.verify, this.echoClient = i3.echoClient, this.linkModeSupportedApps = i3.linkModeSupportedApps, this.eventClient = i3.eventClient, this.initialized = i3.initialized, this.logChunkController = i3.logChunkController, i3;
    } catch (a5) {
      console.warn("Failed to copy global core", a5);
    }
    this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ue, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s2 = k({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : Et2.logger, name: he2 }), { logger: n4, chunkLoggerController: o4 } = A({ opts: s2, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = o4, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var a5, c7;
      (a5 = this.logChunkController) != null && a5.downloadLogsBlobInBrowser && ((c7 = this.logChunkController) == null || c7.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(n4, this.name), this.heartbeat = new i(), this.crypto = new vi2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new ki2(this, this.logger), this.expirer = new ji2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(qi2(qi2({}, It), e == null ? void 0 : e.storageOptions)), this.relayer = new Si({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Li2(this, this.logger), this.verify = new Ui2(this, this.logger, this.storage), this.echoClient = new Mi2(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Bi2(this, this.logger, e == null ? void 0 : e.telemetryEnabled), this.setGlobalCore(this);
  }
  static async init(e) {
    const t = new _Te(e);
    await t.initialize();
    const i3 = await t.crypto.getClientId();
    return await t.storage.setItem(jt2, i3), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(Fe2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Fe2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
  getGlobalCore(e = "") {
    try {
      if (this.isGlobalCoreDisabled()) return;
      const t = `_walletConnectCore_${e}`, i3 = `${t}_count`;
      return globalThis[i3] = (globalThis[i3] || 0) + 1, globalThis[i3] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i3]} times.`), globalThis[t];
    } catch (t) {
      console.warn("Failed to get global WalletConnect core", t);
      return;
    }
  }
  setGlobalCore(e) {
    var t;
    try {
      if (this.isGlobalCoreDisabled()) return;
      const i3 = `_walletConnectCore_${((t = e.opts) == null ? void 0 : t.customStoragePrefix) || ""}`;
      globalThis[i3] = e;
    } catch (i3) {
      console.warn("Failed to set global WalletConnect core", i3);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return true;
    }
  }
};
var Jo = Te;

// node_modules/@walletconnect/auth-client/dist/index.es.js
var import_events8 = __toESM(require_events());
var import_time4 = __toESM(require_cjs());
init_lib();
init_lib2();
var import_isomorphic_unfetch = __toESM(require_browser());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var G3 = class {
  constructor(t) {
    this.client = t;
  }
};
var H2 = class {
  constructor(t) {
    this.opts = t;
  }
};
var Y3 = "https://rpc.walletconnect.com/v1";
var R3 = { wc_authRequest: { req: { ttl: import_time4.ONE_DAY, prompt: true, tag: 3e3 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 3001 } } };
var U2 = { min: import_time4.FIVE_MINUTES, max: import_time4.SEVEN_DAYS };
var $2 = "wc";
var Q2 = 1;
var Z2 = "auth";
var B2 = "authClient";
var F3 = `${$2}@${1}:${Z2}:`;
var x2 = `${F3}:PUB_KEY`;
function z3(r3) {
  return r3 == null ? void 0 : r3.split(":");
}
function Ze3(r3) {
  const t = r3 && z3(r3);
  if (t) return t[3];
}
function We3(r3) {
  const t = r3 && z3(r3);
  if (t) return t[2] + ":" + t[3];
}
function W2(r3) {
  const t = r3 && z3(r3);
  if (t) return t.pop();
}
async function et2(r3, t, e, i3, n4) {
  switch (e.t) {
    case "eip191":
      return tt3(r3, t, e.s);
    case "eip1271":
      return await rt(r3, t, e.s, i3, n4);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e.t}`);
  }
}
function tt3(r3, t, e) {
  return recoverAddress(hashMessage(t), e).toLowerCase() === r3.toLowerCase();
}
async function rt(r3, t, e, i3, n4) {
  try {
    const s2 = "0x1626ba7e", o4 = "0000000000000000000000000000000000000000000000000000000000000040", u4 = "0000000000000000000000000000000000000000000000000000000000000041", a5 = e.substring(2), c7 = hashMessage(t).substring(2), h7 = s2 + c7 + o4 + u4 + a5, f6 = await (0, import_isomorphic_unfetch.default)(`${Y3}/?chainId=${i3}&projectId=${n4}`, { method: "POST", body: JSON.stringify({ id: it2(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r3, data: h7 }, "latest"] }) }), { result: p5 } = await f6.json();
    return p5 ? p5.slice(0, s2.length).toLowerCase() === s2.toLowerCase() : false;
  } catch (s2) {
    return console.error("isValidEip1271Signature: ", s2), false;
  }
}
function it2() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function ee3(r3) {
  return r3.getAll().filter((t) => "requester" in t);
}
function te3(r3, t) {
  return ee3(r3).find((e) => e.id === t);
}
function nt2(r3) {
  const t = ua(r3.aud), e = new RegExp(`${r3.domain}`).test(r3.aud), i3 = !!r3.nonce, n4 = r3.type ? r3.type === "eip4361" : true, s2 = r3.expiry;
  if (s2 && !Ba(s2, U2)) {
    const { message: o4 } = ht("MISSING_OR_INVALID", `request() expiry: ${s2}. Expiry must be a number (in seconds) between ${U2.min} and ${U2.max}`);
    throw new Error(o4);
  }
  return !!(t && e && i3 && n4);
}
function st2(r3, t) {
  return !!te3(t, r3.id);
}
function ot2(r3 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r3) : new Uint8Array(r3);
}
function ut2(r3, t) {
  if (r3.length >= 255) throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), i3 = 0; i3 < e.length; i3++) e[i3] = 255;
  for (var n4 = 0; n4 < r3.length; n4++) {
    var s2 = r3.charAt(n4), o4 = s2.charCodeAt(0);
    if (e[o4] !== 255) throw new TypeError(s2 + " is ambiguous");
    e[o4] = n4;
  }
  var u4 = r3.length, a5 = r3.charAt(0), c7 = Math.log(u4) / Math.log(256), h7 = Math.log(256) / Math.log(u4);
  function f6(D5) {
    if (D5 instanceof Uint8Array || (ArrayBuffer.isView(D5) ? D5 = new Uint8Array(D5.buffer, D5.byteOffset, D5.byteLength) : Array.isArray(D5) && (D5 = Uint8Array.from(D5))), !(D5 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (D5.length === 0) return "";
    for (var l7 = 0, m2 = 0, E6 = 0, y10 = D5.length; E6 !== y10 && D5[E6] === 0; ) E6++, l7++;
    for (var w6 = (y10 - E6) * h7 + 1 >>> 0, g4 = new Uint8Array(w6); E6 !== y10; ) {
      for (var C5 = D5[E6], _5 = 0, b6 = w6 - 1; (C5 !== 0 || _5 < m2) && b6 !== -1; b6--, _5++) C5 += 256 * g4[b6] >>> 0, g4[b6] = C5 % u4 >>> 0, C5 = C5 / u4 >>> 0;
      if (C5 !== 0) throw new Error("Non-zero carry");
      m2 = _5, E6++;
    }
    for (var v7 = w6 - m2; v7 !== w6 && g4[v7] === 0; ) v7++;
    for (var q4 = a5.repeat(l7); v7 < w6; ++v7) q4 += r3.charAt(g4[v7]);
    return q4;
  }
  function p5(D5) {
    if (typeof D5 != "string") throw new TypeError("Expected String");
    if (D5.length === 0) return new Uint8Array();
    var l7 = 0;
    if (D5[l7] !== " ") {
      for (var m2 = 0, E6 = 0; D5[l7] === a5; ) m2++, l7++;
      for (var y10 = (D5.length - l7) * c7 + 1 >>> 0, w6 = new Uint8Array(y10); D5[l7]; ) {
        var g4 = e[D5.charCodeAt(l7)];
        if (g4 === 255) return;
        for (var C5 = 0, _5 = y10 - 1; (g4 !== 0 || C5 < E6) && _5 !== -1; _5--, C5++) g4 += u4 * w6[_5] >>> 0, w6[_5] = g4 % 256 >>> 0, g4 = g4 / 256 >>> 0;
        if (g4 !== 0) throw new Error("Non-zero carry");
        E6 = C5, l7++;
      }
      if (D5[l7] !== " ") {
        for (var b6 = y10 - E6; b6 !== y10 && w6[b6] === 0; ) b6++;
        for (var v7 = new Uint8Array(m2 + (y10 - b6)), q4 = m2; b6 !== y10; ) v7[q4++] = w6[b6++];
        return v7;
      }
    }
  }
  function A5(D5) {
    var l7 = p5(D5);
    if (l7) return l7;
    throw new Error(`Non-${t} character`);
  }
  return { encode: f6, decodeUnsafe: p5, decode: A5 };
}
var at = ut2;
var Dt2 = at;
var re3 = (r3) => {
  if (r3 instanceof Uint8Array && r3.constructor.name === "Uint8Array") return r3;
  if (r3 instanceof ArrayBuffer) return new Uint8Array(r3);
  if (ArrayBuffer.isView(r3)) return new Uint8Array(r3.buffer, r3.byteOffset, r3.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ct = (r3) => new TextEncoder().encode(r3);
var ht2 = (r3) => new TextDecoder().decode(r3);
var lt2 = class {
  constructor(t, e, i3) {
    this.name = t, this.prefix = e, this.baseEncode = i3;
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var dt2 = class {
  constructor(t, e, i3) {
    if (this.name = t, this.prefix = e, e.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = e.codePointAt(0), this.baseDecode = i3;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ie2(this, t);
  }
};
var pt2 = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ie2(this, t);
  }
  decode(t) {
    const e = t[0], i3 = this.decoders[e];
    if (i3) return i3.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ie2 = (r3, t) => new pt2({ ...r3.decoders || { [r3.prefix]: r3 }, ...t.decoders || { [t.prefix]: t } });
var ft2 = class {
  constructor(t, e, i3, n4) {
    this.name = t, this.prefix = e, this.baseEncode = i3, this.baseDecode = n4, this.encoder = new lt2(t, e, i3), this.decoder = new dt2(t, e, n4);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
};
var O4 = ({ name: r3, prefix: t, encode: e, decode: i3 }) => new ft2(r3, t, e, i3);
var T = ({ prefix: r3, name: t, alphabet: e }) => {
  const { encode: i3, decode: n4 } = Dt2(e, t);
  return O4({ prefix: r3, name: t, encode: i3, decode: (s2) => re3(n4(s2)) });
};
var gt = (r3, t, e, i3) => {
  const n4 = {};
  for (let h7 = 0; h7 < t.length; ++h7) n4[t[h7]] = h7;
  let s2 = r3.length;
  for (; r3[s2 - 1] === "="; ) --s2;
  const o4 = new Uint8Array(s2 * e / 8 | 0);
  let u4 = 0, a5 = 0, c7 = 0;
  for (let h7 = 0; h7 < s2; ++h7) {
    const f6 = n4[r3[h7]];
    if (f6 === void 0) throw new SyntaxError(`Non-${i3} character`);
    a5 = a5 << e | f6, u4 += e, u4 >= 8 && (u4 -= 8, o4[c7++] = 255 & a5 >> u4);
  }
  if (u4 >= e || 255 & a5 << 8 - u4) throw new SyntaxError("Unexpected end of data");
  return o4;
};
var Et3 = (r3, t, e) => {
  const i3 = t[t.length - 1] === "=", n4 = (1 << e) - 1;
  let s2 = "", o4 = 0, u4 = 0;
  for (let a5 = 0; a5 < r3.length; ++a5) for (u4 = u4 << 8 | r3[a5], o4 += 8; o4 > e; ) o4 -= e, s2 += t[n4 & u4 >> o4];
  if (o4 && (s2 += t[n4 & u4 << e - o4]), i3) for (; s2.length * e & 7; ) s2 += "=";
  return s2;
};
var d3 = ({ name: r3, prefix: t, bitsPerChar: e, alphabet: i3 }) => O4({ prefix: t, name: r3, encode(n4) {
  return Et3(n4, i3, e);
}, decode(n4) {
  return gt(n4, i3, e, r3);
} });
var bt2 = O4({ prefix: "\0", name: "identity", encode: (r3) => ht2(r3), decode: (r3) => ct(r3) });
var yt = Object.freeze({ __proto__: null, identity: bt2 });
var wt2 = d3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ct3 = Object.freeze({ __proto__: null, base2: wt2 });
var mt2 = d3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vt = Object.freeze({ __proto__: null, base8: mt2 });
var At3 = T({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _t2 = Object.freeze({ __proto__: null, base10: At3 });
var xt3 = d3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Rt3 = d3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ft2 = Object.freeze({ __proto__: null, base16: xt3, base16upper: Rt3 });
var Tt3 = d3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var It2 = d3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var qt3 = d3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Ut2 = d3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ot3 = d3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var St3 = d3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Pt3 = d3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Nt3 = d3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var $t3 = d3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Bt3 = Object.freeze({ __proto__: null, base32: Tt3, base32upper: It2, base32pad: qt3, base32padupper: Ut2, base32hex: Ot3, base32hexupper: St3, base32hexpad: Pt3, base32hexpadupper: Nt3, base32z: $t3 });
var zt2 = T({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var jt3 = T({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Mt3 = Object.freeze({ __proto__: null, base36: zt2, base36upper: jt3 });
var Lt3 = T({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Kt3 = T({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Vt3 = Object.freeze({ __proto__: null, base58btc: Lt3, base58flickr: Kt3 });
var kt3 = d3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Jt3 = d3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Xt3 = d3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Gt3 = d3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ht3 = Object.freeze({ __proto__: null, base64: kt3, base64pad: Jt3, base64url: Xt3, base64urlpad: Gt3 });
var ne2 = Array.from("");
var Yt3 = ne2.reduce((r3, t, e) => (r3[e] = t, r3), []);
var Qt3 = ne2.reduce((r3, t, e) => (r3[t.codePointAt(0)] = e, r3), []);
function Zt2(r3) {
  return r3.reduce((t, e) => (t += Yt3[e], t), "");
}
function Wt3(r3) {
  const t = [];
  for (const e of r3) {
    const i3 = Qt3[e.codePointAt(0)];
    if (i3 === void 0) throw new Error(`Non-base256emoji character: ${e}`);
    t.push(i3);
  }
  return new Uint8Array(t);
}
var er2 = O4({ prefix: "", name: "base256emoji", encode: Zt2, decode: Wt3 });
var tr2 = Object.freeze({ __proto__: null, base256emoji: er2 });
var rr3 = oe;
var se2 = 128;
var ir = 127;
var nr3 = ~ir;
var sr2 = Math.pow(2, 31);
function oe(r3, t, e) {
  t = t || [], e = e || 0;
  for (var i3 = e; r3 >= sr2; ) t[e++] = r3 & 255 | se2, r3 /= 128;
  for (; r3 & nr3; ) t[e++] = r3 & 255 | se2, r3 >>>= 7;
  return t[e] = r3 | 0, oe.bytes = e - i3 + 1, t;
}
var or3 = j2;
var ur2 = 128;
var ue3 = 127;
function j2(r3, i3) {
  var e = 0, i3 = i3 || 0, n4 = 0, s2 = i3, o4, u4 = r3.length;
  do {
    if (s2 >= u4) throw j2.bytes = 0, new RangeError("Could not decode varint");
    o4 = r3[s2++], e += n4 < 28 ? (o4 & ue3) << n4 : (o4 & ue3) * Math.pow(2, n4), n4 += 7;
  } while (o4 >= ur2);
  return j2.bytes = s2 - i3, e;
}
var ar2 = Math.pow(2, 7);
var Dr3 = Math.pow(2, 14);
var cr2 = Math.pow(2, 21);
var hr2 = Math.pow(2, 28);
var lr2 = Math.pow(2, 35);
var dr2 = Math.pow(2, 42);
var pr2 = Math.pow(2, 49);
var fr2 = Math.pow(2, 56);
var gr2 = Math.pow(2, 63);
var Er2 = function(r3) {
  return r3 < ar2 ? 1 : r3 < Dr3 ? 2 : r3 < cr2 ? 3 : r3 < hr2 ? 4 : r3 < lr2 ? 5 : r3 < dr2 ? 6 : r3 < pr2 ? 7 : r3 < fr2 ? 8 : r3 < gr2 ? 9 : 10;
};
var br2 = { encode: rr3, decode: or3, encodingLength: Er2 };
var ae = br2;
var De = (r3, t, e = 0) => (ae.encode(r3, t, e), t);
var ce = (r3) => ae.encodingLength(r3);
var M3 = (r3, t) => {
  const e = t.byteLength, i3 = ce(r3), n4 = i3 + ce(e), s2 = new Uint8Array(n4 + e);
  return De(r3, s2, 0), De(e, s2, i3), s2.set(t, n4), new yr2(r3, e, t, s2);
};
var yr2 = class {
  constructor(t, e, i3, n4) {
    this.code = t, this.size = e, this.digest = i3, this.bytes = n4;
  }
};
var he3 = ({ name: r3, code: t, encode: e }) => new wr2(r3, t, e);
var wr2 = class {
  constructor(t, e, i3) {
    this.name = t, this.code = e, this.encode = i3;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const e = this.encode(t);
      return e instanceof Uint8Array ? M3(this.code, e) : e.then((i3) => M3(this.code, i3));
    } else throw Error("Unknown type, must be binary type");
  }
};
var le2 = (r3) => async (t) => new Uint8Array(await crypto.subtle.digest(r3, t));
var Cr3 = he3({ name: "sha2-256", code: 18, encode: le2("SHA-256") });
var mr2 = he3({ name: "sha2-512", code: 19, encode: le2("SHA-512") });
var vr2 = Object.freeze({ __proto__: null, sha256: Cr3, sha512: mr2 });
var de2 = 0;
var Ar3 = "identity";
var pe3 = re3;
var _r3 = (r3) => M3(de2, pe3(r3));
var xr2 = { code: de2, name: Ar3, encode: pe3, digest: _r3 };
var Rr3 = Object.freeze({ __proto__: null, identity: xr2 });
new TextEncoder(), new TextDecoder();
var fe2 = { ...yt, ...Ct3, ...vt, ..._t2, ...Ft2, ...Bt3, ...Mt3, ...Vt3, ...Ht3, ...tr2 };
({ ...vr2, ...Rr3 });
function ge3(r3, t, e, i3) {
  return { name: r3, prefix: t, encoder: { name: r3, prefix: t, encode: e }, decoder: { decode: i3 } };
}
var Ee3 = ge3("utf8", "u", (r3) => "u" + new TextDecoder("utf8").decode(r3), (r3) => new TextEncoder().encode(r3.substring(1)));
var L2 = ge3("ascii", "a", (r3) => {
  let t = "a";
  for (let e = 0; e < r3.length; e++) t += String.fromCharCode(r3[e]);
  return t;
}, (r3) => {
  r3 = r3.substring(1);
  const t = ot2(r3.length);
  for (let e = 0; e < r3.length; e++) t[e] = r3.charCodeAt(e);
  return t;
});
var be3 = { utf8: Ee3, "utf-8": Ee3, hex: fe2.base16, latin1: L2, ascii: L2, binary: L2, ...fe2 };
function Fr3(r3, t = "utf8") {
  const e = be3[t];
  if (!e) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r3, "utf8") : e.decoder.decode(`${e.prefix}${r3}`);
}
function Tr3(r3, t = "utf8") {
  const e = be3[t];
  if (!e) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r3.buffer, r3.byteOffset, r3.byteLength).toString("utf8") : e.encoder.encode(r3).substring(1);
}
var ye3 = "base16";
var we2 = "utf8";
function K3(r3) {
  const t = (0, import_sha256.hash)(Fr3(r3, we2));
  return Tr3(t, ye3);
}
var Or3 = Object.defineProperty;
var Sr3 = Object.defineProperties;
var Pr3 = Object.getOwnPropertyDescriptors;
var Ce3 = Object.getOwnPropertySymbols;
var Nr3 = Object.prototype.hasOwnProperty;
var $r3 = Object.prototype.propertyIsEnumerable;
var me2 = (r3, t, e) => t in r3 ? Or3(r3, t, { enumerable: true, configurable: true, writable: true, value: e }) : r3[t] = e;
var I2 = (r3, t) => {
  for (var e in t || (t = {})) Nr3.call(t, e) && me2(r3, e, t[e]);
  if (Ce3) for (var e of Ce3(t)) $r3.call(t, e) && me2(r3, e, t[e]);
  return r3;
};
var V3 = (r3, t) => Sr3(r3, Pr3(t));
var Br4 = class extends G3 {
  constructor(t) {
    super(t), this.initialized = false, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(R3) }), this.initialized = true);
    }, this.request = async (e, i3) => {
      if (this.isInitialized(), !nt2(e)) throw new Error("Invalid request");
      if (i3 != null && i3.topic) return await this.requestOnKnownPairing(i3.topic, e);
      const { chainId: n4, statement: s2, aud: o4, domain: u4, nonce: a5, type: c7, exp: h7, nbf: f6 } = e, { topic: p5, uri: A5 } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: p5, uri: A5 } });
      const D5 = await this.client.core.crypto.generateKeyPair(), l7 = Pc(D5);
      await this.client.authKeys.set(x2, { responseTopic: l7, publicKey: D5 }), await this.client.pairingTopics.set(l7, { topic: l7, pairingTopic: p5 }), await this.client.core.relayer.subscribe(l7), this.client.logger.info(`sending request to new pairing topic: ${p5}`);
      const m2 = await this.sendRequest(p5, "wc_authRequest", { payloadParams: { type: c7 ?? "eip4361", chainId: n4, statement: s2, aud: o4, domain: u4, version: "1", nonce: a5, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: h7, nbf: f6 }, requester: { publicKey: D5, metadata: this.client.metadata } }, {}, e.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${p5}`), { uri: A5, id: m2 };
    }, this.respond = async (e, i3) => {
      if (this.isInitialized(), !st2(e, this.client.requests)) throw new Error("Invalid response");
      const n4 = te3(this.client.requests, e.id);
      if (!n4) throw new Error(`Could not find pending auth request with id ${e.id}`);
      const s2 = n4.requester.publicKey, o4 = await this.client.core.crypto.generateKeyPair(), u4 = Pc(s2), a5 = { type: Kt, receiverPublicKey: s2, senderPublicKey: o4 };
      if ("error" in e) {
        await this.sendError(n4.id, u4, e, a5);
        return;
      }
      const c7 = { h: { t: "eip4361" }, p: V3(I2({}, n4.cacaoPayload), { iss: i3 }), s: e.signature };
      await this.sendResult(n4.id, u4, c7, a5), await this.client.core.pairing.activate({ topic: n4.pairingTopic }), await this.client.requests.update(n4.id, I2({}, c7));
    }, this.getPendingRequests = () => ee3(this.client.requests), this.formatMessage = (e, i3) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e)}`);
      const n4 = `${e.domain} wants you to sign in with your Ethereum account:`, s2 = W2(i3), o4 = e.statement, u4 = `URI: ${e.aud}`, a5 = `Version: ${e.version}`, c7 = `Chain ID: ${Ze3(i3)}`, h7 = `Nonce: ${e.nonce}`, f6 = `Issued At: ${e.iat}`, p5 = e.exp ? `Expiry: ${e.exp}` : void 0, A5 = e.resources && e.resources.length > 0 ? `Resources:
${e.resources.map((D5) => `- ${D5}`).join(`
`)}` : void 0;
      return [n4, s2, "", o4, "", u4, a5, c7, h7, f6, p5, A5].filter((D5) => D5 != null).join(`
`);
    }, this.setExpiry = async (e, i3) => {
      this.client.core.pairing.pairings.keys.includes(e) && await this.client.core.pairing.updateExpiry({ topic: e, expiry: i3 }), this.client.core.expirer.set(e, i3);
    }, this.sendRequest = async (e, i3, n4, s2, o4) => {
      const u4 = formatJsonRpcRequest(i3, n4), a5 = await this.client.core.crypto.encode(e, u4, s2), c7 = R3[i3].req;
      if (o4 && (c7.ttl = o4), this.client.core.history.set(e, u4), Yt()) {
        const h7 = K3(JSON.stringify(u4));
        this.client.core.verify.register({ attestationId: h7 });
      }
      return await this.client.core.relayer.publish(e, a5, V3(I2({}, c7), { internal: { throwOnFailedPublish: true } })), u4.id;
    }, this.sendResult = async (e, i3, n4, s2) => {
      const o4 = formatJsonRpcResult(e, n4), u4 = await this.client.core.crypto.encode(i3, o4, s2), a5 = await this.client.core.history.get(i3, e), c7 = R3[a5.request.method].res;
      return await this.client.core.relayer.publish(i3, u4, V3(I2({}, c7), { internal: { throwOnFailedPublish: true } })), await this.client.core.history.resolve(o4), o4.id;
    }, this.sendError = async (e, i3, n4, s2) => {
      const o4 = formatJsonRpcError(e, n4.error), u4 = await this.client.core.crypto.encode(i3, o4, s2), a5 = await this.client.core.history.get(i3, e), c7 = R3[a5.request.method].res;
      return await this.client.core.relayer.publish(i3, u4, c7), await this.client.core.history.resolve(o4), o4.id;
    }, this.requestOnKnownPairing = async (e, i3) => {
      const n4 = this.client.core.pairing.pairings.getAll({ active: true }).find((A5) => A5.topic === e);
      if (!n4) throw new Error(`Could not find pairing for provided topic ${e}`);
      const { publicKey: s2 } = this.client.authKeys.get(x2), { chainId: o4, statement: u4, aud: a5, domain: c7, nonce: h7, type: f6 } = i3, p5 = await this.sendRequest(n4.topic, "wc_authRequest", { payloadParams: { type: f6 ?? "eip4361", chainId: o4, statement: u4, aud: a5, domain: c7, version: "1", nonce: h7, iat: (/* @__PURE__ */ new Date()).toISOString() }, requester: { publicKey: s2, metadata: this.client.metadata } }, {}, i3.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${n4.topic}`), { id: p5 };
    }, this.onPairingCreated = (e) => {
      const i3 = this.getPendingRequests();
      if (i3) {
        const n4 = Object.values(i3).find((s2) => s2.pairingTopic === e.topic);
        n4 && this.handleAuthRequest(n4);
      }
    }, this.onRelayEventRequest = (e) => {
      const { topic: i3, payload: n4 } = e, s2 = n4.method;
      switch (s2) {
        case "wc_authRequest":
          return this.onAuthRequest(i3, n4);
        default:
          return this.client.logger.info(`Unsupported request method ${s2}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: i3, payload: n4 } = e, s2 = (await this.client.core.history.get(i3, n4.id)).request.method;
      switch (s2) {
        case "wc_authRequest":
          return this.onAuthResponse(i3, n4);
        default:
          return this.client.logger.info(`Unsupported response method ${s2}`);
      }
    }, this.onAuthRequest = async (e, i3) => {
      const { requester: n4, payloadParams: s2 } = i3.params;
      this.client.logger.info({ type: "onAuthRequest", topic: e, payload: i3 });
      const o4 = K3(JSON.stringify(i3)), u4 = await this.getVerifyContext(o4, this.client.metadata), a5 = { requester: n4, pairingTopic: e, id: i3.id, cacaoPayload: s2, verifyContext: u4 };
      await this.client.requests.set(i3.id, a5), this.handleAuthRequest(a5);
    }, this.handleAuthRequest = async (e) => {
      const { id: i3, pairingTopic: n4, requester: s2, cacaoPayload: o4, verifyContext: u4 } = e;
      try {
        this.client.emit("auth_request", { id: i3, topic: n4, params: { requester: s2, cacaoPayload: o4 }, verifyContext: u4 });
      } catch (a5) {
        await this.sendError(e.id, e.pairingTopic, a5), this.client.logger.error(a5);
      }
    }, this.onAuthResponse = async (e, i3) => {
      const { id: n4 } = i3;
      if (this.client.logger.info({ type: "onAuthResponse", topic: e, response: i3 }), isJsonRpcResult(i3)) {
        const { pairingTopic: s2 } = this.client.pairingTopics.get(e);
        await this.client.core.pairing.activate({ topic: s2 });
        const { s: o4, p: u4 } = i3.result;
        await this.client.requests.set(n4, I2({ id: n4, pairingTopic: s2 }, i3.result));
        const a5 = this.formatMessage(u4, u4.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(a5)), this.client.logger.debug("payload.iss:", u4.iss), this.client.logger.debug("signature:", o4);
        const c7 = W2(u4.iss), h7 = We3(u4.iss);
        if (!c7) throw new Error("Could not derive address from `payload.iss`");
        if (!h7) throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", c7), await et2(c7, a5, o4, h7, this.client.projectId) ? this.client.emit("auth_response", { id: n4, topic: e, params: i3 }) : this.client.emit("auth_response", { id: n4, topic: e, params: { message: "Invalid signature", code: -1 } });
      } else isJsonRpcError(i3) && this.client.emit("auth_response", { id: n4, topic: e, params: i3 });
    }, this.getVerifyContext = async (e, i3) => {
      const n4 = { verified: { verifyUrl: i3.verifyUrl || "", validation: "UNKNOWN", origin: i3.url || "" } };
      try {
        const s2 = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: i3.verifyUrl });
        s2 && (n4.verified.origin = s2.origin, n4.verified.isScam = s2.isScam, n4.verified.validation = origin === new URL(i3.url).origin ? "VALID" : "INVALID");
      } catch (s2) {
        this.client.logger.error(s2);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(n4)}`), n4;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = ht("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(C2.message, async (t) => {
      const { topic: e, message: i3 } = t, { responseTopic: n4, publicKey: s2 } = this.client.authKeys.keys.includes(x2) ? this.client.authKeys.get(x2) : { responseTopic: void 0, publicKey: void 0 };
      if (n4 && e !== n4) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", e);
        return;
      }
      const o4 = await this.client.core.crypto.decode(e, i3, { receiverPublicKey: s2 });
      isJsonRpcRequest(o4) ? (this.client.core.history.set(e, o4), this.onRelayEventRequest({ topic: e, payload: o4 })) : isJsonRpcResponse(o4) && (await this.client.core.history.resolve(o4), this.onRelayEventResponse({ topic: e, payload: o4 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(se.create, (t) => this.onPairingCreated(t));
  }
};
var S3 = class _S extends H2 {
  constructor(t) {
    super(t), this.protocol = $2, this.version = Q2, this.name = B2, this.events = new import_events8.EventEmitter(), this.emit = (i3, n4) => this.events.emit(i3, n4), this.on = (i3, n4) => this.events.on(i3, n4), this.once = (i3, n4) => this.events.once(i3, n4), this.off = (i3, n4) => this.events.off(i3, n4), this.removeListener = (i3, n4) => this.events.removeListener(i3, n4), this.request = async (i3, n4) => {
      try {
        return await this.engine.request(i3, n4);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.respond = async (i3, n4) => {
      try {
        return await this.engine.respond(i3, n4);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.formatMessage = (i3, n4) => {
      try {
        return this.engine.formatMessage(i3, n4);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    };
    const e = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : (0, import_pino.default)(k({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || B2, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new Jo(t), this.logger = E(e, this.name), this.authKeys = new zi2(this.core, this.logger, "authKeys", F3, () => x2), this.pairingTopics = new zi2(this.core, this.logger, "pairingTopics", F3), this.requests = new zi2(this.core, this.logger, "requests", F3, (i3) => i3.id), this.engine = new Br4(this);
  }
  static async init(t) {
    const e = new _S(t);
    return await e.initialize(), e;
  }
  get context() {
    return y(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var zr3 = S3;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_events12 = __toESM(require_events());

// node_modules/@walletconnect/web3wallet/node_modules/unstorage/dist/shared/unstorage.mNKHTF5Y.mjs
function wrapToPromise2(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall2(function_, ...arguments_) {
  try {
    return wrapToPromise2(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive2(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject2(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify2(value) {
  if (isPrimitive2(value)) {
    return String(value);
  }
  if (isPureObject2(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify2(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX2 = "base64:";
function serializeRaw2(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX2 + base64Encode2(value);
}
function deserializeRaw2(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX2)) {
    return value;
  }
  return base64Decode2(value.slice(BASE64_PREFIX2.length));
}
function base64Decode2(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c7) => c7.codePointAt(0)
  );
}
function base64Encode2(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey2(key) {
  var _a2;
  if (!key) {
    return "";
  }
  return ((_a2 = key.split("?")[0]) == null ? void 0 : _a2.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys2(...keys2) {
  return normalizeKey2(keys2.join(":"));
}
function normalizeBaseKey2(base2) {
  base2 = normalizeKey2(base2);
  return base2 ? base2 + ":" : "";
}
function filterKeyByDepth2(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase2(key, base2) {
  if (base2) {
    return key.startsWith(base2) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

// node_modules/@walletconnect/web3wallet/node_modules/unstorage/dist/index.mjs
function defineDriver2(factory) {
  return factory;
}
var DRIVER_NAME2 = "memory";
var memory2 = defineDriver2(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME2,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage2(options = {}) {
  const context = {
    mounts: { "": options.driver || memory2() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base2 of context.mountpoints) {
      if (key.startsWith(base2)) {
        return {
          base: base2,
          relativeKey: key.slice(base2.length),
          driver: context.mounts[base2]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base2, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base2) || includeParent && base2.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base2.length > mountpoint.length ? base2.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey2(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch2(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey2(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r3) => r3.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall2(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall2(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall2(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r3) => r3.map((item) => ({
              key: joinKeys2(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall2(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall2(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall2(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw2(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall2(driver.setItem, relativeKey, stringify2(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall2(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify2(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall2(
              batch.driver.setItem,
              item.relativeKey,
              stringify2(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall2(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall2(driver.setItem, relativeKey, serializeRaw2(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall2(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall2(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall2(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall2(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base2, opts = {}) {
      var _a2;
      base2 = normalizeBaseKey2(base2);
      const mounts = getMounts(base2, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a2 = mount.driver.flags) == null ? void 0 : _a2.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall2(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey2(key);
          if (!maskedMounts.some((p5) => fullKey.startsWith(p5))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p5) => !p5.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth2(key, opts.maxDepth)) && filterKeyByBase2(key, base2)
      );
    },
    // Utils
    async clear(base2, opts = {}) {
      base2 = normalizeBaseKey2(base2);
      await Promise.all(
        getMounts(base2, false).map(async (m2) => {
          if (m2.driver.clear) {
            return asyncCall2(m2.driver.clear, m2.relativeBase, opts);
          }
          if (m2.driver.removeItem) {
            const keys2 = await m2.driver.getKeys(m2.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m2.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose2(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base2, driver) {
      base2 = normalizeBaseKey2(base2);
      if (base2 && context.mounts[base2]) {
        throw new Error(`already mounted at ${base2}`);
      }
      if (base2) {
        context.mountpoints.push(base2);
        context.mountpoints.sort((a5, b6) => b6.length - a5.length);
      }
      context.mounts[base2] = driver;
      if (context.watching) {
        Promise.resolve(watch2(driver, onChange, base2)).then((unwatcher) => {
          context.unwatch[base2] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base2, _dispose = true) {
      var _a2, _b;
      base2 = normalizeBaseKey2(base2);
      if (!base2 || !context.mounts[base2]) {
        return;
      }
      if (context.watching && base2 in context.unwatch) {
        (_b = (_a2 = context.unwatch)[base2]) == null ? void 0 : _b.call(_a2);
        delete context.unwatch[base2];
      }
      if (_dispose) {
        await dispose2(context.mounts[base2]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base2);
      delete context.mounts[base2];
    },
    getMount(key = "") {
      key = normalizeKey2(key) + ":";
      const m2 = getMount(key);
      return {
        driver: m2.driver,
        base: m2.base
      };
    },
    getMounts(base2 = "", opts = {}) {
      base2 = normalizeKey2(base2);
      const mounts = getMounts(base2, opts.parents);
      return mounts.map((m2) => ({
        driver: m2.driver,
        base: m2.mountpoint
      }));
    },
    // Aliases
    keys: (base2, opts = {}) => storage.getKeys(base2, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch2(driver, onChange, base2) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base2 + key)) : () => {
  };
}
async function dispose2(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall2(driver.dispose);
  }
}

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x3 = "idb-keyval";
var z4 = (i3 = {}) => {
  const t = i3.base && i3.base.length > 0 ? `${i3.base}:` : "", e = (s2) => t + s2;
  let n4;
  return i3.dbName && i3.storeName && (n4 = createStore(i3.dbName, i3.storeName)), { name: x3, options: i3, async hasItem(s2) {
    return !(typeof await get(e(s2), n4) > "u");
  }, async getItem(s2) {
    return await get(e(s2), n4) ?? null;
  }, setItem(s2, a5) {
    return set(e(s2), a5, n4);
  }, removeItem(s2) {
    return del(e(s2), n4);
  }, getKeys() {
    return keys(n4);
  }, clear() {
    return clear(n4);
  } };
};
var D2 = "WALLET_CONNECT_V2_INDEXED_DB";
var E4 = "keyvaluestorage";
var _2 = class {
  constructor() {
    this.indexedDb = createStorage2({ driver: z4({ dbName: D2, storeName: E4 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e = await this.indexedDb.getItem(t);
    if (e !== null) return e;
  }
  async setItem(t, e) {
    await this.indexedDb.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l5 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c4 = { exports: {} };
(function() {
  let i3;
  function t() {
  }
  i3 = t, i3.prototype.getItem = function(e) {
    return this.hasOwnProperty(e) ? String(this[e]) : null;
  }, i3.prototype.setItem = function(e, n4) {
    this[e] = String(n4);
  }, i3.prototype.removeItem = function(e) {
    delete this[e];
  }, i3.prototype.clear = function() {
    const e = this;
    Object.keys(e).forEach(function(n4) {
      e[n4] = void 0, delete e[n4];
    });
  }, i3.prototype.key = function(e) {
    return e = e || 0, Object.keys(this)[e];
  }, i3.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l5 < "u" && l5.localStorage ? c4.exports = l5.localStorage : typeof window < "u" && window.localStorage ? c4.exports = window.localStorage : c4.exports = new t();
})();
function k4(i3) {
  var t;
  return [i3[0], safeJsonParse((t = i3[1]) != null ? t : "")];
}
var K4 = class {
  constructor() {
    this.localStorage = c4.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k4);
  }
  async getItem(t) {
    const e = this.localStorage.getItem(t);
    if (e !== null) return safeJsonParse(e);
  }
  async setItem(t, e) {
    this.localStorage.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N3 = "wc_storage_version";
var y5 = 1;
var O5 = async (i3, t, e) => {
  const n4 = N3, s2 = await t.getItem(n4);
  if (s2 && s2 >= y5) {
    e(t);
    return;
  }
  const a5 = await i3.getKeys();
  if (!a5.length) {
    e(t);
    return;
  }
  const m2 = [];
  for (; a5.length; ) {
    const r3 = a5.shift();
    if (!r3) continue;
    const o4 = r3.toLowerCase();
    if (o4.includes("wc@") || o4.includes("walletconnect") || o4.includes("wc_") || o4.includes("wallet_connect")) {
      const f6 = await i3.getItem(r3);
      await t.setItem(r3, f6), m2.push(r3);
    }
  }
  await t.setItem(n4, y5), e(t), j3(i3, m2);
};
var j3 = async (i3, t) => {
  t.length && t.forEach(async (e) => {
    await i3.removeItem(e);
  });
};
var h4 = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e) => {
      this.storage = e, this.initialized = true;
    };
    const t = new K4();
    this.storage = t;
    try {
      const e = new _2();
      O5(t, e, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e) {
    return await this.initialize(), this.storage.setItem(t, e);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e = setInterval(() => {
        this.initialized && (clearInterval(e), t());
      }, 20);
    });
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/types/dist/index.es.js
init_esm();
var import_events10 = __toESM(require_events());
var n3 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var h5 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a3 = class {
  constructor(s2, t) {
    this.logger = s2, this.core = t;
  }
};
var g2 = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var u2 = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var p3 = class {
  constructor(s2, t, e, f6) {
    this.core = s2, this.logger = t, this.name = e;
  }
};
var d4 = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var x4 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t;
  }
};
var y6 = class {
  constructor(s2, t, e) {
    this.core = s2, this.logger = t, this.store = e;
  }
};
var v4 = class {
  constructor(s2, t) {
    this.projectId = s2, this.logger = t;
  }
};
var C3 = class {
  constructor(s2, t, e) {
    this.core = s2, this.logger = t, this.telemetryEnabled = e;
  }
};
var S4 = class {
  constructor(s2) {
    this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var M4 = class {
  constructor(s2) {
    this.client = s2;
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_time7 = __toESM(require_cjs());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/relay-auth/dist/esm/api.js
var ed25519 = __toESM(require_ed25519());
var import_random2 = __toESM(require_random());
var import_time5 = __toESM(require_cjs());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/relay-auth/dist/esm/constants.js
var JWT_IRIDIUM_ALG = "EdDSA";
var JWT_IRIDIUM_TYP = "JWT";
var JWT_DELIMITER = ".";
var JWT_ENCODING = "base64url";
var JSON_ENCODING = "utf8";
var DATA_ENCODING = "utf8";
var DID_DELIMITER = ":";
var DID_PREFIX = "did";
var DID_METHOD = "key";
var MULTICODEC_ED25519_ENCODING = "base58btc";
var MULTICODEC_ED25519_BASE = "z";
var MULTICODEC_ED25519_HEADER = "K36";
var KEY_PAIR_SEED_LENGTH = 32;

// node_modules/@walletconnect/web3wallet/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe3(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return globalThis.Buffer.allocUnsafe(size);
  }
  return new Uint8Array(size);
}

// node_modules/@walletconnect/web3wallet/node_modules/uint8arrays/esm/src/concat.js
function concat3(arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe3(length);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return output;
}

// node_modules/@walletconnect/web3wallet/node_modules/uint8arrays/esm/src/util/bases.js
init_basics();
function createCodec3(name, prefix, encode, decode) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode
    },
    decoder: { decode }
  };
}
var string3 = createCodec3("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii3 = createCodec3("ascii", "a", (buf) => {
  let string4 = "a";
  for (let i3 = 0; i3 < buf.length; i3++) {
    string4 += String.fromCharCode(buf[i3]);
  }
  return string4;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe3(str.length);
  for (let i3 = 0; i3 < str.length; i3++) {
    buf[i3] = str.charCodeAt(i3);
  }
  return buf;
});
var BASES3 = {
  utf8: string3,
  "utf-8": string3,
  hex: bases.base16,
  latin1: ascii3,
  ascii: ascii3,
  binary: ascii3,
  ...bases
};
var bases_default3 = BASES3;

// node_modules/@walletconnect/web3wallet/node_modules/uint8arrays/esm/src/to-string.js
function toString3(array, encoding = "utf8") {
  const base2 = bases_default3[encoding];
  if (!base2) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base2.encoder.encode(array).substring(1);
}

// node_modules/@walletconnect/web3wallet/node_modules/uint8arrays/esm/src/from-string.js
function fromString3(string4, encoding = "utf8") {
  const base2 = bases_default3[encoding];
  if (!base2) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(string4, "utf8");
  }
  return base2.decoder.decode(`${base2.prefix}${string4}`);
}

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/relay-auth/dist/esm/utils.js
function decodeJSON(str) {
  return safeJsonParse(toString3(fromString3(str, JWT_ENCODING), JSON_ENCODING));
}
function encodeJSON(val) {
  return toString3(fromString3(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(publicKey) {
  const header = fromString3(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);
  const multicodec = MULTICODEC_ED25519_BASE + toString3(concat3([header, publicKey]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);
}
function encodeSig(bytes) {
  return toString3(bytes, JWT_ENCODING);
}
function decodeSig(encoded) {
  return fromString3(encoded, JWT_ENCODING);
}
function encodeData(params) {
  return fromString3([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function encodeJWT(params) {
  return [
    encodeJSON(params.header),
    encodeJSON(params.payload),
    encodeSig(params.signature)
  ].join(JWT_DELIMITER);
}
function decodeJWT(jwt) {
  const params = jwt.split(JWT_DELIMITER);
  const header = decodeJSON(params[0]);
  const payload = decodeJSON(params[1]);
  const signature = decodeSig(params[2]);
  const data = fromString3(params.slice(0, 2).join(JWT_DELIMITER), DATA_ENCODING);
  return { header, payload, signature, data };
}

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/relay-auth/dist/esm/api.js
function generateKeyPair(seed = (0, import_random2.randomBytes)(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(seed);
}
async function signJWT(sub, aud, ttl, keyPair, iat = (0, import_time5.fromMiliseconds)(Date.now())) {
  const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };
  const iss = encodeIss(keyPair.publicKey);
  const exp = iat + ttl;
  const payload = { iss, sub, aud, iat, exp };
  const data = encodeData({ header, payload });
  const signature = ed25519.sign(keyPair.secretKey, data);
  return encodeJWT({ header, payload, signature });
}

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/utils/dist/index.es.js
var import_time6 = __toESM(require_cjs());
var import_window_getters3 = __toESM(require_cjs2());
var import_window_metadata2 = __toESM(require_cjs3());
var Br5 = __toESM(require_query_string());
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random3 = __toESM(require_random());
var import_sha2562 = __toESM(require_sha256());
var mn2 = __toESM(require_x25519());
var import_elliptic = __toESM(require_elliptic());
var Rr4 = ":";
function An2(e) {
  const [t, r3] = e.split(Rr4);
  return { namespace: t, reference: r3 };
}
function Or4(e, t) {
  return e.includes(":") ? [e] : t.chains || [];
}
var Zo = Object.defineProperty;
var En3 = Object.getOwnPropertySymbols;
var ts = Object.prototype.hasOwnProperty;
var es = Object.prototype.propertyIsEnumerable;
var Sn3 = (e, t, r3) => t in e ? Zo(e, t, { enumerable: true, configurable: true, writable: true, value: r3 }) : e[t] = r3;
var In2 = (e, t) => {
  for (var r3 in t || (t = {})) ts.call(t, r3) && Sn3(e, r3, t[r3]);
  if (En3) for (var r3 of En3(t)) es.call(t, r3) && Sn3(e, r3, t[r3]);
  return e;
};
var Nn2 = "ReactNative";
var qt4 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var Bn2 = "js";
function bi3() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function rr4() {
  return !(0, import_window_getters3.getDocument)() && !!(0, import_window_getters3.getNavigator)() && navigator.product === Nn2;
}
function gr3() {
  return !bi3() && !!(0, import_window_getters3.getNavigator)() && !!(0, import_window_getters3.getDocument)();
}
function We4() {
  return rr4() ? qt4.reactNative : bi3() ? qt4.node : gr3() ? qt4.browser : qt4.unknown;
}
function ns() {
  var e;
  try {
    return rr4() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
  } catch {
    return;
  }
}
function Cn3(e, t) {
  let r3 = Br5.parse(e);
  return r3 = In2(In2({}, r3), t), e = Br5.stringify(r3), e;
}
function fs() {
  return (0, import_window_metadata2.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function Rn2() {
  if (We4() === qt4.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: r3, Version: i3 } = global.Platform;
    return [r3, i3].join("-");
  }
  const e = detect();
  if (e === null) return "unknown";
  const t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [t, e.name, e.version].join("-") : [t, e.version].join("-");
}
function On3() {
  var e;
  const t = We4();
  return t === qt4.browser ? [t, ((e = (0, import_window_getters3.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : t;
}
function Pn3(e, t, r3) {
  const i3 = Rn2(), n4 = On3();
  return [[e, t].join("-"), [Bn2, r3].join("-"), i3, n4].join("/");
}
function ss({ protocol: e, version: t, relayUrl: r3, sdkVersion: i3, auth: n4, projectId: o4, useOnCloseEvent: h7, bundleId: p5 }) {
  const A5 = r3.split("?"), v7 = Pn3(e, t, i3), w6 = { auth: n4, ua: v7, projectId: o4, useOnCloseEvent: h7 || void 0, origin: p5 || void 0 }, y10 = Cn3(A5[1] || "", w6);
  return A5[0] + "?" + y10;
}
function _e3(e, t) {
  return e.filter((r3) => t.includes(r3)).length === e.length;
}
function cs2(e) {
  return Object.fromEntries(e.entries());
}
function ls(e) {
  return new Map(Object.entries(e));
}
function gs2(e = import_time6.FIVE_MINUTES, t) {
  const r3 = (0, import_time6.toMiliseconds)(e || import_time6.FIVE_MINUTES);
  let i3, n4, o4;
  return { resolve: (h7) => {
    o4 && i3 && (clearTimeout(o4), i3(h7));
  }, reject: (h7) => {
    o4 && n4 && (clearTimeout(o4), n4(h7));
  }, done: () => new Promise((h7, p5) => {
    o4 = setTimeout(() => {
      p5(new Error(t));
    }, r3), i3 = h7, n4 = p5;
  }) };
}
function ms2(e, t, r3) {
  return new Promise(async (i3, n4) => {
    const o4 = setTimeout(() => n4(new Error(r3)), t);
    try {
      const h7 = await e;
      i3(h7);
    } catch (h7) {
      n4(h7);
    }
    clearTimeout(o4);
  });
}
function yi3(e, t) {
  if (typeof t == "string" && t.startsWith(`${e}:`)) return t;
  if (e.toLowerCase() === "topic") {
    if (typeof t != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof t != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function As2(e) {
  return yi3("topic", e);
}
function bs2(e) {
  return yi3("id", e);
}
function ys2(e) {
  const [t, r3] = e.split(":"), i3 = { id: void 0, topic: void 0 };
  if (t === "topic" && typeof r3 == "string") i3.topic = r3;
  else if (t === "id" && Number.isInteger(Number(r3))) i3.id = Number(r3);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${r3}`);
  return i3;
}
function ws2(e, t) {
  return (0, import_time6.fromMiliseconds)((t || Date.now()) + (0, import_time6.toMiliseconds)(e));
}
function xs2(e) {
  return Date.now() >= (0, import_time6.toMiliseconds)(e);
}
function Ms2(e, t) {
  return `${e}${t ? `:${t}` : ""}`;
}
function me3(e = [], t = []) {
  return [.../* @__PURE__ */ new Set([...e, ...t])];
}
async function Es2({ id: e, topic: t, wcDeepLink: r3 }) {
  var i3;
  try {
    if (!r3) return;
    const n4 = typeof r3 == "string" ? JSON.parse(r3) : r3, o4 = n4 == null ? void 0 : n4.href;
    if (typeof o4 != "string") return;
    const h7 = Un2(o4, e, t), p5 = We4();
    if (p5 === qt4.browser) {
      if (!((i3 = (0, import_window_getters3.getDocument)()) != null && i3.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      h7.startsWith("https://") || h7.startsWith("http://") ? window.open(h7, "_blank", "noreferrer noopener") : window.open(h7, kn3() ? "_blank" : "_self", "noreferrer noopener");
    } else p5 === qt4.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(h7);
  } catch (n4) {
    console.error(n4);
  }
}
function Un2(e, t, r3) {
  const i3 = `requestId=${t}&sessionTopic=${r3}`;
  e.endsWith("/") && (e = e.slice(0, -1));
  let n4 = `${e}`;
  if (e.startsWith("https://t.me")) {
    const o4 = e.includes("?") ? "&startapp=" : "?startapp=";
    n4 = `${n4}${o4}${qn2(i3, true)}`;
  } else n4 = `${n4}/wc?${i3}`;
  return n4;
}
async function Ss2(e, t) {
  let r3 = "";
  try {
    if (gr3() && (r3 = localStorage.getItem(t), r3)) return r3;
    r3 = await e.getItem(t);
  } catch (i3) {
    console.error(i3);
  }
  return r3;
}
function Is2(e, t) {
  if (!e.includes(t)) return null;
  const r3 = e.split(/([&,?,=])/), i3 = r3.indexOf(t);
  return r3[i3 + 2];
}
function Ns2() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
    const t = Math.random() * 16 | 0;
    return (e === "x" ? t : t & 3 | 8).toString(16);
  });
}
function _s2() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function kn3() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function qn2(e, t = false) {
  const r3 = Buffer.from(e).toString("base64");
  return t ? r3.replace(/[=]/g, "") : r3;
}
function xi3(e) {
  return Buffer.from(e, "base64").toString("utf-8");
}
var Kn2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Bs2(e) {
  var t = e.default;
  if (typeof t == "function") {
    var r3 = function() {
      return t.apply(this, arguments);
    };
    r3.prototype = t.prototype;
  } else r3 = {};
  return Object.defineProperty(r3, "__esModule", { value: true }), Object.keys(e).forEach(function(i3) {
    var n4 = Object.getOwnPropertyDescriptor(e, i3);
    Object.defineProperty(r3, i3, n4.get ? n4 : { enumerable: true, get: function() {
      return e[i3];
    } });
  }), r3;
}
var Hn2 = { exports: {} };
(function(e) {
  (function() {
    var t = "input is invalid type", r3 = "finalize already called", i3 = typeof window == "object", n4 = i3 ? window : {};
    n4.JS_SHA3_NO_WINDOW && (i3 = false);
    var o4 = !i3 && typeof self == "object", h7 = !n4.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    h7 ? n4 = Kn2 : o4 && (n4 = self);
    var p5 = !n4.JS_SHA3_NO_COMMON_JS && true && e.exports, A5 = !n4.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", v7 = "0123456789abcdef".split(""), w6 = [31, 7936, 2031616, 520093696], y10 = [4, 1024, 262144, 67108864], S7 = [1, 256, 65536, 16777216], N4 = [6, 1536, 393216, 100663296], I5 = [0, 8, 16, 24], C5 = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648], D5 = [224, 256, 384, 512], U5 = [128, 256], J2 = ["hex", "buffer", "arrayBuffer", "array", "digest"], Bt5 = { 128: 168, 256: 136 };
    (n4.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(u4) {
      return Object.prototype.toString.call(u4) === "[object Array]";
    }), A5 && (n4.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(u4) {
      return typeof u4 == "object" && u4.buffer && u4.buffer.constructor === ArrayBuffer;
    });
    for (var G5 = function(u4, E6, _5) {
      return function(B5) {
        return new s2(u4, E6, u4).update(B5)[_5]();
      };
    }, H3 = function(u4, E6, _5) {
      return function(B5, R6) {
        return new s2(u4, E6, R6).update(B5)[_5]();
      };
    }, L4 = function(u4, E6, _5) {
      return function(B5, R6, F6, P5) {
        return f6["cshake" + u4].update(B5, R6, F6, P5)[_5]();
      };
    }, Pt5 = function(u4, E6, _5) {
      return function(B5, R6, F6, P5) {
        return f6["kmac" + u4].update(B5, R6, F6, P5)[_5]();
      };
    }, W3 = function(u4, E6, _5, B5) {
      for (var R6 = 0; R6 < J2.length; ++R6) {
        var F6 = J2[R6];
        u4[F6] = E6(_5, B5, F6);
      }
      return u4;
    }, Rt5 = function(u4, E6) {
      var _5 = G5(u4, E6, "hex");
      return _5.create = function() {
        return new s2(u4, E6, u4);
      }, _5.update = function(B5) {
        return _5.create().update(B5);
      }, W3(_5, G5, u4, E6);
    }, Vt5 = function(u4, E6) {
      var _5 = H3(u4, E6, "hex");
      return _5.create = function(B5) {
        return new s2(u4, E6, B5);
      }, _5.update = function(B5, R6) {
        return _5.create(R6).update(B5);
      }, W3(_5, H3, u4, E6);
    }, Y6 = function(u4, E6) {
      var _5 = Bt5[u4], B5 = L4(u4, E6, "hex");
      return B5.create = function(R6, F6, P5) {
        return !F6 && !P5 ? f6["shake" + u4].create(R6) : new s2(u4, E6, R6).bytepad([F6, P5], _5);
      }, B5.update = function(R6, F6, P5, O8) {
        return B5.create(F6, P5, O8).update(R6);
      }, W3(B5, L4, u4, E6);
    }, Wt5 = function(u4, E6) {
      var _5 = Bt5[u4], B5 = Pt5(u4, E6, "hex");
      return B5.create = function(R6, F6, P5) {
        return new g4(u4, E6, F6).bytepad(["KMAC", P5], _5).bytepad([R6], _5);
      }, B5.update = function(R6, F6, P5, O8) {
        return B5.create(R6, P5, O8).update(F6);
      }, W3(B5, Pt5, u4, E6);
    }, b6 = [{ name: "keccak", padding: S7, bits: D5, createMethod: Rt5 }, { name: "sha3", padding: N4, bits: D5, createMethod: Rt5 }, { name: "shake", padding: w6, bits: U5, createMethod: Vt5 }, { name: "cshake", padding: y10, bits: U5, createMethod: Y6 }, { name: "kmac", padding: y10, bits: U5, createMethod: Wt5 }], f6 = {}, a5 = [], c7 = 0; c7 < b6.length; ++c7) for (var d5 = b6[c7], m2 = d5.bits, x7 = 0; x7 < m2.length; ++x7) {
      var M6 = d5.name + "_" + m2[x7];
      if (a5.push(M6), f6[M6] = d5.createMethod(m2[x7], d5.padding), d5.name !== "sha3") {
        var l7 = d5.name + m2[x7];
        a5.push(l7), f6[l7] = f6[M6];
      }
    }
    function s2(u4, E6, _5) {
      this.blocks = [], this.s = [], this.padding = E6, this.outputBits = _5, this.reset = true, this.finalized = false, this.block = 0, this.start = 0, this.blockCount = 1600 - (u4 << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = _5 >> 5, this.extraBytes = (_5 & 31) >> 3;
      for (var B5 = 0; B5 < 50; ++B5) this.s[B5] = 0;
    }
    s2.prototype.update = function(u4) {
      if (this.finalized) throw new Error(r3);
      var E6, _5 = typeof u4;
      if (_5 !== "string") {
        if (_5 === "object") {
          if (u4 === null) throw new Error(t);
          if (A5 && u4.constructor === ArrayBuffer) u4 = new Uint8Array(u4);
          else if (!Array.isArray(u4) && (!A5 || !ArrayBuffer.isView(u4))) throw new Error(t);
        } else throw new Error(t);
        E6 = true;
      }
      for (var B5 = this.blocks, R6 = this.byteCount, F6 = u4.length, P5 = this.blockCount, O8 = 0, Ct5 = this.s, T4, q4; O8 < F6; ) {
        if (this.reset) for (this.reset = false, B5[0] = this.block, T4 = 1; T4 < P5 + 1; ++T4) B5[T4] = 0;
        if (E6) for (T4 = this.start; O8 < F6 && T4 < R6; ++O8) B5[T4 >> 2] |= u4[O8] << I5[T4++ & 3];
        else for (T4 = this.start; O8 < F6 && T4 < R6; ++O8) q4 = u4.charCodeAt(O8), q4 < 128 ? B5[T4 >> 2] |= q4 << I5[T4++ & 3] : q4 < 2048 ? (B5[T4 >> 2] |= (192 | q4 >> 6) << I5[T4++ & 3], B5[T4 >> 2] |= (128 | q4 & 63) << I5[T4++ & 3]) : q4 < 55296 || q4 >= 57344 ? (B5[T4 >> 2] |= (224 | q4 >> 12) << I5[T4++ & 3], B5[T4 >> 2] |= (128 | q4 >> 6 & 63) << I5[T4++ & 3], B5[T4 >> 2] |= (128 | q4 & 63) << I5[T4++ & 3]) : (q4 = 65536 + ((q4 & 1023) << 10 | u4.charCodeAt(++O8) & 1023), B5[T4 >> 2] |= (240 | q4 >> 18) << I5[T4++ & 3], B5[T4 >> 2] |= (128 | q4 >> 12 & 63) << I5[T4++ & 3], B5[T4 >> 2] |= (128 | q4 >> 6 & 63) << I5[T4++ & 3], B5[T4 >> 2] |= (128 | q4 & 63) << I5[T4++ & 3]);
        if (this.lastByteIndex = T4, T4 >= R6) {
          for (this.start = T4 - R6, this.block = B5[P5], T4 = 0; T4 < P5; ++T4) Ct5[T4] ^= B5[T4];
          k6(Ct5), this.reset = true;
        } else this.start = T4;
      }
      return this;
    }, s2.prototype.encode = function(u4, E6) {
      var _5 = u4 & 255, B5 = 1, R6 = [_5];
      for (u4 = u4 >> 8, _5 = u4 & 255; _5 > 0; ) R6.unshift(_5), u4 = u4 >> 8, _5 = u4 & 255, ++B5;
      return E6 ? R6.push(B5) : R6.unshift(B5), this.update(R6), R6.length;
    }, s2.prototype.encodeString = function(u4) {
      var E6, _5 = typeof u4;
      if (_5 !== "string") {
        if (_5 === "object") {
          if (u4 === null) throw new Error(t);
          if (A5 && u4.constructor === ArrayBuffer) u4 = new Uint8Array(u4);
          else if (!Array.isArray(u4) && (!A5 || !ArrayBuffer.isView(u4))) throw new Error(t);
        } else throw new Error(t);
        E6 = true;
      }
      var B5 = 0, R6 = u4.length;
      if (E6) B5 = R6;
      else for (var F6 = 0; F6 < u4.length; ++F6) {
        var P5 = u4.charCodeAt(F6);
        P5 < 128 ? B5 += 1 : P5 < 2048 ? B5 += 2 : P5 < 55296 || P5 >= 57344 ? B5 += 3 : (P5 = 65536 + ((P5 & 1023) << 10 | u4.charCodeAt(++F6) & 1023), B5 += 4);
      }
      return B5 += this.encode(B5 * 8), this.update(u4), B5;
    }, s2.prototype.bytepad = function(u4, E6) {
      for (var _5 = this.encode(E6), B5 = 0; B5 < u4.length; ++B5) _5 += this.encodeString(u4[B5]);
      var R6 = E6 - _5 % E6, F6 = [];
      return F6.length = R6, this.update(F6), this;
    }, s2.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = true;
        var u4 = this.blocks, E6 = this.lastByteIndex, _5 = this.blockCount, B5 = this.s;
        if (u4[E6 >> 2] |= this.padding[E6 & 3], this.lastByteIndex === this.byteCount) for (u4[0] = u4[_5], E6 = 1; E6 < _5 + 1; ++E6) u4[E6] = 0;
        for (u4[_5 - 1] |= 2147483648, E6 = 0; E6 < _5; ++E6) B5[E6] ^= u4[E6];
        k6(B5);
      }
    }, s2.prototype.toString = s2.prototype.hex = function() {
      this.finalize();
      for (var u4 = this.blockCount, E6 = this.s, _5 = this.outputBlocks, B5 = this.extraBytes, R6 = 0, F6 = 0, P5 = "", O8; F6 < _5; ) {
        for (R6 = 0; R6 < u4 && F6 < _5; ++R6, ++F6) O8 = E6[R6], P5 += v7[O8 >> 4 & 15] + v7[O8 & 15] + v7[O8 >> 12 & 15] + v7[O8 >> 8 & 15] + v7[O8 >> 20 & 15] + v7[O8 >> 16 & 15] + v7[O8 >> 28 & 15] + v7[O8 >> 24 & 15];
        F6 % u4 === 0 && (k6(E6), R6 = 0);
      }
      return B5 && (O8 = E6[R6], P5 += v7[O8 >> 4 & 15] + v7[O8 & 15], B5 > 1 && (P5 += v7[O8 >> 12 & 15] + v7[O8 >> 8 & 15]), B5 > 2 && (P5 += v7[O8 >> 20 & 15] + v7[O8 >> 16 & 15])), P5;
    }, s2.prototype.arrayBuffer = function() {
      this.finalize();
      var u4 = this.blockCount, E6 = this.s, _5 = this.outputBlocks, B5 = this.extraBytes, R6 = 0, F6 = 0, P5 = this.outputBits >> 3, O8;
      B5 ? O8 = new ArrayBuffer(_5 + 1 << 2) : O8 = new ArrayBuffer(P5);
      for (var Ct5 = new Uint32Array(O8); F6 < _5; ) {
        for (R6 = 0; R6 < u4 && F6 < _5; ++R6, ++F6) Ct5[F6] = E6[R6];
        F6 % u4 === 0 && k6(E6);
      }
      return B5 && (Ct5[R6] = E6[R6], O8 = O8.slice(0, P5)), O8;
    }, s2.prototype.buffer = s2.prototype.arrayBuffer, s2.prototype.digest = s2.prototype.array = function() {
      this.finalize();
      for (var u4 = this.blockCount, E6 = this.s, _5 = this.outputBlocks, B5 = this.extraBytes, R6 = 0, F6 = 0, P5 = [], O8, Ct5; F6 < _5; ) {
        for (R6 = 0; R6 < u4 && F6 < _5; ++R6, ++F6) O8 = F6 << 2, Ct5 = E6[R6], P5[O8] = Ct5 & 255, P5[O8 + 1] = Ct5 >> 8 & 255, P5[O8 + 2] = Ct5 >> 16 & 255, P5[O8 + 3] = Ct5 >> 24 & 255;
        F6 % u4 === 0 && k6(E6);
      }
      return B5 && (O8 = F6 << 2, Ct5 = E6[R6], P5[O8] = Ct5 & 255, B5 > 1 && (P5[O8 + 1] = Ct5 >> 8 & 255), B5 > 2 && (P5[O8 + 2] = Ct5 >> 16 & 255)), P5;
    };
    function g4(u4, E6, _5) {
      s2.call(this, u4, E6, _5);
    }
    g4.prototype = new s2(), g4.prototype.finalize = function() {
      return this.encode(this.outputBits, true), s2.prototype.finalize.call(this);
    };
    var k6 = function(u4) {
      var E6, _5, B5, R6, F6, P5, O8, Ct5, T4, q4, Te3, X2, $5, De2, Z5, tt6, Fe3, et5, rt4, Ue2, it5, nt5, ke3, ft4, ot5, qe2, st5, at4, Ke4, ut5, ht5, He2, ct4, lt5, Le5, dt5, pt5, ze3, vt3, gt4, je3, mt4, At5, Qe5, bt4, yt4, Je4, wt4, xt5, Ge3, Mt5, Et5, Ye3, St5, It4, Ve2, Nt5, _t4, Me2, Ee5, Se3, Ie4, Ne;
      for (B5 = 0; B5 < 48; B5 += 2) R6 = u4[0] ^ u4[10] ^ u4[20] ^ u4[30] ^ u4[40], F6 = u4[1] ^ u4[11] ^ u4[21] ^ u4[31] ^ u4[41], P5 = u4[2] ^ u4[12] ^ u4[22] ^ u4[32] ^ u4[42], O8 = u4[3] ^ u4[13] ^ u4[23] ^ u4[33] ^ u4[43], Ct5 = u4[4] ^ u4[14] ^ u4[24] ^ u4[34] ^ u4[44], T4 = u4[5] ^ u4[15] ^ u4[25] ^ u4[35] ^ u4[45], q4 = u4[6] ^ u4[16] ^ u4[26] ^ u4[36] ^ u4[46], Te3 = u4[7] ^ u4[17] ^ u4[27] ^ u4[37] ^ u4[47], X2 = u4[8] ^ u4[18] ^ u4[28] ^ u4[38] ^ u4[48], $5 = u4[9] ^ u4[19] ^ u4[29] ^ u4[39] ^ u4[49], E6 = X2 ^ (P5 << 1 | O8 >>> 31), _5 = $5 ^ (O8 << 1 | P5 >>> 31), u4[0] ^= E6, u4[1] ^= _5, u4[10] ^= E6, u4[11] ^= _5, u4[20] ^= E6, u4[21] ^= _5, u4[30] ^= E6, u4[31] ^= _5, u4[40] ^= E6, u4[41] ^= _5, E6 = R6 ^ (Ct5 << 1 | T4 >>> 31), _5 = F6 ^ (T4 << 1 | Ct5 >>> 31), u4[2] ^= E6, u4[3] ^= _5, u4[12] ^= E6, u4[13] ^= _5, u4[22] ^= E6, u4[23] ^= _5, u4[32] ^= E6, u4[33] ^= _5, u4[42] ^= E6, u4[43] ^= _5, E6 = P5 ^ (q4 << 1 | Te3 >>> 31), _5 = O8 ^ (Te3 << 1 | q4 >>> 31), u4[4] ^= E6, u4[5] ^= _5, u4[14] ^= E6, u4[15] ^= _5, u4[24] ^= E6, u4[25] ^= _5, u4[34] ^= E6, u4[35] ^= _5, u4[44] ^= E6, u4[45] ^= _5, E6 = Ct5 ^ (X2 << 1 | $5 >>> 31), _5 = T4 ^ ($5 << 1 | X2 >>> 31), u4[6] ^= E6, u4[7] ^= _5, u4[16] ^= E6, u4[17] ^= _5, u4[26] ^= E6, u4[27] ^= _5, u4[36] ^= E6, u4[37] ^= _5, u4[46] ^= E6, u4[47] ^= _5, E6 = q4 ^ (R6 << 1 | F6 >>> 31), _5 = Te3 ^ (F6 << 1 | R6 >>> 31), u4[8] ^= E6, u4[9] ^= _5, u4[18] ^= E6, u4[19] ^= _5, u4[28] ^= E6, u4[29] ^= _5, u4[38] ^= E6, u4[39] ^= _5, u4[48] ^= E6, u4[49] ^= _5, De2 = u4[0], Z5 = u4[1], yt4 = u4[11] << 4 | u4[10] >>> 28, Je4 = u4[10] << 4 | u4[11] >>> 28, at4 = u4[20] << 3 | u4[21] >>> 29, Ke4 = u4[21] << 3 | u4[20] >>> 29, Ee5 = u4[31] << 9 | u4[30] >>> 23, Se3 = u4[30] << 9 | u4[31] >>> 23, mt4 = u4[40] << 18 | u4[41] >>> 14, At5 = u4[41] << 18 | u4[40] >>> 14, lt5 = u4[2] << 1 | u4[3] >>> 31, Le5 = u4[3] << 1 | u4[2] >>> 31, tt6 = u4[13] << 12 | u4[12] >>> 20, Fe3 = u4[12] << 12 | u4[13] >>> 20, wt4 = u4[22] << 10 | u4[23] >>> 22, xt5 = u4[23] << 10 | u4[22] >>> 22, ut5 = u4[33] << 13 | u4[32] >>> 19, ht5 = u4[32] << 13 | u4[33] >>> 19, Ie4 = u4[42] << 2 | u4[43] >>> 30, Ne = u4[43] << 2 | u4[42] >>> 30, St5 = u4[5] << 30 | u4[4] >>> 2, It4 = u4[4] << 30 | u4[5] >>> 2, dt5 = u4[14] << 6 | u4[15] >>> 26, pt5 = u4[15] << 6 | u4[14] >>> 26, et5 = u4[25] << 11 | u4[24] >>> 21, rt4 = u4[24] << 11 | u4[25] >>> 21, Ge3 = u4[34] << 15 | u4[35] >>> 17, Mt5 = u4[35] << 15 | u4[34] >>> 17, He2 = u4[45] << 29 | u4[44] >>> 3, ct4 = u4[44] << 29 | u4[45] >>> 3, ft4 = u4[6] << 28 | u4[7] >>> 4, ot5 = u4[7] << 28 | u4[6] >>> 4, Ve2 = u4[17] << 23 | u4[16] >>> 9, Nt5 = u4[16] << 23 | u4[17] >>> 9, ze3 = u4[26] << 25 | u4[27] >>> 7, vt3 = u4[27] << 25 | u4[26] >>> 7, Ue2 = u4[36] << 21 | u4[37] >>> 11, it5 = u4[37] << 21 | u4[36] >>> 11, Et5 = u4[47] << 24 | u4[46] >>> 8, Ye3 = u4[46] << 24 | u4[47] >>> 8, Qe5 = u4[8] << 27 | u4[9] >>> 5, bt4 = u4[9] << 27 | u4[8] >>> 5, qe2 = u4[18] << 20 | u4[19] >>> 12, st5 = u4[19] << 20 | u4[18] >>> 12, _t4 = u4[29] << 7 | u4[28] >>> 25, Me2 = u4[28] << 7 | u4[29] >>> 25, gt4 = u4[38] << 8 | u4[39] >>> 24, je3 = u4[39] << 8 | u4[38] >>> 24, nt5 = u4[48] << 14 | u4[49] >>> 18, ke3 = u4[49] << 14 | u4[48] >>> 18, u4[0] = De2 ^ ~tt6 & et5, u4[1] = Z5 ^ ~Fe3 & rt4, u4[10] = ft4 ^ ~qe2 & at4, u4[11] = ot5 ^ ~st5 & Ke4, u4[20] = lt5 ^ ~dt5 & ze3, u4[21] = Le5 ^ ~pt5 & vt3, u4[30] = Qe5 ^ ~yt4 & wt4, u4[31] = bt4 ^ ~Je4 & xt5, u4[40] = St5 ^ ~Ve2 & _t4, u4[41] = It4 ^ ~Nt5 & Me2, u4[2] = tt6 ^ ~et5 & Ue2, u4[3] = Fe3 ^ ~rt4 & it5, u4[12] = qe2 ^ ~at4 & ut5, u4[13] = st5 ^ ~Ke4 & ht5, u4[22] = dt5 ^ ~ze3 & gt4, u4[23] = pt5 ^ ~vt3 & je3, u4[32] = yt4 ^ ~wt4 & Ge3, u4[33] = Je4 ^ ~xt5 & Mt5, u4[42] = Ve2 ^ ~_t4 & Ee5, u4[43] = Nt5 ^ ~Me2 & Se3, u4[4] = et5 ^ ~Ue2 & nt5, u4[5] = rt4 ^ ~it5 & ke3, u4[14] = at4 ^ ~ut5 & He2, u4[15] = Ke4 ^ ~ht5 & ct4, u4[24] = ze3 ^ ~gt4 & mt4, u4[25] = vt3 ^ ~je3 & At5, u4[34] = wt4 ^ ~Ge3 & Et5, u4[35] = xt5 ^ ~Mt5 & Ye3, u4[44] = _t4 ^ ~Ee5 & Ie4, u4[45] = Me2 ^ ~Se3 & Ne, u4[6] = Ue2 ^ ~nt5 & De2, u4[7] = it5 ^ ~ke3 & Z5, u4[16] = ut5 ^ ~He2 & ft4, u4[17] = ht5 ^ ~ct4 & ot5, u4[26] = gt4 ^ ~mt4 & lt5, u4[27] = je3 ^ ~At5 & Le5, u4[36] = Ge3 ^ ~Et5 & Qe5, u4[37] = Mt5 ^ ~Ye3 & bt4, u4[46] = Ee5 ^ ~Ie4 & St5, u4[47] = Se3 ^ ~Ne & It4, u4[8] = nt5 ^ ~De2 & tt6, u4[9] = ke3 ^ ~Z5 & Fe3, u4[18] = He2 ^ ~ft4 & qe2, u4[19] = ct4 ^ ~ot5 & st5, u4[28] = mt4 ^ ~lt5 & dt5, u4[29] = At5 ^ ~Le5 & pt5, u4[38] = Et5 ^ ~Qe5 & yt4, u4[39] = Ye3 ^ ~bt4 & Je4, u4[48] = Ie4 ^ ~St5 & Ve2, u4[49] = Ne ^ ~It4 & Nt5, u4[0] ^= C5[B5], u4[1] ^= C5[B5 + 1];
    };
    if (p5) e.exports = f6;
    else for (c7 = 0; c7 < a5.length; ++c7) n4[a5[c7]] = f6[a5[c7]];
  })();
})(Hn2);
var Cs2 = Hn2.exports;
var Rs2 = "logger/5.7.0";
var Ln2 = false;
var zn2 = false;
var Tr4 = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
var jn3 = Tr4.default;
var Mi3 = null;
function Os2() {
  try {
    const e = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((t) => {
      try {
        if ("test".normalize(t) !== "test") throw new Error("bad normalize");
      } catch {
        e.push(t);
      }
    }), e.length) throw new Error("missing " + e.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation");
  } catch (e) {
    return e.message;
  }
  return null;
}
var Qn3 = Os2();
var Ei3;
(function(e) {
  e.DEBUG = "DEBUG", e.INFO = "INFO", e.WARNING = "WARNING", e.ERROR = "ERROR", e.OFF = "OFF";
})(Ei3 || (Ei3 = {}));
var re4;
(function(e) {
  e.UNKNOWN_ERROR = "UNKNOWN_ERROR", e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", e.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", e.NETWORK_ERROR = "NETWORK_ERROR", e.SERVER_ERROR = "SERVER_ERROR", e.TIMEOUT = "TIMEOUT", e.BUFFER_OVERRUN = "BUFFER_OVERRUN", e.NUMERIC_FAULT = "NUMERIC_FAULT", e.MISSING_NEW = "MISSING_NEW", e.INVALID_ARGUMENT = "INVALID_ARGUMENT", e.MISSING_ARGUMENT = "MISSING_ARGUMENT", e.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", e.CALL_EXCEPTION = "CALL_EXCEPTION", e.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", e.NONCE_EXPIRED = "NONCE_EXPIRED", e.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", e.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", e.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", e.ACTION_REJECTED = "ACTION_REJECTED";
})(re4 || (re4 = {}));
var Jn3 = "0123456789abcdef";
var z5 = class _z {
  constructor(t) {
    Object.defineProperty(this, "version", { enumerable: true, value: t, writable: false });
  }
  _log(t, r3) {
    const i3 = t.toLowerCase();
    Tr4[i3] == null && this.throwArgumentError("invalid log level name", "logLevel", t), !(jn3 > Tr4[i3]) && console.log.apply(console, r3);
  }
  debug(...t) {
    this._log(_z.levels.DEBUG, t);
  }
  info(...t) {
    this._log(_z.levels.INFO, t);
  }
  warn(...t) {
    this._log(_z.levels.WARNING, t);
  }
  makeError(t, r3, i3) {
    if (zn2) return this.makeError("censored error", r3, {});
    r3 || (r3 = _z.errors.UNKNOWN_ERROR), i3 || (i3 = {});
    const n4 = [];
    Object.keys(i3).forEach((A5) => {
      const v7 = i3[A5];
      try {
        if (v7 instanceof Uint8Array) {
          let w6 = "";
          for (let y10 = 0; y10 < v7.length; y10++) w6 += Jn3[v7[y10] >> 4], w6 += Jn3[v7[y10] & 15];
          n4.push(A5 + "=Uint8Array(0x" + w6 + ")");
        } else n4.push(A5 + "=" + JSON.stringify(v7));
      } catch {
        n4.push(A5 + "=" + JSON.stringify(i3[A5].toString()));
      }
    }), n4.push(`code=${r3}`), n4.push(`version=${this.version}`);
    const o4 = t;
    let h7 = "";
    switch (r3) {
      case re4.NUMERIC_FAULT: {
        h7 = "NUMERIC_FAULT";
        const A5 = t;
        switch (A5) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            h7 += "-" + A5;
            break;
          case "negative-power":
          case "negative-width":
            h7 += "-unsupported";
            break;
          case "unbound-bitwise-result":
            h7 += "-unbound-result";
            break;
        }
        break;
      }
      case re4.CALL_EXCEPTION:
      case re4.INSUFFICIENT_FUNDS:
      case re4.MISSING_NEW:
      case re4.NONCE_EXPIRED:
      case re4.REPLACEMENT_UNDERPRICED:
      case re4.TRANSACTION_REPLACED:
      case re4.UNPREDICTABLE_GAS_LIMIT:
        h7 = r3;
        break;
    }
    h7 && (t += " [ See: https://links.ethers.org/v5-errors-" + h7 + " ]"), n4.length && (t += " (" + n4.join(", ") + ")");
    const p5 = new Error(t);
    return p5.reason = o4, p5.code = r3, Object.keys(i3).forEach(function(A5) {
      p5[A5] = i3[A5];
    }), p5;
  }
  throwError(t, r3, i3) {
    throw this.makeError(t, r3, i3);
  }
  throwArgumentError(t, r3, i3) {
    return this.throwError(t, _z.errors.INVALID_ARGUMENT, { argument: r3, value: i3 });
  }
  assert(t, r3, i3, n4) {
    t || this.throwError(r3, i3, n4);
  }
  assertArgument(t, r3, i3, n4) {
    t || this.throwArgumentError(r3, i3, n4);
  }
  checkNormalize(t) {
    Qn3 && this.throwError("platform missing String.prototype.normalize", _z.errors.UNSUPPORTED_OPERATION, { operation: "String.prototype.normalize", form: Qn3 });
  }
  checkSafeUint53(t, r3) {
    typeof t == "number" && (r3 == null && (r3 = "value not safe"), (t < 0 || t >= 9007199254740991) && this.throwError(r3, _z.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "out-of-safe-range", value: t }), t % 1 && this.throwError(r3, _z.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "non-integer", value: t }));
  }
  checkArgumentCount(t, r3, i3) {
    i3 ? i3 = ": " + i3 : i3 = "", t < r3 && this.throwError("missing argument" + i3, _z.errors.MISSING_ARGUMENT, { count: t, expectedCount: r3 }), t > r3 && this.throwError("too many arguments" + i3, _z.errors.UNEXPECTED_ARGUMENT, { count: t, expectedCount: r3 });
  }
  checkNew(t, r3) {
    (t === Object || t == null) && this.throwError("missing new", _z.errors.MISSING_NEW, { name: r3.name });
  }
  checkAbstract(t, r3) {
    t === r3 ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r3.name) + " directly; use a sub-class", _z.errors.UNSUPPORTED_OPERATION, { name: t.name, operation: "new" }) : (t === Object || t == null) && this.throwError("missing new", _z.errors.MISSING_NEW, { name: r3.name });
  }
  static globalLogger() {
    return Mi3 || (Mi3 = new _z(Rs2)), Mi3;
  }
  static setCensorship(t, r3) {
    if (!t && r3 && this.globalLogger().throwError("cannot permanently disable censorship", _z.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" }), Ln2) {
      if (!t) return;
      this.globalLogger().throwError("error censorship permanent", _z.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" });
    }
    zn2 = !!t, Ln2 = !!r3;
  }
  static setLogLevel(t) {
    const r3 = Tr4[t.toLowerCase()];
    if (r3 == null) {
      _z.globalLogger().warn("invalid log level - " + t);
      return;
    }
    jn3 = r3;
  }
  static from(t) {
    return new _z(t);
  }
};
z5.errors = re4, z5.levels = Ei3;
var Ps2 = "bytes/5.7.0";
var Tt4 = new z5(Ps2);
function Gn3(e) {
  return !!e.toHexString;
}
function ir2(e) {
  return e.slice || (e.slice = function() {
    const t = Array.prototype.slice.call(arguments);
    return ir2(new Uint8Array(Array.prototype.slice.apply(e, t)));
  }), e;
}
function Ts2(e) {
  return Jt4(e) && !(e.length % 2) || nr4(e);
}
function Yn2(e) {
  return typeof e == "number" && e == e && e % 1 === 0;
}
function nr4(e) {
  if (e == null) return false;
  if (e.constructor === Uint8Array) return true;
  if (typeof e == "string" || !Yn2(e.length) || e.length < 0) return false;
  for (let t = 0; t < e.length; t++) {
    const r3 = e[t];
    if (!Yn2(r3) || r3 < 0 || r3 >= 256) return false;
  }
  return true;
}
function Ot4(e, t) {
  if (t || (t = {}), typeof e == "number") {
    Tt4.checkSafeUint53(e, "invalid arrayify value");
    const r3 = [];
    for (; e; ) r3.unshift(e & 255), e = parseInt(String(e / 256));
    return r3.length === 0 && r3.push(0), ir2(new Uint8Array(r3));
  }
  if (t.allowMissingPrefix && typeof e == "string" && e.substring(0, 2) !== "0x" && (e = "0x" + e), Gn3(e) && (e = e.toHexString()), Jt4(e)) {
    let r3 = e.substring(2);
    r3.length % 2 && (t.hexPad === "left" ? r3 = "0" + r3 : t.hexPad === "right" ? r3 += "0" : Tt4.throwArgumentError("hex data is odd-length", "value", e));
    const i3 = [];
    for (let n4 = 0; n4 < r3.length; n4 += 2) i3.push(parseInt(r3.substring(n4, n4 + 2), 16));
    return ir2(new Uint8Array(i3));
  }
  return nr4(e) ? ir2(new Uint8Array(e)) : Tt4.throwArgumentError("invalid arrayify value", "value", e);
}
function Ds2(e) {
  const t = e.map((n4) => Ot4(n4)), r3 = t.reduce((n4, o4) => n4 + o4.length, 0), i3 = new Uint8Array(r3);
  return t.reduce((n4, o4) => (i3.set(o4, n4), n4 + o4.length), 0), ir2(i3);
}
function Fs2(e, t) {
  e = Ot4(e), e.length > t && Tt4.throwArgumentError("value out of range", "value", arguments[0]);
  const r3 = new Uint8Array(t);
  return r3.set(e, t - e.length), ir2(r3);
}
function Jt4(e, t) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || t && e.length !== 2 + 2 * t);
}
var Si2 = "0123456789abcdef";
function Kt4(e, t) {
  if (t || (t = {}), typeof e == "number") {
    Tt4.checkSafeUint53(e, "invalid hexlify value");
    let r3 = "";
    for (; e; ) r3 = Si2[e & 15] + r3, e = Math.floor(e / 16);
    return r3.length ? (r3.length % 2 && (r3 = "0" + r3), "0x" + r3) : "0x00";
  }
  if (typeof e == "bigint") return e = e.toString(16), e.length % 2 ? "0x0" + e : "0x" + e;
  if (t.allowMissingPrefix && typeof e == "string" && e.substring(0, 2) !== "0x" && (e = "0x" + e), Gn3(e)) return e.toHexString();
  if (Jt4(e)) return e.length % 2 && (t.hexPad === "left" ? e = "0x0" + e.substring(2) : t.hexPad === "right" ? e += "0" : Tt4.throwArgumentError("hex data is odd-length", "value", e)), e.toLowerCase();
  if (nr4(e)) {
    let r3 = "0x";
    for (let i3 = 0; i3 < e.length; i3++) {
      let n4 = e[i3];
      r3 += Si2[(n4 & 240) >> 4] + Si2[n4 & 15];
    }
    return r3;
  }
  return Tt4.throwArgumentError("invalid hexlify value", "value", e);
}
function Us2(e) {
  if (typeof e != "string") e = Kt4(e);
  else if (!Jt4(e) || e.length % 2) return null;
  return (e.length - 2) / 2;
}
function Vn3(e, t, r3) {
  return typeof e != "string" ? e = Kt4(e) : (!Jt4(e) || e.length % 2) && Tt4.throwArgumentError("invalid hexData", "value", e), t = 2 + 2 * t, r3 != null ? "0x" + e.substring(t, 2 + 2 * r3) : "0x" + e.substring(t);
}
function oe2(e, t) {
  for (typeof e != "string" ? e = Kt4(e) : Jt4(e) || Tt4.throwArgumentError("invalid hex string", "value", e), e.length > 2 * t + 2 && Tt4.throwArgumentError("value out of range", "value", arguments[1]); e.length < 2 * t + 2; ) e = "0x0" + e.substring(2);
  return e;
}
function Wn3(e) {
  const t = { r: "0x", s: "0x", _vs: "0x", recoveryParam: 0, v: 0, yParityAndS: "0x", compact: "0x" };
  if (Ts2(e)) {
    let r3 = Ot4(e);
    r3.length === 64 ? (t.v = 27 + (r3[32] >> 7), r3[32] &= 127, t.r = Kt4(r3.slice(0, 32)), t.s = Kt4(r3.slice(32, 64))) : r3.length === 65 ? (t.r = Kt4(r3.slice(0, 32)), t.s = Kt4(r3.slice(32, 64)), t.v = r3[64]) : Tt4.throwArgumentError("invalid signature string", "signature", e), t.v < 27 && (t.v === 0 || t.v === 1 ? t.v += 27 : Tt4.throwArgumentError("signature invalid v byte", "signature", e)), t.recoveryParam = 1 - t.v % 2, t.recoveryParam && (r3[32] |= 128), t._vs = Kt4(r3.slice(32, 64));
  } else {
    if (t.r = e.r, t.s = e.s, t.v = e.v, t.recoveryParam = e.recoveryParam, t._vs = e._vs, t._vs != null) {
      const n4 = Fs2(Ot4(t._vs), 32);
      t._vs = Kt4(n4);
      const o4 = n4[0] >= 128 ? 1 : 0;
      t.recoveryParam == null ? t.recoveryParam = o4 : t.recoveryParam !== o4 && Tt4.throwArgumentError("signature recoveryParam mismatch _vs", "signature", e), n4[0] &= 127;
      const h7 = Kt4(n4);
      t.s == null ? t.s = h7 : t.s !== h7 && Tt4.throwArgumentError("signature v mismatch _vs", "signature", e);
    }
    if (t.recoveryParam == null) t.v == null ? Tt4.throwArgumentError("signature missing v and recoveryParam", "signature", e) : t.v === 0 || t.v === 1 ? t.recoveryParam = t.v : t.recoveryParam = 1 - t.v % 2;
    else if (t.v == null) t.v = 27 + t.recoveryParam;
    else {
      const n4 = t.v === 0 || t.v === 1 ? t.v : 1 - t.v % 2;
      t.recoveryParam !== n4 && Tt4.throwArgumentError("signature recoveryParam mismatch v", "signature", e);
    }
    t.r == null || !Jt4(t.r) ? Tt4.throwArgumentError("signature missing or invalid r", "signature", e) : t.r = oe2(t.r, 32), t.s == null || !Jt4(t.s) ? Tt4.throwArgumentError("signature missing or invalid s", "signature", e) : t.s = oe2(t.s, 32);
    const r3 = Ot4(t.s);
    r3[0] >= 128 && Tt4.throwArgumentError("signature s out of range", "signature", e), t.recoveryParam && (r3[0] |= 128);
    const i3 = Kt4(r3);
    t._vs && (Jt4(t._vs) || Tt4.throwArgumentError("signature invalid _vs", "signature", e), t._vs = oe2(t._vs, 32)), t._vs == null ? t._vs = i3 : t._vs !== i3 && Tt4.throwArgumentError("signature _vs mismatch v and s", "signature", e);
  }
  return t.yParityAndS = t._vs, t.compact = t.r + t.yParityAndS.substring(2), t;
}
function Ii3(e) {
  return "0x" + Cs2.keccak_256(Ot4(e));
}
var Xn3 = { exports: {} };
var ks2 = {};
var qs2 = Object.freeze({ __proto__: null, default: ks2 });
var Ks2 = Bs2(qs2);
(function(e) {
  (function(t, r3) {
    function i3(b6, f6) {
      if (!b6) throw new Error(f6 || "Assertion failed");
    }
    function n4(b6, f6) {
      b6.super_ = f6;
      var a5 = function() {
      };
      a5.prototype = f6.prototype, b6.prototype = new a5(), b6.prototype.constructor = b6;
    }
    function o4(b6, f6, a5) {
      if (o4.isBN(b6)) return b6;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, b6 !== null && ((f6 === "le" || f6 === "be") && (a5 = f6, f6 = 10), this._init(b6 || 0, f6 || 10, a5 || "be"));
    }
    typeof t == "object" ? t.exports = o4 : r3.BN = o4, o4.BN = o4, o4.wordSize = 26;
    var h7;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? h7 = window.Buffer : h7 = Ks2.Buffer;
    } catch {
    }
    o4.isBN = function(f6) {
      return f6 instanceof o4 ? true : f6 !== null && typeof f6 == "object" && f6.constructor.wordSize === o4.wordSize && Array.isArray(f6.words);
    }, o4.max = function(f6, a5) {
      return f6.cmp(a5) > 0 ? f6 : a5;
    }, o4.min = function(f6, a5) {
      return f6.cmp(a5) < 0 ? f6 : a5;
    }, o4.prototype._init = function(f6, a5, c7) {
      if (typeof f6 == "number") return this._initNumber(f6, a5, c7);
      if (typeof f6 == "object") return this._initArray(f6, a5, c7);
      a5 === "hex" && (a5 = 16), i3(a5 === (a5 | 0) && a5 >= 2 && a5 <= 36), f6 = f6.toString().replace(/\s+/g, "");
      var d5 = 0;
      f6[0] === "-" && (d5++, this.negative = 1), d5 < f6.length && (a5 === 16 ? this._parseHex(f6, d5, c7) : (this._parseBase(f6, a5, d5), c7 === "le" && this._initArray(this.toArray(), a5, c7)));
    }, o4.prototype._initNumber = function(f6, a5, c7) {
      f6 < 0 && (this.negative = 1, f6 = -f6), f6 < 67108864 ? (this.words = [f6 & 67108863], this.length = 1) : f6 < 4503599627370496 ? (this.words = [f6 & 67108863, f6 / 67108864 & 67108863], this.length = 2) : (i3(f6 < 9007199254740992), this.words = [f6 & 67108863, f6 / 67108864 & 67108863, 1], this.length = 3), c7 === "le" && this._initArray(this.toArray(), a5, c7);
    }, o4.prototype._initArray = function(f6, a5, c7) {
      if (i3(typeof f6.length == "number"), f6.length <= 0) return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f6.length / 3), this.words = new Array(this.length);
      for (var d5 = 0; d5 < this.length; d5++) this.words[d5] = 0;
      var m2, x7, M6 = 0;
      if (c7 === "be") for (d5 = f6.length - 1, m2 = 0; d5 >= 0; d5 -= 3) x7 = f6[d5] | f6[d5 - 1] << 8 | f6[d5 - 2] << 16, this.words[m2] |= x7 << M6 & 67108863, this.words[m2 + 1] = x7 >>> 26 - M6 & 67108863, M6 += 24, M6 >= 26 && (M6 -= 26, m2++);
      else if (c7 === "le") for (d5 = 0, m2 = 0; d5 < f6.length; d5 += 3) x7 = f6[d5] | f6[d5 + 1] << 8 | f6[d5 + 2] << 16, this.words[m2] |= x7 << M6 & 67108863, this.words[m2 + 1] = x7 >>> 26 - M6 & 67108863, M6 += 24, M6 >= 26 && (M6 -= 26, m2++);
      return this._strip();
    };
    function p5(b6, f6) {
      var a5 = b6.charCodeAt(f6);
      if (a5 >= 48 && a5 <= 57) return a5 - 48;
      if (a5 >= 65 && a5 <= 70) return a5 - 55;
      if (a5 >= 97 && a5 <= 102) return a5 - 87;
      i3(false, "Invalid character in " + b6);
    }
    function A5(b6, f6, a5) {
      var c7 = p5(b6, a5);
      return a5 - 1 >= f6 && (c7 |= p5(b6, a5 - 1) << 4), c7;
    }
    o4.prototype._parseHex = function(f6, a5, c7) {
      this.length = Math.ceil((f6.length - a5) / 6), this.words = new Array(this.length);
      for (var d5 = 0; d5 < this.length; d5++) this.words[d5] = 0;
      var m2 = 0, x7 = 0, M6;
      if (c7 === "be") for (d5 = f6.length - 1; d5 >= a5; d5 -= 2) M6 = A5(f6, a5, d5) << m2, this.words[x7] |= M6 & 67108863, m2 >= 18 ? (m2 -= 18, x7 += 1, this.words[x7] |= M6 >>> 26) : m2 += 8;
      else {
        var l7 = f6.length - a5;
        for (d5 = l7 % 2 === 0 ? a5 + 1 : a5; d5 < f6.length; d5 += 2) M6 = A5(f6, a5, d5) << m2, this.words[x7] |= M6 & 67108863, m2 >= 18 ? (m2 -= 18, x7 += 1, this.words[x7] |= M6 >>> 26) : m2 += 8;
      }
      this._strip();
    };
    function v7(b6, f6, a5, c7) {
      for (var d5 = 0, m2 = 0, x7 = Math.min(b6.length, a5), M6 = f6; M6 < x7; M6++) {
        var l7 = b6.charCodeAt(M6) - 48;
        d5 *= c7, l7 >= 49 ? m2 = l7 - 49 + 10 : l7 >= 17 ? m2 = l7 - 17 + 10 : m2 = l7, i3(l7 >= 0 && m2 < c7, "Invalid character"), d5 += m2;
      }
      return d5;
    }
    o4.prototype._parseBase = function(f6, a5, c7) {
      this.words = [0], this.length = 1;
      for (var d5 = 0, m2 = 1; m2 <= 67108863; m2 *= a5) d5++;
      d5--, m2 = m2 / a5 | 0;
      for (var x7 = f6.length - c7, M6 = x7 % d5, l7 = Math.min(x7, x7 - M6) + c7, s2 = 0, g4 = c7; g4 < l7; g4 += d5) s2 = v7(f6, g4, g4 + d5, a5), this.imuln(m2), this.words[0] + s2 < 67108864 ? this.words[0] += s2 : this._iaddn(s2);
      if (M6 !== 0) {
        var k6 = 1;
        for (s2 = v7(f6, g4, f6.length, a5), g4 = 0; g4 < M6; g4++) k6 *= a5;
        this.imuln(k6), this.words[0] + s2 < 67108864 ? this.words[0] += s2 : this._iaddn(s2);
      }
      this._strip();
    }, o4.prototype.copy = function(f6) {
      f6.words = new Array(this.length);
      for (var a5 = 0; a5 < this.length; a5++) f6.words[a5] = this.words[a5];
      f6.length = this.length, f6.negative = this.negative, f6.red = this.red;
    };
    function w6(b6, f6) {
      b6.words = f6.words, b6.length = f6.length, b6.negative = f6.negative, b6.red = f6.red;
    }
    if (o4.prototype._move = function(f6) {
      w6(f6, this);
    }, o4.prototype.clone = function() {
      var f6 = new o4(null);
      return this.copy(f6), f6;
    }, o4.prototype._expand = function(f6) {
      for (; this.length < f6; ) this.words[this.length++] = 0;
      return this;
    }, o4.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
      return this._normSign();
    }, o4.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
      o4.prototype[Symbol.for("nodejs.util.inspect.custom")] = y10;
    } catch {
      o4.prototype.inspect = y10;
    }
    else o4.prototype.inspect = y10;
    function y10() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var S7 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], N4 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], I5 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    o4.prototype.toString = function(f6, a5) {
      f6 = f6 || 10, a5 = a5 | 0 || 1;
      var c7;
      if (f6 === 16 || f6 === "hex") {
        c7 = "";
        for (var d5 = 0, m2 = 0, x7 = 0; x7 < this.length; x7++) {
          var M6 = this.words[x7], l7 = ((M6 << d5 | m2) & 16777215).toString(16);
          m2 = M6 >>> 24 - d5 & 16777215, d5 += 2, d5 >= 26 && (d5 -= 26, x7--), m2 !== 0 || x7 !== this.length - 1 ? c7 = S7[6 - l7.length] + l7 + c7 : c7 = l7 + c7;
        }
        for (m2 !== 0 && (c7 = m2.toString(16) + c7); c7.length % a5 !== 0; ) c7 = "0" + c7;
        return this.negative !== 0 && (c7 = "-" + c7), c7;
      }
      if (f6 === (f6 | 0) && f6 >= 2 && f6 <= 36) {
        var s2 = N4[f6], g4 = I5[f6];
        c7 = "";
        var k6 = this.clone();
        for (k6.negative = 0; !k6.isZero(); ) {
          var u4 = k6.modrn(g4).toString(f6);
          k6 = k6.idivn(g4), k6.isZero() ? c7 = u4 + c7 : c7 = S7[s2 - u4.length] + u4 + c7;
        }
        for (this.isZero() && (c7 = "0" + c7); c7.length % a5 !== 0; ) c7 = "0" + c7;
        return this.negative !== 0 && (c7 = "-" + c7), c7;
      }
      i3(false, "Base should be between 2 and 36");
    }, o4.prototype.toNumber = function() {
      var f6 = this.words[0];
      return this.length === 2 ? f6 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f6 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i3(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f6 : f6;
    }, o4.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, h7 && (o4.prototype.toBuffer = function(f6, a5) {
      return this.toArrayLike(h7, f6, a5);
    }), o4.prototype.toArray = function(f6, a5) {
      return this.toArrayLike(Array, f6, a5);
    };
    var C5 = function(f6, a5) {
      return f6.allocUnsafe ? f6.allocUnsafe(a5) : new f6(a5);
    };
    o4.prototype.toArrayLike = function(f6, a5, c7) {
      this._strip();
      var d5 = this.byteLength(), m2 = c7 || Math.max(1, d5);
      i3(d5 <= m2, "byte array longer than desired length"), i3(m2 > 0, "Requested array length <= 0");
      var x7 = C5(f6, m2), M6 = a5 === "le" ? "LE" : "BE";
      return this["_toArrayLike" + M6](x7, d5), x7;
    }, o4.prototype._toArrayLikeLE = function(f6, a5) {
      for (var c7 = 0, d5 = 0, m2 = 0, x7 = 0; m2 < this.length; m2++) {
        var M6 = this.words[m2] << x7 | d5;
        f6[c7++] = M6 & 255, c7 < f6.length && (f6[c7++] = M6 >> 8 & 255), c7 < f6.length && (f6[c7++] = M6 >> 16 & 255), x7 === 6 ? (c7 < f6.length && (f6[c7++] = M6 >> 24 & 255), d5 = 0, x7 = 0) : (d5 = M6 >>> 24, x7 += 2);
      }
      if (c7 < f6.length) for (f6[c7++] = d5; c7 < f6.length; ) f6[c7++] = 0;
    }, o4.prototype._toArrayLikeBE = function(f6, a5) {
      for (var c7 = f6.length - 1, d5 = 0, m2 = 0, x7 = 0; m2 < this.length; m2++) {
        var M6 = this.words[m2] << x7 | d5;
        f6[c7--] = M6 & 255, c7 >= 0 && (f6[c7--] = M6 >> 8 & 255), c7 >= 0 && (f6[c7--] = M6 >> 16 & 255), x7 === 6 ? (c7 >= 0 && (f6[c7--] = M6 >> 24 & 255), d5 = 0, x7 = 0) : (d5 = M6 >>> 24, x7 += 2);
      }
      if (c7 >= 0) for (f6[c7--] = d5; c7 >= 0; ) f6[c7--] = 0;
    }, Math.clz32 ? o4.prototype._countBits = function(f6) {
      return 32 - Math.clz32(f6);
    } : o4.prototype._countBits = function(f6) {
      var a5 = f6, c7 = 0;
      return a5 >= 4096 && (c7 += 13, a5 >>>= 13), a5 >= 64 && (c7 += 7, a5 >>>= 7), a5 >= 8 && (c7 += 4, a5 >>>= 4), a5 >= 2 && (c7 += 2, a5 >>>= 2), c7 + a5;
    }, o4.prototype._zeroBits = function(f6) {
      if (f6 === 0) return 26;
      var a5 = f6, c7 = 0;
      return a5 & 8191 || (c7 += 13, a5 >>>= 13), a5 & 127 || (c7 += 7, a5 >>>= 7), a5 & 15 || (c7 += 4, a5 >>>= 4), a5 & 3 || (c7 += 2, a5 >>>= 2), a5 & 1 || c7++, c7;
    }, o4.prototype.bitLength = function() {
      var f6 = this.words[this.length - 1], a5 = this._countBits(f6);
      return (this.length - 1) * 26 + a5;
    };
    function D5(b6) {
      for (var f6 = new Array(b6.bitLength()), a5 = 0; a5 < f6.length; a5++) {
        var c7 = a5 / 26 | 0, d5 = a5 % 26;
        f6[a5] = b6.words[c7] >>> d5 & 1;
      }
      return f6;
    }
    o4.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var f6 = 0, a5 = 0; a5 < this.length; a5++) {
        var c7 = this._zeroBits(this.words[a5]);
        if (f6 += c7, c7 !== 26) break;
      }
      return f6;
    }, o4.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, o4.prototype.toTwos = function(f6) {
      return this.negative !== 0 ? this.abs().inotn(f6).iaddn(1) : this.clone();
    }, o4.prototype.fromTwos = function(f6) {
      return this.testn(f6 - 1) ? this.notn(f6).iaddn(1).ineg() : this.clone();
    }, o4.prototype.isNeg = function() {
      return this.negative !== 0;
    }, o4.prototype.neg = function() {
      return this.clone().ineg();
    }, o4.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, o4.prototype.iuor = function(f6) {
      for (; this.length < f6.length; ) this.words[this.length++] = 0;
      for (var a5 = 0; a5 < f6.length; a5++) this.words[a5] = this.words[a5] | f6.words[a5];
      return this._strip();
    }, o4.prototype.ior = function(f6) {
      return i3((this.negative | f6.negative) === 0), this.iuor(f6);
    }, o4.prototype.or = function(f6) {
      return this.length > f6.length ? this.clone().ior(f6) : f6.clone().ior(this);
    }, o4.prototype.uor = function(f6) {
      return this.length > f6.length ? this.clone().iuor(f6) : f6.clone().iuor(this);
    }, o4.prototype.iuand = function(f6) {
      var a5;
      this.length > f6.length ? a5 = f6 : a5 = this;
      for (var c7 = 0; c7 < a5.length; c7++) this.words[c7] = this.words[c7] & f6.words[c7];
      return this.length = a5.length, this._strip();
    }, o4.prototype.iand = function(f6) {
      return i3((this.negative | f6.negative) === 0), this.iuand(f6);
    }, o4.prototype.and = function(f6) {
      return this.length > f6.length ? this.clone().iand(f6) : f6.clone().iand(this);
    }, o4.prototype.uand = function(f6) {
      return this.length > f6.length ? this.clone().iuand(f6) : f6.clone().iuand(this);
    }, o4.prototype.iuxor = function(f6) {
      var a5, c7;
      this.length > f6.length ? (a5 = this, c7 = f6) : (a5 = f6, c7 = this);
      for (var d5 = 0; d5 < c7.length; d5++) this.words[d5] = a5.words[d5] ^ c7.words[d5];
      if (this !== a5) for (; d5 < a5.length; d5++) this.words[d5] = a5.words[d5];
      return this.length = a5.length, this._strip();
    }, o4.prototype.ixor = function(f6) {
      return i3((this.negative | f6.negative) === 0), this.iuxor(f6);
    }, o4.prototype.xor = function(f6) {
      return this.length > f6.length ? this.clone().ixor(f6) : f6.clone().ixor(this);
    }, o4.prototype.uxor = function(f6) {
      return this.length > f6.length ? this.clone().iuxor(f6) : f6.clone().iuxor(this);
    }, o4.prototype.inotn = function(f6) {
      i3(typeof f6 == "number" && f6 >= 0);
      var a5 = Math.ceil(f6 / 26) | 0, c7 = f6 % 26;
      this._expand(a5), c7 > 0 && a5--;
      for (var d5 = 0; d5 < a5; d5++) this.words[d5] = ~this.words[d5] & 67108863;
      return c7 > 0 && (this.words[d5] = ~this.words[d5] & 67108863 >> 26 - c7), this._strip();
    }, o4.prototype.notn = function(f6) {
      return this.clone().inotn(f6);
    }, o4.prototype.setn = function(f6, a5) {
      i3(typeof f6 == "number" && f6 >= 0);
      var c7 = f6 / 26 | 0, d5 = f6 % 26;
      return this._expand(c7 + 1), a5 ? this.words[c7] = this.words[c7] | 1 << d5 : this.words[c7] = this.words[c7] & ~(1 << d5), this._strip();
    }, o4.prototype.iadd = function(f6) {
      var a5;
      if (this.negative !== 0 && f6.negative === 0) return this.negative = 0, a5 = this.isub(f6), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f6.negative !== 0) return f6.negative = 0, a5 = this.isub(f6), f6.negative = 1, a5._normSign();
      var c7, d5;
      this.length > f6.length ? (c7 = this, d5 = f6) : (c7 = f6, d5 = this);
      for (var m2 = 0, x7 = 0; x7 < d5.length; x7++) a5 = (c7.words[x7] | 0) + (d5.words[x7] | 0) + m2, this.words[x7] = a5 & 67108863, m2 = a5 >>> 26;
      for (; m2 !== 0 && x7 < c7.length; x7++) a5 = (c7.words[x7] | 0) + m2, this.words[x7] = a5 & 67108863, m2 = a5 >>> 26;
      if (this.length = c7.length, m2 !== 0) this.words[this.length] = m2, this.length++;
      else if (c7 !== this) for (; x7 < c7.length; x7++) this.words[x7] = c7.words[x7];
      return this;
    }, o4.prototype.add = function(f6) {
      var a5;
      return f6.negative !== 0 && this.negative === 0 ? (f6.negative = 0, a5 = this.sub(f6), f6.negative ^= 1, a5) : f6.negative === 0 && this.negative !== 0 ? (this.negative = 0, a5 = f6.sub(this), this.negative = 1, a5) : this.length > f6.length ? this.clone().iadd(f6) : f6.clone().iadd(this);
    }, o4.prototype.isub = function(f6) {
      if (f6.negative !== 0) {
        f6.negative = 0;
        var a5 = this.iadd(f6);
        return f6.negative = 1, a5._normSign();
      } else if (this.negative !== 0) return this.negative = 0, this.iadd(f6), this.negative = 1, this._normSign();
      var c7 = this.cmp(f6);
      if (c7 === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var d5, m2;
      c7 > 0 ? (d5 = this, m2 = f6) : (d5 = f6, m2 = this);
      for (var x7 = 0, M6 = 0; M6 < m2.length; M6++) a5 = (d5.words[M6] | 0) - (m2.words[M6] | 0) + x7, x7 = a5 >> 26, this.words[M6] = a5 & 67108863;
      for (; x7 !== 0 && M6 < d5.length; M6++) a5 = (d5.words[M6] | 0) + x7, x7 = a5 >> 26, this.words[M6] = a5 & 67108863;
      if (x7 === 0 && M6 < d5.length && d5 !== this) for (; M6 < d5.length; M6++) this.words[M6] = d5.words[M6];
      return this.length = Math.max(this.length, M6), d5 !== this && (this.negative = 1), this._strip();
    }, o4.prototype.sub = function(f6) {
      return this.clone().isub(f6);
    };
    function U5(b6, f6, a5) {
      a5.negative = f6.negative ^ b6.negative;
      var c7 = b6.length + f6.length | 0;
      a5.length = c7, c7 = c7 - 1 | 0;
      var d5 = b6.words[0] | 0, m2 = f6.words[0] | 0, x7 = d5 * m2, M6 = x7 & 67108863, l7 = x7 / 67108864 | 0;
      a5.words[0] = M6;
      for (var s2 = 1; s2 < c7; s2++) {
        for (var g4 = l7 >>> 26, k6 = l7 & 67108863, u4 = Math.min(s2, f6.length - 1), E6 = Math.max(0, s2 - b6.length + 1); E6 <= u4; E6++) {
          var _5 = s2 - E6 | 0;
          d5 = b6.words[_5] | 0, m2 = f6.words[E6] | 0, x7 = d5 * m2 + k6, g4 += x7 / 67108864 | 0, k6 = x7 & 67108863;
        }
        a5.words[s2] = k6 | 0, l7 = g4 | 0;
      }
      return l7 !== 0 ? a5.words[s2] = l7 | 0 : a5.length--, a5._strip();
    }
    var J2 = function(f6, a5, c7) {
      var d5 = f6.words, m2 = a5.words, x7 = c7.words, M6 = 0, l7, s2, g4, k6 = d5[0] | 0, u4 = k6 & 8191, E6 = k6 >>> 13, _5 = d5[1] | 0, B5 = _5 & 8191, R6 = _5 >>> 13, F6 = d5[2] | 0, P5 = F6 & 8191, O8 = F6 >>> 13, Ct5 = d5[3] | 0, T4 = Ct5 & 8191, q4 = Ct5 >>> 13, Te3 = d5[4] | 0, X2 = Te3 & 8191, $5 = Te3 >>> 13, De2 = d5[5] | 0, Z5 = De2 & 8191, tt6 = De2 >>> 13, Fe3 = d5[6] | 0, et5 = Fe3 & 8191, rt4 = Fe3 >>> 13, Ue2 = d5[7] | 0, it5 = Ue2 & 8191, nt5 = Ue2 >>> 13, ke3 = d5[8] | 0, ft4 = ke3 & 8191, ot5 = ke3 >>> 13, qe2 = d5[9] | 0, st5 = qe2 & 8191, at4 = qe2 >>> 13, Ke4 = m2[0] | 0, ut5 = Ke4 & 8191, ht5 = Ke4 >>> 13, He2 = m2[1] | 0, ct4 = He2 & 8191, lt5 = He2 >>> 13, Le5 = m2[2] | 0, dt5 = Le5 & 8191, pt5 = Le5 >>> 13, ze3 = m2[3] | 0, vt3 = ze3 & 8191, gt4 = ze3 >>> 13, je3 = m2[4] | 0, mt4 = je3 & 8191, At5 = je3 >>> 13, Qe5 = m2[5] | 0, bt4 = Qe5 & 8191, yt4 = Qe5 >>> 13, Je4 = m2[6] | 0, wt4 = Je4 & 8191, xt5 = Je4 >>> 13, Ge3 = m2[7] | 0, Mt5 = Ge3 & 8191, Et5 = Ge3 >>> 13, Ye3 = m2[8] | 0, St5 = Ye3 & 8191, It4 = Ye3 >>> 13, Ve2 = m2[9] | 0, Nt5 = Ve2 & 8191, _t4 = Ve2 >>> 13;
      c7.negative = f6.negative ^ a5.negative, c7.length = 19, l7 = Math.imul(u4, ut5), s2 = Math.imul(u4, ht5), s2 = s2 + Math.imul(E6, ut5) | 0, g4 = Math.imul(E6, ht5);
      var Me2 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (Me2 >>> 26) | 0, Me2 &= 67108863, l7 = Math.imul(B5, ut5), s2 = Math.imul(B5, ht5), s2 = s2 + Math.imul(R6, ut5) | 0, g4 = Math.imul(R6, ht5), l7 = l7 + Math.imul(u4, ct4) | 0, s2 = s2 + Math.imul(u4, lt5) | 0, s2 = s2 + Math.imul(E6, ct4) | 0, g4 = g4 + Math.imul(E6, lt5) | 0;
      var Ee5 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (Ee5 >>> 26) | 0, Ee5 &= 67108863, l7 = Math.imul(P5, ut5), s2 = Math.imul(P5, ht5), s2 = s2 + Math.imul(O8, ut5) | 0, g4 = Math.imul(O8, ht5), l7 = l7 + Math.imul(B5, ct4) | 0, s2 = s2 + Math.imul(B5, lt5) | 0, s2 = s2 + Math.imul(R6, ct4) | 0, g4 = g4 + Math.imul(R6, lt5) | 0, l7 = l7 + Math.imul(u4, dt5) | 0, s2 = s2 + Math.imul(u4, pt5) | 0, s2 = s2 + Math.imul(E6, dt5) | 0, g4 = g4 + Math.imul(E6, pt5) | 0;
      var Se3 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (Se3 >>> 26) | 0, Se3 &= 67108863, l7 = Math.imul(T4, ut5), s2 = Math.imul(T4, ht5), s2 = s2 + Math.imul(q4, ut5) | 0, g4 = Math.imul(q4, ht5), l7 = l7 + Math.imul(P5, ct4) | 0, s2 = s2 + Math.imul(P5, lt5) | 0, s2 = s2 + Math.imul(O8, ct4) | 0, g4 = g4 + Math.imul(O8, lt5) | 0, l7 = l7 + Math.imul(B5, dt5) | 0, s2 = s2 + Math.imul(B5, pt5) | 0, s2 = s2 + Math.imul(R6, dt5) | 0, g4 = g4 + Math.imul(R6, pt5) | 0, l7 = l7 + Math.imul(u4, vt3) | 0, s2 = s2 + Math.imul(u4, gt4) | 0, s2 = s2 + Math.imul(E6, vt3) | 0, g4 = g4 + Math.imul(E6, gt4) | 0;
      var Ie4 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (Ie4 >>> 26) | 0, Ie4 &= 67108863, l7 = Math.imul(X2, ut5), s2 = Math.imul(X2, ht5), s2 = s2 + Math.imul($5, ut5) | 0, g4 = Math.imul($5, ht5), l7 = l7 + Math.imul(T4, ct4) | 0, s2 = s2 + Math.imul(T4, lt5) | 0, s2 = s2 + Math.imul(q4, ct4) | 0, g4 = g4 + Math.imul(q4, lt5) | 0, l7 = l7 + Math.imul(P5, dt5) | 0, s2 = s2 + Math.imul(P5, pt5) | 0, s2 = s2 + Math.imul(O8, dt5) | 0, g4 = g4 + Math.imul(O8, pt5) | 0, l7 = l7 + Math.imul(B5, vt3) | 0, s2 = s2 + Math.imul(B5, gt4) | 0, s2 = s2 + Math.imul(R6, vt3) | 0, g4 = g4 + Math.imul(R6, gt4) | 0, l7 = l7 + Math.imul(u4, mt4) | 0, s2 = s2 + Math.imul(u4, At5) | 0, s2 = s2 + Math.imul(E6, mt4) | 0, g4 = g4 + Math.imul(E6, At5) | 0;
      var Ne = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (Ne >>> 26) | 0, Ne &= 67108863, l7 = Math.imul(Z5, ut5), s2 = Math.imul(Z5, ht5), s2 = s2 + Math.imul(tt6, ut5) | 0, g4 = Math.imul(tt6, ht5), l7 = l7 + Math.imul(X2, ct4) | 0, s2 = s2 + Math.imul(X2, lt5) | 0, s2 = s2 + Math.imul($5, ct4) | 0, g4 = g4 + Math.imul($5, lt5) | 0, l7 = l7 + Math.imul(T4, dt5) | 0, s2 = s2 + Math.imul(T4, pt5) | 0, s2 = s2 + Math.imul(q4, dt5) | 0, g4 = g4 + Math.imul(q4, pt5) | 0, l7 = l7 + Math.imul(P5, vt3) | 0, s2 = s2 + Math.imul(P5, gt4) | 0, s2 = s2 + Math.imul(O8, vt3) | 0, g4 = g4 + Math.imul(O8, gt4) | 0, l7 = l7 + Math.imul(B5, mt4) | 0, s2 = s2 + Math.imul(B5, At5) | 0, s2 = s2 + Math.imul(R6, mt4) | 0, g4 = g4 + Math.imul(R6, At5) | 0, l7 = l7 + Math.imul(u4, bt4) | 0, s2 = s2 + Math.imul(u4, yt4) | 0, s2 = s2 + Math.imul(E6, bt4) | 0, g4 = g4 + Math.imul(E6, yt4) | 0;
      var Zr4 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (Zr4 >>> 26) | 0, Zr4 &= 67108863, l7 = Math.imul(et5, ut5), s2 = Math.imul(et5, ht5), s2 = s2 + Math.imul(rt4, ut5) | 0, g4 = Math.imul(rt4, ht5), l7 = l7 + Math.imul(Z5, ct4) | 0, s2 = s2 + Math.imul(Z5, lt5) | 0, s2 = s2 + Math.imul(tt6, ct4) | 0, g4 = g4 + Math.imul(tt6, lt5) | 0, l7 = l7 + Math.imul(X2, dt5) | 0, s2 = s2 + Math.imul(X2, pt5) | 0, s2 = s2 + Math.imul($5, dt5) | 0, g4 = g4 + Math.imul($5, pt5) | 0, l7 = l7 + Math.imul(T4, vt3) | 0, s2 = s2 + Math.imul(T4, gt4) | 0, s2 = s2 + Math.imul(q4, vt3) | 0, g4 = g4 + Math.imul(q4, gt4) | 0, l7 = l7 + Math.imul(P5, mt4) | 0, s2 = s2 + Math.imul(P5, At5) | 0, s2 = s2 + Math.imul(O8, mt4) | 0, g4 = g4 + Math.imul(O8, At5) | 0, l7 = l7 + Math.imul(B5, bt4) | 0, s2 = s2 + Math.imul(B5, yt4) | 0, s2 = s2 + Math.imul(R6, bt4) | 0, g4 = g4 + Math.imul(R6, yt4) | 0, l7 = l7 + Math.imul(u4, wt4) | 0, s2 = s2 + Math.imul(u4, xt5) | 0, s2 = s2 + Math.imul(E6, wt4) | 0, g4 = g4 + Math.imul(E6, xt5) | 0;
      var ti3 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (ti3 >>> 26) | 0, ti3 &= 67108863, l7 = Math.imul(it5, ut5), s2 = Math.imul(it5, ht5), s2 = s2 + Math.imul(nt5, ut5) | 0, g4 = Math.imul(nt5, ht5), l7 = l7 + Math.imul(et5, ct4) | 0, s2 = s2 + Math.imul(et5, lt5) | 0, s2 = s2 + Math.imul(rt4, ct4) | 0, g4 = g4 + Math.imul(rt4, lt5) | 0, l7 = l7 + Math.imul(Z5, dt5) | 0, s2 = s2 + Math.imul(Z5, pt5) | 0, s2 = s2 + Math.imul(tt6, dt5) | 0, g4 = g4 + Math.imul(tt6, pt5) | 0, l7 = l7 + Math.imul(X2, vt3) | 0, s2 = s2 + Math.imul(X2, gt4) | 0, s2 = s2 + Math.imul($5, vt3) | 0, g4 = g4 + Math.imul($5, gt4) | 0, l7 = l7 + Math.imul(T4, mt4) | 0, s2 = s2 + Math.imul(T4, At5) | 0, s2 = s2 + Math.imul(q4, mt4) | 0, g4 = g4 + Math.imul(q4, At5) | 0, l7 = l7 + Math.imul(P5, bt4) | 0, s2 = s2 + Math.imul(P5, yt4) | 0, s2 = s2 + Math.imul(O8, bt4) | 0, g4 = g4 + Math.imul(O8, yt4) | 0, l7 = l7 + Math.imul(B5, wt4) | 0, s2 = s2 + Math.imul(B5, xt5) | 0, s2 = s2 + Math.imul(R6, wt4) | 0, g4 = g4 + Math.imul(R6, xt5) | 0, l7 = l7 + Math.imul(u4, Mt5) | 0, s2 = s2 + Math.imul(u4, Et5) | 0, s2 = s2 + Math.imul(E6, Mt5) | 0, g4 = g4 + Math.imul(E6, Et5) | 0;
      var ei4 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (ei4 >>> 26) | 0, ei4 &= 67108863, l7 = Math.imul(ft4, ut5), s2 = Math.imul(ft4, ht5), s2 = s2 + Math.imul(ot5, ut5) | 0, g4 = Math.imul(ot5, ht5), l7 = l7 + Math.imul(it5, ct4) | 0, s2 = s2 + Math.imul(it5, lt5) | 0, s2 = s2 + Math.imul(nt5, ct4) | 0, g4 = g4 + Math.imul(nt5, lt5) | 0, l7 = l7 + Math.imul(et5, dt5) | 0, s2 = s2 + Math.imul(et5, pt5) | 0, s2 = s2 + Math.imul(rt4, dt5) | 0, g4 = g4 + Math.imul(rt4, pt5) | 0, l7 = l7 + Math.imul(Z5, vt3) | 0, s2 = s2 + Math.imul(Z5, gt4) | 0, s2 = s2 + Math.imul(tt6, vt3) | 0, g4 = g4 + Math.imul(tt6, gt4) | 0, l7 = l7 + Math.imul(X2, mt4) | 0, s2 = s2 + Math.imul(X2, At5) | 0, s2 = s2 + Math.imul($5, mt4) | 0, g4 = g4 + Math.imul($5, At5) | 0, l7 = l7 + Math.imul(T4, bt4) | 0, s2 = s2 + Math.imul(T4, yt4) | 0, s2 = s2 + Math.imul(q4, bt4) | 0, g4 = g4 + Math.imul(q4, yt4) | 0, l7 = l7 + Math.imul(P5, wt4) | 0, s2 = s2 + Math.imul(P5, xt5) | 0, s2 = s2 + Math.imul(O8, wt4) | 0, g4 = g4 + Math.imul(O8, xt5) | 0, l7 = l7 + Math.imul(B5, Mt5) | 0, s2 = s2 + Math.imul(B5, Et5) | 0, s2 = s2 + Math.imul(R6, Mt5) | 0, g4 = g4 + Math.imul(R6, Et5) | 0, l7 = l7 + Math.imul(u4, St5) | 0, s2 = s2 + Math.imul(u4, It4) | 0, s2 = s2 + Math.imul(E6, St5) | 0, g4 = g4 + Math.imul(E6, It4) | 0;
      var ri4 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (ri4 >>> 26) | 0, ri4 &= 67108863, l7 = Math.imul(st5, ut5), s2 = Math.imul(st5, ht5), s2 = s2 + Math.imul(at4, ut5) | 0, g4 = Math.imul(at4, ht5), l7 = l7 + Math.imul(ft4, ct4) | 0, s2 = s2 + Math.imul(ft4, lt5) | 0, s2 = s2 + Math.imul(ot5, ct4) | 0, g4 = g4 + Math.imul(ot5, lt5) | 0, l7 = l7 + Math.imul(it5, dt5) | 0, s2 = s2 + Math.imul(it5, pt5) | 0, s2 = s2 + Math.imul(nt5, dt5) | 0, g4 = g4 + Math.imul(nt5, pt5) | 0, l7 = l7 + Math.imul(et5, vt3) | 0, s2 = s2 + Math.imul(et5, gt4) | 0, s2 = s2 + Math.imul(rt4, vt3) | 0, g4 = g4 + Math.imul(rt4, gt4) | 0, l7 = l7 + Math.imul(Z5, mt4) | 0, s2 = s2 + Math.imul(Z5, At5) | 0, s2 = s2 + Math.imul(tt6, mt4) | 0, g4 = g4 + Math.imul(tt6, At5) | 0, l7 = l7 + Math.imul(X2, bt4) | 0, s2 = s2 + Math.imul(X2, yt4) | 0, s2 = s2 + Math.imul($5, bt4) | 0, g4 = g4 + Math.imul($5, yt4) | 0, l7 = l7 + Math.imul(T4, wt4) | 0, s2 = s2 + Math.imul(T4, xt5) | 0, s2 = s2 + Math.imul(q4, wt4) | 0, g4 = g4 + Math.imul(q4, xt5) | 0, l7 = l7 + Math.imul(P5, Mt5) | 0, s2 = s2 + Math.imul(P5, Et5) | 0, s2 = s2 + Math.imul(O8, Mt5) | 0, g4 = g4 + Math.imul(O8, Et5) | 0, l7 = l7 + Math.imul(B5, St5) | 0, s2 = s2 + Math.imul(B5, It4) | 0, s2 = s2 + Math.imul(R6, St5) | 0, g4 = g4 + Math.imul(R6, It4) | 0, l7 = l7 + Math.imul(u4, Nt5) | 0, s2 = s2 + Math.imul(u4, _t4) | 0, s2 = s2 + Math.imul(E6, Nt5) | 0, g4 = g4 + Math.imul(E6, _t4) | 0;
      var ii3 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (ii3 >>> 26) | 0, ii3 &= 67108863, l7 = Math.imul(st5, ct4), s2 = Math.imul(st5, lt5), s2 = s2 + Math.imul(at4, ct4) | 0, g4 = Math.imul(at4, lt5), l7 = l7 + Math.imul(ft4, dt5) | 0, s2 = s2 + Math.imul(ft4, pt5) | 0, s2 = s2 + Math.imul(ot5, dt5) | 0, g4 = g4 + Math.imul(ot5, pt5) | 0, l7 = l7 + Math.imul(it5, vt3) | 0, s2 = s2 + Math.imul(it5, gt4) | 0, s2 = s2 + Math.imul(nt5, vt3) | 0, g4 = g4 + Math.imul(nt5, gt4) | 0, l7 = l7 + Math.imul(et5, mt4) | 0, s2 = s2 + Math.imul(et5, At5) | 0, s2 = s2 + Math.imul(rt4, mt4) | 0, g4 = g4 + Math.imul(rt4, At5) | 0, l7 = l7 + Math.imul(Z5, bt4) | 0, s2 = s2 + Math.imul(Z5, yt4) | 0, s2 = s2 + Math.imul(tt6, bt4) | 0, g4 = g4 + Math.imul(tt6, yt4) | 0, l7 = l7 + Math.imul(X2, wt4) | 0, s2 = s2 + Math.imul(X2, xt5) | 0, s2 = s2 + Math.imul($5, wt4) | 0, g4 = g4 + Math.imul($5, xt5) | 0, l7 = l7 + Math.imul(T4, Mt5) | 0, s2 = s2 + Math.imul(T4, Et5) | 0, s2 = s2 + Math.imul(q4, Mt5) | 0, g4 = g4 + Math.imul(q4, Et5) | 0, l7 = l7 + Math.imul(P5, St5) | 0, s2 = s2 + Math.imul(P5, It4) | 0, s2 = s2 + Math.imul(O8, St5) | 0, g4 = g4 + Math.imul(O8, It4) | 0, l7 = l7 + Math.imul(B5, Nt5) | 0, s2 = s2 + Math.imul(B5, _t4) | 0, s2 = s2 + Math.imul(R6, Nt5) | 0, g4 = g4 + Math.imul(R6, _t4) | 0;
      var ni4 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (ni4 >>> 26) | 0, ni4 &= 67108863, l7 = Math.imul(st5, dt5), s2 = Math.imul(st5, pt5), s2 = s2 + Math.imul(at4, dt5) | 0, g4 = Math.imul(at4, pt5), l7 = l7 + Math.imul(ft4, vt3) | 0, s2 = s2 + Math.imul(ft4, gt4) | 0, s2 = s2 + Math.imul(ot5, vt3) | 0, g4 = g4 + Math.imul(ot5, gt4) | 0, l7 = l7 + Math.imul(it5, mt4) | 0, s2 = s2 + Math.imul(it5, At5) | 0, s2 = s2 + Math.imul(nt5, mt4) | 0, g4 = g4 + Math.imul(nt5, At5) | 0, l7 = l7 + Math.imul(et5, bt4) | 0, s2 = s2 + Math.imul(et5, yt4) | 0, s2 = s2 + Math.imul(rt4, bt4) | 0, g4 = g4 + Math.imul(rt4, yt4) | 0, l7 = l7 + Math.imul(Z5, wt4) | 0, s2 = s2 + Math.imul(Z5, xt5) | 0, s2 = s2 + Math.imul(tt6, wt4) | 0, g4 = g4 + Math.imul(tt6, xt5) | 0, l7 = l7 + Math.imul(X2, Mt5) | 0, s2 = s2 + Math.imul(X2, Et5) | 0, s2 = s2 + Math.imul($5, Mt5) | 0, g4 = g4 + Math.imul($5, Et5) | 0, l7 = l7 + Math.imul(T4, St5) | 0, s2 = s2 + Math.imul(T4, It4) | 0, s2 = s2 + Math.imul(q4, St5) | 0, g4 = g4 + Math.imul(q4, It4) | 0, l7 = l7 + Math.imul(P5, Nt5) | 0, s2 = s2 + Math.imul(P5, _t4) | 0, s2 = s2 + Math.imul(O8, Nt5) | 0, g4 = g4 + Math.imul(O8, _t4) | 0;
      var fi4 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (fi4 >>> 26) | 0, fi4 &= 67108863, l7 = Math.imul(st5, vt3), s2 = Math.imul(st5, gt4), s2 = s2 + Math.imul(at4, vt3) | 0, g4 = Math.imul(at4, gt4), l7 = l7 + Math.imul(ft4, mt4) | 0, s2 = s2 + Math.imul(ft4, At5) | 0, s2 = s2 + Math.imul(ot5, mt4) | 0, g4 = g4 + Math.imul(ot5, At5) | 0, l7 = l7 + Math.imul(it5, bt4) | 0, s2 = s2 + Math.imul(it5, yt4) | 0, s2 = s2 + Math.imul(nt5, bt4) | 0, g4 = g4 + Math.imul(nt5, yt4) | 0, l7 = l7 + Math.imul(et5, wt4) | 0, s2 = s2 + Math.imul(et5, xt5) | 0, s2 = s2 + Math.imul(rt4, wt4) | 0, g4 = g4 + Math.imul(rt4, xt5) | 0, l7 = l7 + Math.imul(Z5, Mt5) | 0, s2 = s2 + Math.imul(Z5, Et5) | 0, s2 = s2 + Math.imul(tt6, Mt5) | 0, g4 = g4 + Math.imul(tt6, Et5) | 0, l7 = l7 + Math.imul(X2, St5) | 0, s2 = s2 + Math.imul(X2, It4) | 0, s2 = s2 + Math.imul($5, St5) | 0, g4 = g4 + Math.imul($5, It4) | 0, l7 = l7 + Math.imul(T4, Nt5) | 0, s2 = s2 + Math.imul(T4, _t4) | 0, s2 = s2 + Math.imul(q4, Nt5) | 0, g4 = g4 + Math.imul(q4, _t4) | 0;
      var oi3 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (oi3 >>> 26) | 0, oi3 &= 67108863, l7 = Math.imul(st5, mt4), s2 = Math.imul(st5, At5), s2 = s2 + Math.imul(at4, mt4) | 0, g4 = Math.imul(at4, At5), l7 = l7 + Math.imul(ft4, bt4) | 0, s2 = s2 + Math.imul(ft4, yt4) | 0, s2 = s2 + Math.imul(ot5, bt4) | 0, g4 = g4 + Math.imul(ot5, yt4) | 0, l7 = l7 + Math.imul(it5, wt4) | 0, s2 = s2 + Math.imul(it5, xt5) | 0, s2 = s2 + Math.imul(nt5, wt4) | 0, g4 = g4 + Math.imul(nt5, xt5) | 0, l7 = l7 + Math.imul(et5, Mt5) | 0, s2 = s2 + Math.imul(et5, Et5) | 0, s2 = s2 + Math.imul(rt4, Mt5) | 0, g4 = g4 + Math.imul(rt4, Et5) | 0, l7 = l7 + Math.imul(Z5, St5) | 0, s2 = s2 + Math.imul(Z5, It4) | 0, s2 = s2 + Math.imul(tt6, St5) | 0, g4 = g4 + Math.imul(tt6, It4) | 0, l7 = l7 + Math.imul(X2, Nt5) | 0, s2 = s2 + Math.imul(X2, _t4) | 0, s2 = s2 + Math.imul($5, Nt5) | 0, g4 = g4 + Math.imul($5, _t4) | 0;
      var si4 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (si4 >>> 26) | 0, si4 &= 67108863, l7 = Math.imul(st5, bt4), s2 = Math.imul(st5, yt4), s2 = s2 + Math.imul(at4, bt4) | 0, g4 = Math.imul(at4, yt4), l7 = l7 + Math.imul(ft4, wt4) | 0, s2 = s2 + Math.imul(ft4, xt5) | 0, s2 = s2 + Math.imul(ot5, wt4) | 0, g4 = g4 + Math.imul(ot5, xt5) | 0, l7 = l7 + Math.imul(it5, Mt5) | 0, s2 = s2 + Math.imul(it5, Et5) | 0, s2 = s2 + Math.imul(nt5, Mt5) | 0, g4 = g4 + Math.imul(nt5, Et5) | 0, l7 = l7 + Math.imul(et5, St5) | 0, s2 = s2 + Math.imul(et5, It4) | 0, s2 = s2 + Math.imul(rt4, St5) | 0, g4 = g4 + Math.imul(rt4, It4) | 0, l7 = l7 + Math.imul(Z5, Nt5) | 0, s2 = s2 + Math.imul(Z5, _t4) | 0, s2 = s2 + Math.imul(tt6, Nt5) | 0, g4 = g4 + Math.imul(tt6, _t4) | 0;
      var ai3 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (ai3 >>> 26) | 0, ai3 &= 67108863, l7 = Math.imul(st5, wt4), s2 = Math.imul(st5, xt5), s2 = s2 + Math.imul(at4, wt4) | 0, g4 = Math.imul(at4, xt5), l7 = l7 + Math.imul(ft4, Mt5) | 0, s2 = s2 + Math.imul(ft4, Et5) | 0, s2 = s2 + Math.imul(ot5, Mt5) | 0, g4 = g4 + Math.imul(ot5, Et5) | 0, l7 = l7 + Math.imul(it5, St5) | 0, s2 = s2 + Math.imul(it5, It4) | 0, s2 = s2 + Math.imul(nt5, St5) | 0, g4 = g4 + Math.imul(nt5, It4) | 0, l7 = l7 + Math.imul(et5, Nt5) | 0, s2 = s2 + Math.imul(et5, _t4) | 0, s2 = s2 + Math.imul(rt4, Nt5) | 0, g4 = g4 + Math.imul(rt4, _t4) | 0;
      var ui3 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (ui3 >>> 26) | 0, ui3 &= 67108863, l7 = Math.imul(st5, Mt5), s2 = Math.imul(st5, Et5), s2 = s2 + Math.imul(at4, Mt5) | 0, g4 = Math.imul(at4, Et5), l7 = l7 + Math.imul(ft4, St5) | 0, s2 = s2 + Math.imul(ft4, It4) | 0, s2 = s2 + Math.imul(ot5, St5) | 0, g4 = g4 + Math.imul(ot5, It4) | 0, l7 = l7 + Math.imul(it5, Nt5) | 0, s2 = s2 + Math.imul(it5, _t4) | 0, s2 = s2 + Math.imul(nt5, Nt5) | 0, g4 = g4 + Math.imul(nt5, _t4) | 0;
      var hi3 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (hi3 >>> 26) | 0, hi3 &= 67108863, l7 = Math.imul(st5, St5), s2 = Math.imul(st5, It4), s2 = s2 + Math.imul(at4, St5) | 0, g4 = Math.imul(at4, It4), l7 = l7 + Math.imul(ft4, Nt5) | 0, s2 = s2 + Math.imul(ft4, _t4) | 0, s2 = s2 + Math.imul(ot5, Nt5) | 0, g4 = g4 + Math.imul(ot5, _t4) | 0;
      var ci3 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      M6 = (g4 + (s2 >>> 13) | 0) + (ci3 >>> 26) | 0, ci3 &= 67108863, l7 = Math.imul(st5, Nt5), s2 = Math.imul(st5, _t4), s2 = s2 + Math.imul(at4, Nt5) | 0, g4 = Math.imul(at4, _t4);
      var li4 = (M6 + l7 | 0) + ((s2 & 8191) << 13) | 0;
      return M6 = (g4 + (s2 >>> 13) | 0) + (li4 >>> 26) | 0, li4 &= 67108863, x7[0] = Me2, x7[1] = Ee5, x7[2] = Se3, x7[3] = Ie4, x7[4] = Ne, x7[5] = Zr4, x7[6] = ti3, x7[7] = ei4, x7[8] = ri4, x7[9] = ii3, x7[10] = ni4, x7[11] = fi4, x7[12] = oi3, x7[13] = si4, x7[14] = ai3, x7[15] = ui3, x7[16] = hi3, x7[17] = ci3, x7[18] = li4, M6 !== 0 && (x7[19] = M6, c7.length++), c7;
    };
    Math.imul || (J2 = U5);
    function Bt5(b6, f6, a5) {
      a5.negative = f6.negative ^ b6.negative, a5.length = b6.length + f6.length;
      for (var c7 = 0, d5 = 0, m2 = 0; m2 < a5.length - 1; m2++) {
        var x7 = d5;
        d5 = 0;
        for (var M6 = c7 & 67108863, l7 = Math.min(m2, f6.length - 1), s2 = Math.max(0, m2 - b6.length + 1); s2 <= l7; s2++) {
          var g4 = m2 - s2, k6 = b6.words[g4] | 0, u4 = f6.words[s2] | 0, E6 = k6 * u4, _5 = E6 & 67108863;
          x7 = x7 + (E6 / 67108864 | 0) | 0, _5 = _5 + M6 | 0, M6 = _5 & 67108863, x7 = x7 + (_5 >>> 26) | 0, d5 += x7 >>> 26, x7 &= 67108863;
        }
        a5.words[m2] = M6, c7 = x7, x7 = d5;
      }
      return c7 !== 0 ? a5.words[m2] = c7 : a5.length--, a5._strip();
    }
    function G5(b6, f6, a5) {
      return Bt5(b6, f6, a5);
    }
    o4.prototype.mulTo = function(f6, a5) {
      var c7, d5 = this.length + f6.length;
      return this.length === 10 && f6.length === 10 ? c7 = J2(this, f6, a5) : d5 < 63 ? c7 = U5(this, f6, a5) : d5 < 1024 ? c7 = Bt5(this, f6, a5) : c7 = G5(this, f6, a5), c7;
    }, o4.prototype.mul = function(f6) {
      var a5 = new o4(null);
      return a5.words = new Array(this.length + f6.length), this.mulTo(f6, a5);
    }, o4.prototype.mulf = function(f6) {
      var a5 = new o4(null);
      return a5.words = new Array(this.length + f6.length), G5(this, f6, a5);
    }, o4.prototype.imul = function(f6) {
      return this.clone().mulTo(f6, this);
    }, o4.prototype.imuln = function(f6) {
      var a5 = f6 < 0;
      a5 && (f6 = -f6), i3(typeof f6 == "number"), i3(f6 < 67108864);
      for (var c7 = 0, d5 = 0; d5 < this.length; d5++) {
        var m2 = (this.words[d5] | 0) * f6, x7 = (m2 & 67108863) + (c7 & 67108863);
        c7 >>= 26, c7 += m2 / 67108864 | 0, c7 += x7 >>> 26, this.words[d5] = x7 & 67108863;
      }
      return c7 !== 0 && (this.words[d5] = c7, this.length++), a5 ? this.ineg() : this;
    }, o4.prototype.muln = function(f6) {
      return this.clone().imuln(f6);
    }, o4.prototype.sqr = function() {
      return this.mul(this);
    }, o4.prototype.isqr = function() {
      return this.imul(this.clone());
    }, o4.prototype.pow = function(f6) {
      var a5 = D5(f6);
      if (a5.length === 0) return new o4(1);
      for (var c7 = this, d5 = 0; d5 < a5.length && a5[d5] === 0; d5++, c7 = c7.sqr()) ;
      if (++d5 < a5.length) for (var m2 = c7.sqr(); d5 < a5.length; d5++, m2 = m2.sqr()) a5[d5] !== 0 && (c7 = c7.mul(m2));
      return c7;
    }, o4.prototype.iushln = function(f6) {
      i3(typeof f6 == "number" && f6 >= 0);
      var a5 = f6 % 26, c7 = (f6 - a5) / 26, d5 = 67108863 >>> 26 - a5 << 26 - a5, m2;
      if (a5 !== 0) {
        var x7 = 0;
        for (m2 = 0; m2 < this.length; m2++) {
          var M6 = this.words[m2] & d5, l7 = (this.words[m2] | 0) - M6 << a5;
          this.words[m2] = l7 | x7, x7 = M6 >>> 26 - a5;
        }
        x7 && (this.words[m2] = x7, this.length++);
      }
      if (c7 !== 0) {
        for (m2 = this.length - 1; m2 >= 0; m2--) this.words[m2 + c7] = this.words[m2];
        for (m2 = 0; m2 < c7; m2++) this.words[m2] = 0;
        this.length += c7;
      }
      return this._strip();
    }, o4.prototype.ishln = function(f6) {
      return i3(this.negative === 0), this.iushln(f6);
    }, o4.prototype.iushrn = function(f6, a5, c7) {
      i3(typeof f6 == "number" && f6 >= 0);
      var d5;
      a5 ? d5 = (a5 - a5 % 26) / 26 : d5 = 0;
      var m2 = f6 % 26, x7 = Math.min((f6 - m2) / 26, this.length), M6 = 67108863 ^ 67108863 >>> m2 << m2, l7 = c7;
      if (d5 -= x7, d5 = Math.max(0, d5), l7) {
        for (var s2 = 0; s2 < x7; s2++) l7.words[s2] = this.words[s2];
        l7.length = x7;
      }
      if (x7 !== 0) if (this.length > x7) for (this.length -= x7, s2 = 0; s2 < this.length; s2++) this.words[s2] = this.words[s2 + x7];
      else this.words[0] = 0, this.length = 1;
      var g4 = 0;
      for (s2 = this.length - 1; s2 >= 0 && (g4 !== 0 || s2 >= d5); s2--) {
        var k6 = this.words[s2] | 0;
        this.words[s2] = g4 << 26 - m2 | k6 >>> m2, g4 = k6 & M6;
      }
      return l7 && g4 !== 0 && (l7.words[l7.length++] = g4), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, o4.prototype.ishrn = function(f6, a5, c7) {
      return i3(this.negative === 0), this.iushrn(f6, a5, c7);
    }, o4.prototype.shln = function(f6) {
      return this.clone().ishln(f6);
    }, o4.prototype.ushln = function(f6) {
      return this.clone().iushln(f6);
    }, o4.prototype.shrn = function(f6) {
      return this.clone().ishrn(f6);
    }, o4.prototype.ushrn = function(f6) {
      return this.clone().iushrn(f6);
    }, o4.prototype.testn = function(f6) {
      i3(typeof f6 == "number" && f6 >= 0);
      var a5 = f6 % 26, c7 = (f6 - a5) / 26, d5 = 1 << a5;
      if (this.length <= c7) return false;
      var m2 = this.words[c7];
      return !!(m2 & d5);
    }, o4.prototype.imaskn = function(f6) {
      i3(typeof f6 == "number" && f6 >= 0);
      var a5 = f6 % 26, c7 = (f6 - a5) / 26;
      if (i3(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c7) return this;
      if (a5 !== 0 && c7++, this.length = Math.min(c7, this.length), a5 !== 0) {
        var d5 = 67108863 ^ 67108863 >>> a5 << a5;
        this.words[this.length - 1] &= d5;
      }
      return this._strip();
    }, o4.prototype.maskn = function(f6) {
      return this.clone().imaskn(f6);
    }, o4.prototype.iaddn = function(f6) {
      return i3(typeof f6 == "number"), i3(f6 < 67108864), f6 < 0 ? this.isubn(-f6) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f6 ? (this.words[0] = f6 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f6), this.negative = 1, this) : this._iaddn(f6);
    }, o4.prototype._iaddn = function(f6) {
      this.words[0] += f6;
      for (var a5 = 0; a5 < this.length && this.words[a5] >= 67108864; a5++) this.words[a5] -= 67108864, a5 === this.length - 1 ? this.words[a5 + 1] = 1 : this.words[a5 + 1]++;
      return this.length = Math.max(this.length, a5 + 1), this;
    }, o4.prototype.isubn = function(f6) {
      if (i3(typeof f6 == "number"), i3(f6 < 67108864), f6 < 0) return this.iaddn(-f6);
      if (this.negative !== 0) return this.negative = 0, this.iaddn(f6), this.negative = 1, this;
      if (this.words[0] -= f6, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
      else for (var a5 = 0; a5 < this.length && this.words[a5] < 0; a5++) this.words[a5] += 67108864, this.words[a5 + 1] -= 1;
      return this._strip();
    }, o4.prototype.addn = function(f6) {
      return this.clone().iaddn(f6);
    }, o4.prototype.subn = function(f6) {
      return this.clone().isubn(f6);
    }, o4.prototype.iabs = function() {
      return this.negative = 0, this;
    }, o4.prototype.abs = function() {
      return this.clone().iabs();
    }, o4.prototype._ishlnsubmul = function(f6, a5, c7) {
      var d5 = f6.length + c7, m2;
      this._expand(d5);
      var x7, M6 = 0;
      for (m2 = 0; m2 < f6.length; m2++) {
        x7 = (this.words[m2 + c7] | 0) + M6;
        var l7 = (f6.words[m2] | 0) * a5;
        x7 -= l7 & 67108863, M6 = (x7 >> 26) - (l7 / 67108864 | 0), this.words[m2 + c7] = x7 & 67108863;
      }
      for (; m2 < this.length - c7; m2++) x7 = (this.words[m2 + c7] | 0) + M6, M6 = x7 >> 26, this.words[m2 + c7] = x7 & 67108863;
      if (M6 === 0) return this._strip();
      for (i3(M6 === -1), M6 = 0, m2 = 0; m2 < this.length; m2++) x7 = -(this.words[m2] | 0) + M6, M6 = x7 >> 26, this.words[m2] = x7 & 67108863;
      return this.negative = 1, this._strip();
    }, o4.prototype._wordDiv = function(f6, a5) {
      var c7 = this.length - f6.length, d5 = this.clone(), m2 = f6, x7 = m2.words[m2.length - 1] | 0, M6 = this._countBits(x7);
      c7 = 26 - M6, c7 !== 0 && (m2 = m2.ushln(c7), d5.iushln(c7), x7 = m2.words[m2.length - 1] | 0);
      var l7 = d5.length - m2.length, s2;
      if (a5 !== "mod") {
        s2 = new o4(null), s2.length = l7 + 1, s2.words = new Array(s2.length);
        for (var g4 = 0; g4 < s2.length; g4++) s2.words[g4] = 0;
      }
      var k6 = d5.clone()._ishlnsubmul(m2, 1, l7);
      k6.negative === 0 && (d5 = k6, s2 && (s2.words[l7] = 1));
      for (var u4 = l7 - 1; u4 >= 0; u4--) {
        var E6 = (d5.words[m2.length + u4] | 0) * 67108864 + (d5.words[m2.length + u4 - 1] | 0);
        for (E6 = Math.min(E6 / x7 | 0, 67108863), d5._ishlnsubmul(m2, E6, u4); d5.negative !== 0; ) E6--, d5.negative = 0, d5._ishlnsubmul(m2, 1, u4), d5.isZero() || (d5.negative ^= 1);
        s2 && (s2.words[u4] = E6);
      }
      return s2 && s2._strip(), d5._strip(), a5 !== "div" && c7 !== 0 && d5.iushrn(c7), { div: s2 || null, mod: d5 };
    }, o4.prototype.divmod = function(f6, a5, c7) {
      if (i3(!f6.isZero()), this.isZero()) return { div: new o4(0), mod: new o4(0) };
      var d5, m2, x7;
      return this.negative !== 0 && f6.negative === 0 ? (x7 = this.neg().divmod(f6, a5), a5 !== "mod" && (d5 = x7.div.neg()), a5 !== "div" && (m2 = x7.mod.neg(), c7 && m2.negative !== 0 && m2.iadd(f6)), { div: d5, mod: m2 }) : this.negative === 0 && f6.negative !== 0 ? (x7 = this.divmod(f6.neg(), a5), a5 !== "mod" && (d5 = x7.div.neg()), { div: d5, mod: x7.mod }) : this.negative & f6.negative ? (x7 = this.neg().divmod(f6.neg(), a5), a5 !== "div" && (m2 = x7.mod.neg(), c7 && m2.negative !== 0 && m2.isub(f6)), { div: x7.div, mod: m2 }) : f6.length > this.length || this.cmp(f6) < 0 ? { div: new o4(0), mod: this } : f6.length === 1 ? a5 === "div" ? { div: this.divn(f6.words[0]), mod: null } : a5 === "mod" ? { div: null, mod: new o4(this.modrn(f6.words[0])) } : { div: this.divn(f6.words[0]), mod: new o4(this.modrn(f6.words[0])) } : this._wordDiv(f6, a5);
    }, o4.prototype.div = function(f6) {
      return this.divmod(f6, "div", false).div;
    }, o4.prototype.mod = function(f6) {
      return this.divmod(f6, "mod", false).mod;
    }, o4.prototype.umod = function(f6) {
      return this.divmod(f6, "mod", true).mod;
    }, o4.prototype.divRound = function(f6) {
      var a5 = this.divmod(f6);
      if (a5.mod.isZero()) return a5.div;
      var c7 = a5.div.negative !== 0 ? a5.mod.isub(f6) : a5.mod, d5 = f6.ushrn(1), m2 = f6.andln(1), x7 = c7.cmp(d5);
      return x7 < 0 || m2 === 1 && x7 === 0 ? a5.div : a5.div.negative !== 0 ? a5.div.isubn(1) : a5.div.iaddn(1);
    }, o4.prototype.modrn = function(f6) {
      var a5 = f6 < 0;
      a5 && (f6 = -f6), i3(f6 <= 67108863);
      for (var c7 = (1 << 26) % f6, d5 = 0, m2 = this.length - 1; m2 >= 0; m2--) d5 = (c7 * d5 + (this.words[m2] | 0)) % f6;
      return a5 ? -d5 : d5;
    }, o4.prototype.modn = function(f6) {
      return this.modrn(f6);
    }, o4.prototype.idivn = function(f6) {
      var a5 = f6 < 0;
      a5 && (f6 = -f6), i3(f6 <= 67108863);
      for (var c7 = 0, d5 = this.length - 1; d5 >= 0; d5--) {
        var m2 = (this.words[d5] | 0) + c7 * 67108864;
        this.words[d5] = m2 / f6 | 0, c7 = m2 % f6;
      }
      return this._strip(), a5 ? this.ineg() : this;
    }, o4.prototype.divn = function(f6) {
      return this.clone().idivn(f6);
    }, o4.prototype.egcd = function(f6) {
      i3(f6.negative === 0), i3(!f6.isZero());
      var a5 = this, c7 = f6.clone();
      a5.negative !== 0 ? a5 = a5.umod(f6) : a5 = a5.clone();
      for (var d5 = new o4(1), m2 = new o4(0), x7 = new o4(0), M6 = new o4(1), l7 = 0; a5.isEven() && c7.isEven(); ) a5.iushrn(1), c7.iushrn(1), ++l7;
      for (var s2 = c7.clone(), g4 = a5.clone(); !a5.isZero(); ) {
        for (var k6 = 0, u4 = 1; !(a5.words[0] & u4) && k6 < 26; ++k6, u4 <<= 1) ;
        if (k6 > 0) for (a5.iushrn(k6); k6-- > 0; ) (d5.isOdd() || m2.isOdd()) && (d5.iadd(s2), m2.isub(g4)), d5.iushrn(1), m2.iushrn(1);
        for (var E6 = 0, _5 = 1; !(c7.words[0] & _5) && E6 < 26; ++E6, _5 <<= 1) ;
        if (E6 > 0) for (c7.iushrn(E6); E6-- > 0; ) (x7.isOdd() || M6.isOdd()) && (x7.iadd(s2), M6.isub(g4)), x7.iushrn(1), M6.iushrn(1);
        a5.cmp(c7) >= 0 ? (a5.isub(c7), d5.isub(x7), m2.isub(M6)) : (c7.isub(a5), x7.isub(d5), M6.isub(m2));
      }
      return { a: x7, b: M6, gcd: c7.iushln(l7) };
    }, o4.prototype._invmp = function(f6) {
      i3(f6.negative === 0), i3(!f6.isZero());
      var a5 = this, c7 = f6.clone();
      a5.negative !== 0 ? a5 = a5.umod(f6) : a5 = a5.clone();
      for (var d5 = new o4(1), m2 = new o4(0), x7 = c7.clone(); a5.cmpn(1) > 0 && c7.cmpn(1) > 0; ) {
        for (var M6 = 0, l7 = 1; !(a5.words[0] & l7) && M6 < 26; ++M6, l7 <<= 1) ;
        if (M6 > 0) for (a5.iushrn(M6); M6-- > 0; ) d5.isOdd() && d5.iadd(x7), d5.iushrn(1);
        for (var s2 = 0, g4 = 1; !(c7.words[0] & g4) && s2 < 26; ++s2, g4 <<= 1) ;
        if (s2 > 0) for (c7.iushrn(s2); s2-- > 0; ) m2.isOdd() && m2.iadd(x7), m2.iushrn(1);
        a5.cmp(c7) >= 0 ? (a5.isub(c7), d5.isub(m2)) : (c7.isub(a5), m2.isub(d5));
      }
      var k6;
      return a5.cmpn(1) === 0 ? k6 = d5 : k6 = m2, k6.cmpn(0) < 0 && k6.iadd(f6), k6;
    }, o4.prototype.gcd = function(f6) {
      if (this.isZero()) return f6.abs();
      if (f6.isZero()) return this.abs();
      var a5 = this.clone(), c7 = f6.clone();
      a5.negative = 0, c7.negative = 0;
      for (var d5 = 0; a5.isEven() && c7.isEven(); d5++) a5.iushrn(1), c7.iushrn(1);
      do {
        for (; a5.isEven(); ) a5.iushrn(1);
        for (; c7.isEven(); ) c7.iushrn(1);
        var m2 = a5.cmp(c7);
        if (m2 < 0) {
          var x7 = a5;
          a5 = c7, c7 = x7;
        } else if (m2 === 0 || c7.cmpn(1) === 0) break;
        a5.isub(c7);
      } while (true);
      return c7.iushln(d5);
    }, o4.prototype.invm = function(f6) {
      return this.egcd(f6).a.umod(f6);
    }, o4.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, o4.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, o4.prototype.andln = function(f6) {
      return this.words[0] & f6;
    }, o4.prototype.bincn = function(f6) {
      i3(typeof f6 == "number");
      var a5 = f6 % 26, c7 = (f6 - a5) / 26, d5 = 1 << a5;
      if (this.length <= c7) return this._expand(c7 + 1), this.words[c7] |= d5, this;
      for (var m2 = d5, x7 = c7; m2 !== 0 && x7 < this.length; x7++) {
        var M6 = this.words[x7] | 0;
        M6 += m2, m2 = M6 >>> 26, M6 &= 67108863, this.words[x7] = M6;
      }
      return m2 !== 0 && (this.words[x7] = m2, this.length++), this;
    }, o4.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, o4.prototype.cmpn = function(f6) {
      var a5 = f6 < 0;
      if (this.negative !== 0 && !a5) return -1;
      if (this.negative === 0 && a5) return 1;
      this._strip();
      var c7;
      if (this.length > 1) c7 = 1;
      else {
        a5 && (f6 = -f6), i3(f6 <= 67108863, "Number is too big");
        var d5 = this.words[0] | 0;
        c7 = d5 === f6 ? 0 : d5 < f6 ? -1 : 1;
      }
      return this.negative !== 0 ? -c7 | 0 : c7;
    }, o4.prototype.cmp = function(f6) {
      if (this.negative !== 0 && f6.negative === 0) return -1;
      if (this.negative === 0 && f6.negative !== 0) return 1;
      var a5 = this.ucmp(f6);
      return this.negative !== 0 ? -a5 | 0 : a5;
    }, o4.prototype.ucmp = function(f6) {
      if (this.length > f6.length) return 1;
      if (this.length < f6.length) return -1;
      for (var a5 = 0, c7 = this.length - 1; c7 >= 0; c7--) {
        var d5 = this.words[c7] | 0, m2 = f6.words[c7] | 0;
        if (d5 !== m2) {
          d5 < m2 ? a5 = -1 : d5 > m2 && (a5 = 1);
          break;
        }
      }
      return a5;
    }, o4.prototype.gtn = function(f6) {
      return this.cmpn(f6) === 1;
    }, o4.prototype.gt = function(f6) {
      return this.cmp(f6) === 1;
    }, o4.prototype.gten = function(f6) {
      return this.cmpn(f6) >= 0;
    }, o4.prototype.gte = function(f6) {
      return this.cmp(f6) >= 0;
    }, o4.prototype.ltn = function(f6) {
      return this.cmpn(f6) === -1;
    }, o4.prototype.lt = function(f6) {
      return this.cmp(f6) === -1;
    }, o4.prototype.lten = function(f6) {
      return this.cmpn(f6) <= 0;
    }, o4.prototype.lte = function(f6) {
      return this.cmp(f6) <= 0;
    }, o4.prototype.eqn = function(f6) {
      return this.cmpn(f6) === 0;
    }, o4.prototype.eq = function(f6) {
      return this.cmp(f6) === 0;
    }, o4.red = function(f6) {
      return new Y6(f6);
    }, o4.prototype.toRed = function(f6) {
      return i3(!this.red, "Already a number in reduction context"), i3(this.negative === 0, "red works only with positives"), f6.convertTo(this)._forceRed(f6);
    }, o4.prototype.fromRed = function() {
      return i3(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, o4.prototype._forceRed = function(f6) {
      return this.red = f6, this;
    }, o4.prototype.forceRed = function(f6) {
      return i3(!this.red, "Already a number in reduction context"), this._forceRed(f6);
    }, o4.prototype.redAdd = function(f6) {
      return i3(this.red, "redAdd works only with red numbers"), this.red.add(this, f6);
    }, o4.prototype.redIAdd = function(f6) {
      return i3(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f6);
    }, o4.prototype.redSub = function(f6) {
      return i3(this.red, "redSub works only with red numbers"), this.red.sub(this, f6);
    }, o4.prototype.redISub = function(f6) {
      return i3(this.red, "redISub works only with red numbers"), this.red.isub(this, f6);
    }, o4.prototype.redShl = function(f6) {
      return i3(this.red, "redShl works only with red numbers"), this.red.shl(this, f6);
    }, o4.prototype.redMul = function(f6) {
      return i3(this.red, "redMul works only with red numbers"), this.red._verify2(this, f6), this.red.mul(this, f6);
    }, o4.prototype.redIMul = function(f6) {
      return i3(this.red, "redMul works only with red numbers"), this.red._verify2(this, f6), this.red.imul(this, f6);
    }, o4.prototype.redSqr = function() {
      return i3(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, o4.prototype.redISqr = function() {
      return i3(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, o4.prototype.redSqrt = function() {
      return i3(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, o4.prototype.redInvm = function() {
      return i3(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, o4.prototype.redNeg = function() {
      return i3(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, o4.prototype.redPow = function(f6) {
      return i3(this.red && !f6.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f6);
    };
    var H3 = { k256: null, p224: null, p192: null, p25519: null };
    function L4(b6, f6) {
      this.name = b6, this.p = new o4(f6, 16), this.n = this.p.bitLength(), this.k = new o4(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    L4.prototype._tmp = function() {
      var f6 = new o4(null);
      return f6.words = new Array(Math.ceil(this.n / 13)), f6;
    }, L4.prototype.ireduce = function(f6) {
      var a5 = f6, c7;
      do
        this.split(a5, this.tmp), a5 = this.imulK(a5), a5 = a5.iadd(this.tmp), c7 = a5.bitLength();
      while (c7 > this.n);
      var d5 = c7 < this.n ? -1 : a5.ucmp(this.p);
      return d5 === 0 ? (a5.words[0] = 0, a5.length = 1) : d5 > 0 ? a5.isub(this.p) : a5.strip !== void 0 ? a5.strip() : a5._strip(), a5;
    }, L4.prototype.split = function(f6, a5) {
      f6.iushrn(this.n, 0, a5);
    }, L4.prototype.imulK = function(f6) {
      return f6.imul(this.k);
    };
    function Pt5() {
      L4.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    n4(Pt5, L4), Pt5.prototype.split = function(f6, a5) {
      for (var c7 = 4194303, d5 = Math.min(f6.length, 9), m2 = 0; m2 < d5; m2++) a5.words[m2] = f6.words[m2];
      if (a5.length = d5, f6.length <= 9) {
        f6.words[0] = 0, f6.length = 1;
        return;
      }
      var x7 = f6.words[9];
      for (a5.words[a5.length++] = x7 & c7, m2 = 10; m2 < f6.length; m2++) {
        var M6 = f6.words[m2] | 0;
        f6.words[m2 - 10] = (M6 & c7) << 4 | x7 >>> 22, x7 = M6;
      }
      x7 >>>= 22, f6.words[m2 - 10] = x7, x7 === 0 && f6.length > 10 ? f6.length -= 10 : f6.length -= 9;
    }, Pt5.prototype.imulK = function(f6) {
      f6.words[f6.length] = 0, f6.words[f6.length + 1] = 0, f6.length += 2;
      for (var a5 = 0, c7 = 0; c7 < f6.length; c7++) {
        var d5 = f6.words[c7] | 0;
        a5 += d5 * 977, f6.words[c7] = a5 & 67108863, a5 = d5 * 64 + (a5 / 67108864 | 0);
      }
      return f6.words[f6.length - 1] === 0 && (f6.length--, f6.words[f6.length - 1] === 0 && f6.length--), f6;
    };
    function W3() {
      L4.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    n4(W3, L4);
    function Rt5() {
      L4.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    n4(Rt5, L4);
    function Vt5() {
      L4.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    n4(Vt5, L4), Vt5.prototype.imulK = function(f6) {
      for (var a5 = 0, c7 = 0; c7 < f6.length; c7++) {
        var d5 = (f6.words[c7] | 0) * 19 + a5, m2 = d5 & 67108863;
        d5 >>>= 26, f6.words[c7] = m2, a5 = d5;
      }
      return a5 !== 0 && (f6.words[f6.length++] = a5), f6;
    }, o4._prime = function(f6) {
      if (H3[f6]) return H3[f6];
      var a5;
      if (f6 === "k256") a5 = new Pt5();
      else if (f6 === "p224") a5 = new W3();
      else if (f6 === "p192") a5 = new Rt5();
      else if (f6 === "p25519") a5 = new Vt5();
      else throw new Error("Unknown prime " + f6);
      return H3[f6] = a5, a5;
    };
    function Y6(b6) {
      if (typeof b6 == "string") {
        var f6 = o4._prime(b6);
        this.m = f6.p, this.prime = f6;
      } else i3(b6.gtn(1), "modulus must be greater than 1"), this.m = b6, this.prime = null;
    }
    Y6.prototype._verify1 = function(f6) {
      i3(f6.negative === 0, "red works only with positives"), i3(f6.red, "red works only with red numbers");
    }, Y6.prototype._verify2 = function(f6, a5) {
      i3((f6.negative | a5.negative) === 0, "red works only with positives"), i3(f6.red && f6.red === a5.red, "red works only with red numbers");
    }, Y6.prototype.imod = function(f6) {
      return this.prime ? this.prime.ireduce(f6)._forceRed(this) : (w6(f6, f6.umod(this.m)._forceRed(this)), f6);
    }, Y6.prototype.neg = function(f6) {
      return f6.isZero() ? f6.clone() : this.m.sub(f6)._forceRed(this);
    }, Y6.prototype.add = function(f6, a5) {
      this._verify2(f6, a5);
      var c7 = f6.add(a5);
      return c7.cmp(this.m) >= 0 && c7.isub(this.m), c7._forceRed(this);
    }, Y6.prototype.iadd = function(f6, a5) {
      this._verify2(f6, a5);
      var c7 = f6.iadd(a5);
      return c7.cmp(this.m) >= 0 && c7.isub(this.m), c7;
    }, Y6.prototype.sub = function(f6, a5) {
      this._verify2(f6, a5);
      var c7 = f6.sub(a5);
      return c7.cmpn(0) < 0 && c7.iadd(this.m), c7._forceRed(this);
    }, Y6.prototype.isub = function(f6, a5) {
      this._verify2(f6, a5);
      var c7 = f6.isub(a5);
      return c7.cmpn(0) < 0 && c7.iadd(this.m), c7;
    }, Y6.prototype.shl = function(f6, a5) {
      return this._verify1(f6), this.imod(f6.ushln(a5));
    }, Y6.prototype.imul = function(f6, a5) {
      return this._verify2(f6, a5), this.imod(f6.imul(a5));
    }, Y6.prototype.mul = function(f6, a5) {
      return this._verify2(f6, a5), this.imod(f6.mul(a5));
    }, Y6.prototype.isqr = function(f6) {
      return this.imul(f6, f6.clone());
    }, Y6.prototype.sqr = function(f6) {
      return this.mul(f6, f6);
    }, Y6.prototype.sqrt = function(f6) {
      if (f6.isZero()) return f6.clone();
      var a5 = this.m.andln(3);
      if (i3(a5 % 2 === 1), a5 === 3) {
        var c7 = this.m.add(new o4(1)).iushrn(2);
        return this.pow(f6, c7);
      }
      for (var d5 = this.m.subn(1), m2 = 0; !d5.isZero() && d5.andln(1) === 0; ) m2++, d5.iushrn(1);
      i3(!d5.isZero());
      var x7 = new o4(1).toRed(this), M6 = x7.redNeg(), l7 = this.m.subn(1).iushrn(1), s2 = this.m.bitLength();
      for (s2 = new o4(2 * s2 * s2).toRed(this); this.pow(s2, l7).cmp(M6) !== 0; ) s2.redIAdd(M6);
      for (var g4 = this.pow(s2, d5), k6 = this.pow(f6, d5.addn(1).iushrn(1)), u4 = this.pow(f6, d5), E6 = m2; u4.cmp(x7) !== 0; ) {
        for (var _5 = u4, B5 = 0; _5.cmp(x7) !== 0; B5++) _5 = _5.redSqr();
        i3(B5 < E6);
        var R6 = this.pow(g4, new o4(1).iushln(E6 - B5 - 1));
        k6 = k6.redMul(R6), g4 = R6.redSqr(), u4 = u4.redMul(g4), E6 = B5;
      }
      return k6;
    }, Y6.prototype.invm = function(f6) {
      var a5 = f6._invmp(this.m);
      return a5.negative !== 0 ? (a5.negative = 0, this.imod(a5).redNeg()) : this.imod(a5);
    }, Y6.prototype.pow = function(f6, a5) {
      if (a5.isZero()) return new o4(1).toRed(this);
      if (a5.cmpn(1) === 0) return f6.clone();
      var c7 = 4, d5 = new Array(1 << c7);
      d5[0] = new o4(1).toRed(this), d5[1] = f6;
      for (var m2 = 2; m2 < d5.length; m2++) d5[m2] = this.mul(d5[m2 - 1], f6);
      var x7 = d5[0], M6 = 0, l7 = 0, s2 = a5.bitLength() % 26;
      for (s2 === 0 && (s2 = 26), m2 = a5.length - 1; m2 >= 0; m2--) {
        for (var g4 = a5.words[m2], k6 = s2 - 1; k6 >= 0; k6--) {
          var u4 = g4 >> k6 & 1;
          if (x7 !== d5[0] && (x7 = this.sqr(x7)), u4 === 0 && M6 === 0) {
            l7 = 0;
            continue;
          }
          M6 <<= 1, M6 |= u4, l7++, !(l7 !== c7 && (m2 !== 0 || k6 !== 0)) && (x7 = this.mul(x7, d5[M6]), l7 = 0, M6 = 0);
        }
        s2 = 26;
      }
      return x7;
    }, Y6.prototype.convertTo = function(f6) {
      var a5 = f6.umod(this.m);
      return a5 === f6 ? a5.clone() : a5;
    }, Y6.prototype.convertFrom = function(f6) {
      var a5 = f6.clone();
      return a5.red = null, a5;
    }, o4.mont = function(f6) {
      return new Wt5(f6);
    };
    function Wt5(b6) {
      Y6.call(this, b6), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o4(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    n4(Wt5, Y6), Wt5.prototype.convertTo = function(f6) {
      return this.imod(f6.ushln(this.shift));
    }, Wt5.prototype.convertFrom = function(f6) {
      var a5 = this.imod(f6.mul(this.rinv));
      return a5.red = null, a5;
    }, Wt5.prototype.imul = function(f6, a5) {
      if (f6.isZero() || a5.isZero()) return f6.words[0] = 0, f6.length = 1, f6;
      var c7 = f6.imul(a5), d5 = c7.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m2 = c7.isub(d5).iushrn(this.shift), x7 = m2;
      return m2.cmp(this.m) >= 0 ? x7 = m2.isub(this.m) : m2.cmpn(0) < 0 && (x7 = m2.iadd(this.m)), x7._forceRed(this);
    }, Wt5.prototype.mul = function(f6, a5) {
      if (f6.isZero() || a5.isZero()) return new o4(0)._forceRed(this);
      var c7 = f6.mul(a5), d5 = c7.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m2 = c7.isub(d5).iushrn(this.shift), x7 = m2;
      return m2.cmp(this.m) >= 0 ? x7 = m2.isub(this.m) : m2.cmpn(0) < 0 && (x7 = m2.iadd(this.m)), x7._forceRed(this);
    }, Wt5.prototype.invm = function(f6) {
      var a5 = this.imod(f6._invmp(this.m).mul(this.r2));
      return a5._forceRed(this);
    };
  })(e, Kn2);
})(Xn3);
var K5 = Xn3.exports;
var $n3 = "bignumber/5.7.0";
var Dr4 = K5.BN;
var Ae2 = new z5($n3);
var Ni3 = {};
var Zn2 = 9007199254740991;
function Hs3(e) {
  return e != null && (V4.isBigNumber(e) || typeof e == "number" && e % 1 === 0 || typeof e == "string" && !!e.match(/^-?[0-9]+$/) || Jt4(e) || typeof e == "bigint" || nr4(e));
}
var tf = false;
var V4 = class _V {
  constructor(t, r3) {
    t !== Ni3 && Ae2.throwError("cannot call constructor directly; use BigNumber.from", z5.errors.UNSUPPORTED_OPERATION, { operation: "new (BigNumber)" }), this._hex = r3, this._isBigNumber = true, Object.freeze(this);
  }
  fromTwos(t) {
    return zt3(j4(this).fromTwos(t));
  }
  toTwos(t) {
    return zt3(j4(this).toTwos(t));
  }
  abs() {
    return this._hex[0] === "-" ? _V.from(this._hex.substring(1)) : this;
  }
  add(t) {
    return zt3(j4(this).add(j4(t)));
  }
  sub(t) {
    return zt3(j4(this).sub(j4(t)));
  }
  div(t) {
    return _V.from(t).isZero() && $t4("division-by-zero", "div"), zt3(j4(this).div(j4(t)));
  }
  mul(t) {
    return zt3(j4(this).mul(j4(t)));
  }
  mod(t) {
    const r3 = j4(t);
    return r3.isNeg() && $t4("division-by-zero", "mod"), zt3(j4(this).umod(r3));
  }
  pow(t) {
    const r3 = j4(t);
    return r3.isNeg() && $t4("negative-power", "pow"), zt3(j4(this).pow(r3));
  }
  and(t) {
    const r3 = j4(t);
    return (this.isNegative() || r3.isNeg()) && $t4("unbound-bitwise-result", "and"), zt3(j4(this).and(r3));
  }
  or(t) {
    const r3 = j4(t);
    return (this.isNegative() || r3.isNeg()) && $t4("unbound-bitwise-result", "or"), zt3(j4(this).or(r3));
  }
  xor(t) {
    const r3 = j4(t);
    return (this.isNegative() || r3.isNeg()) && $t4("unbound-bitwise-result", "xor"), zt3(j4(this).xor(r3));
  }
  mask(t) {
    return (this.isNegative() || t < 0) && $t4("negative-width", "mask"), zt3(j4(this).maskn(t));
  }
  shl(t) {
    return (this.isNegative() || t < 0) && $t4("negative-width", "shl"), zt3(j4(this).shln(t));
  }
  shr(t) {
    return (this.isNegative() || t < 0) && $t4("negative-width", "shr"), zt3(j4(this).shrn(t));
  }
  eq(t) {
    return j4(this).eq(j4(t));
  }
  lt(t) {
    return j4(this).lt(j4(t));
  }
  lte(t) {
    return j4(this).lte(j4(t));
  }
  gt(t) {
    return j4(this).gt(j4(t));
  }
  gte(t) {
    return j4(this).gte(j4(t));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return j4(this).isZero();
  }
  toNumber() {
    try {
      return j4(this).toNumber();
    } catch {
      $t4("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return Ae2.throwError("this platform does not support BigInt", z5.errors.UNSUPPORTED_OPERATION, { value: this.toString() });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? tf || (tf = true, Ae2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? Ae2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", z5.errors.UNEXPECTED_ARGUMENT, {}) : Ae2.throwError("BigNumber.toString does not accept parameters", z5.errors.UNEXPECTED_ARGUMENT, {})), j4(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(t) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(t) {
    if (t instanceof _V) return t;
    if (typeof t == "string") return t.match(/^-?0x[0-9a-f]+$/i) ? new _V(Ni3, mr3(t)) : t.match(/^-?[0-9]+$/) ? new _V(Ni3, mr3(new Dr4(t))) : Ae2.throwArgumentError("invalid BigNumber string", "value", t);
    if (typeof t == "number") return t % 1 && $t4("underflow", "BigNumber.from", t), (t >= Zn2 || t <= -Zn2) && $t4("overflow", "BigNumber.from", t), _V.from(String(t));
    const r3 = t;
    if (typeof r3 == "bigint") return _V.from(r3.toString());
    if (nr4(r3)) return _V.from(Kt4(r3));
    if (r3) if (r3.toHexString) {
      const i3 = r3.toHexString();
      if (typeof i3 == "string") return _V.from(i3);
    } else {
      let i3 = r3._hex;
      if (i3 == null && r3.type === "BigNumber" && (i3 = r3.hex), typeof i3 == "string" && (Jt4(i3) || i3[0] === "-" && Jt4(i3.substring(1)))) return _V.from(i3);
    }
    return Ae2.throwArgumentError("invalid BigNumber value", "value", t);
  }
  static isBigNumber(t) {
    return !!(t && t._isBigNumber);
  }
};
function mr3(e) {
  if (typeof e != "string") return mr3(e.toString(16));
  if (e[0] === "-") return e = e.substring(1), e[0] === "-" && Ae2.throwArgumentError("invalid hex", "value", e), e = mr3(e), e === "0x00" ? e : "-" + e;
  if (e.substring(0, 2) !== "0x" && (e = "0x" + e), e === "0x") return "0x00";
  for (e.length % 2 && (e = "0x0" + e.substring(2)); e.length > 4 && e.substring(0, 4) === "0x00"; ) e = "0x" + e.substring(4);
  return e;
}
function zt3(e) {
  return V4.from(mr3(e));
}
function j4(e) {
  const t = V4.from(e).toHexString();
  return t[0] === "-" ? new Dr4("-" + t.substring(3), 16) : new Dr4(t.substring(2), 16);
}
function $t4(e, t, r3) {
  const i3 = { fault: e, operation: t };
  return r3 != null && (i3.value = r3), Ae2.throwError(e, z5.errors.NUMERIC_FAULT, i3);
}
function Ls2(e) {
  return new Dr4(e, 36).toString(16);
}
var Ht4 = new z5($n3);
var Ar4 = {};
var ef = V4.from(0);
var rf = V4.from(-1);
function nf(e, t, r3, i3) {
  const n4 = { fault: t, operation: r3 };
  return i3 !== void 0 && (n4.value = i3), Ht4.throwError(e, z5.errors.NUMERIC_FAULT, n4);
}
var br3 = "0";
for (; br3.length < 256; ) br3 += br3;
function _i3(e) {
  if (typeof e != "number") try {
    e = V4.from(e).toNumber();
  } catch {
  }
  return typeof e == "number" && e >= 0 && e <= 256 && !(e % 1) ? "1" + br3.substring(0, e) : Ht4.throwArgumentError("invalid decimal size", "decimals", e);
}
function Bi3(e, t) {
  t == null && (t = 0);
  const r3 = _i3(t);
  e = V4.from(e);
  const i3 = e.lt(ef);
  i3 && (e = e.mul(rf));
  let n4 = e.mod(r3).toString();
  for (; n4.length < r3.length - 1; ) n4 = "0" + n4;
  n4 = n4.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const o4 = e.div(r3).toString();
  return r3.length === 1 ? e = o4 : e = o4 + "." + n4, i3 && (e = "-" + e), e;
}
function be4(e, t) {
  t == null && (t = 0);
  const r3 = _i3(t);
  (typeof e != "string" || !e.match(/^-?[0-9.]+$/)) && Ht4.throwArgumentError("invalid decimal value", "value", e);
  const i3 = e.substring(0, 1) === "-";
  i3 && (e = e.substring(1)), e === "." && Ht4.throwArgumentError("missing value", "value", e);
  const n4 = e.split(".");
  n4.length > 2 && Ht4.throwArgumentError("too many decimal points", "value", e);
  let o4 = n4[0], h7 = n4[1];
  for (o4 || (o4 = "0"), h7 || (h7 = "0"); h7[h7.length - 1] === "0"; ) h7 = h7.substring(0, h7.length - 1);
  for (h7.length > r3.length - 1 && nf("fractional component exceeds decimals", "underflow", "parseFixed"), h7 === "" && (h7 = "0"); h7.length < r3.length - 1; ) h7 += "0";
  const p5 = V4.from(o4), A5 = V4.from(h7);
  let v7 = p5.mul(r3).add(A5);
  return i3 && (v7 = v7.mul(rf)), v7;
}
var vr3 = class _vr {
  constructor(t, r3, i3, n4) {
    t !== Ar4 && Ht4.throwError("cannot use FixedFormat constructor; use FixedFormat.from", z5.errors.UNSUPPORTED_OPERATION, { operation: "new FixedFormat" }), this.signed = r3, this.width = i3, this.decimals = n4, this.name = (r3 ? "" : "u") + "fixed" + String(i3) + "x" + String(n4), this._multiplier = _i3(n4), Object.freeze(this);
  }
  static from(t) {
    if (t instanceof _vr) return t;
    typeof t == "number" && (t = `fixed128x${t}`);
    let r3 = true, i3 = 128, n4 = 18;
    if (typeof t == "string") {
      if (t !== "fixed") if (t === "ufixed") r3 = false;
      else {
        const o4 = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        o4 || Ht4.throwArgumentError("invalid fixed format", "format", t), r3 = o4[1] !== "u", i3 = parseInt(o4[2]), n4 = parseInt(o4[3]);
      }
    } else if (t) {
      const o4 = (h7, p5, A5) => t[h7] == null ? A5 : (typeof t[h7] !== p5 && Ht4.throwArgumentError("invalid fixed format (" + h7 + " not " + p5 + ")", "format." + h7, t[h7]), t[h7]);
      r3 = o4("signed", "boolean", r3), i3 = o4("width", "number", i3), n4 = o4("decimals", "number", n4);
    }
    return i3 % 8 && Ht4.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", i3), n4 > 80 && Ht4.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", n4), new _vr(Ar4, r3, i3, n4);
  }
};
var Ut3 = class _Ut {
  constructor(t, r3, i3, n4) {
    t !== Ar4 && Ht4.throwError("cannot use FixedNumber constructor; use FixedNumber.from", z5.errors.UNSUPPORTED_OPERATION, { operation: "new FixedFormat" }), this.format = n4, this._hex = r3, this._value = i3, this._isFixedNumber = true, Object.freeze(this);
  }
  _checkFormat(t) {
    this.format.name !== t.format.name && Ht4.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", t);
  }
  addUnsafe(t) {
    this._checkFormat(t);
    const r3 = be4(this._value, this.format.decimals), i3 = be4(t._value, t.format.decimals);
    return _Ut.fromValue(r3.add(i3), this.format.decimals, this.format);
  }
  subUnsafe(t) {
    this._checkFormat(t);
    const r3 = be4(this._value, this.format.decimals), i3 = be4(t._value, t.format.decimals);
    return _Ut.fromValue(r3.sub(i3), this.format.decimals, this.format);
  }
  mulUnsafe(t) {
    this._checkFormat(t);
    const r3 = be4(this._value, this.format.decimals), i3 = be4(t._value, t.format.decimals);
    return _Ut.fromValue(r3.mul(i3).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(t) {
    this._checkFormat(t);
    const r3 = be4(this._value, this.format.decimals), i3 = be4(t._value, t.format.decimals);
    return _Ut.fromValue(r3.mul(this.format._multiplier).div(i3), this.format.decimals, this.format);
  }
  floor() {
    const t = this.toString().split(".");
    t.length === 1 && t.push("0");
    let r3 = _Ut.from(t[0], this.format);
    const i3 = !t[1].match(/^(0*)$/);
    return this.isNegative() && i3 && (r3 = r3.subUnsafe(ff.toFormat(r3.format))), r3;
  }
  ceiling() {
    const t = this.toString().split(".");
    t.length === 1 && t.push("0");
    let r3 = _Ut.from(t[0], this.format);
    const i3 = !t[1].match(/^(0*)$/);
    return !this.isNegative() && i3 && (r3 = r3.addUnsafe(ff.toFormat(r3.format))), r3;
  }
  round(t) {
    t == null && (t = 0);
    const r3 = this.toString().split(".");
    if (r3.length === 1 && r3.push("0"), (t < 0 || t > 80 || t % 1) && Ht4.throwArgumentError("invalid decimal count", "decimals", t), r3[1].length <= t) return this;
    const i3 = _Ut.from("1" + br3.substring(0, t), this.format), n4 = zs2.toFormat(this.format);
    return this.mulUnsafe(i3).addUnsafe(n4).floor().divUnsafe(i3);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(t) {
    if (t == null) return this._hex;
    t % 8 && Ht4.throwArgumentError("invalid byte width", "width", t);
    const r3 = V4.from(this._hex).fromTwos(this.format.width).toTwos(t).toHexString();
    return oe2(r3, t / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(t) {
    return _Ut.fromString(this._value, t);
  }
  static fromValue(t, r3, i3) {
    return i3 == null && r3 != null && !Hs3(r3) && (i3 = r3, r3 = null), r3 == null && (r3 = 0), i3 == null && (i3 = "fixed"), _Ut.fromString(Bi3(t, r3), vr3.from(i3));
  }
  static fromString(t, r3) {
    r3 == null && (r3 = "fixed");
    const i3 = vr3.from(r3), n4 = be4(t, i3.decimals);
    !i3.signed && n4.lt(ef) && nf("unsigned value cannot be negative", "overflow", "value", t);
    let o4 = null;
    i3.signed ? o4 = n4.toTwos(i3.width).toHexString() : (o4 = n4.toHexString(), o4 = oe2(o4, i3.width / 8));
    const h7 = Bi3(n4, i3.decimals);
    return new _Ut(Ar4, o4, h7, i3);
  }
  static fromBytes(t, r3) {
    r3 == null && (r3 = "fixed");
    const i3 = vr3.from(r3);
    if (Ot4(t).length > i3.width / 8) throw new Error("overflow");
    let n4 = V4.from(t);
    i3.signed && (n4 = n4.fromTwos(i3.width));
    const o4 = n4.toTwos((i3.signed ? 0 : 1) + i3.width).toHexString(), h7 = Bi3(n4, i3.decimals);
    return new _Ut(Ar4, o4, h7, i3);
  }
  static from(t, r3) {
    if (typeof t == "string") return _Ut.fromString(t, r3);
    if (nr4(t)) return _Ut.fromBytes(t, r3);
    try {
      return _Ut.fromValue(t, 0, r3);
    } catch (i3) {
      if (i3.code !== z5.errors.INVALID_ARGUMENT) throw i3;
    }
    return Ht4.throwArgumentError("invalid FixedNumber value", "value", t);
  }
  static isFixedNumber(t) {
    return !!(t && t._isFixedNumber);
  }
};
var ff = Ut3.from(1);
var zs2 = Ut3.from("0.5");
var js2 = "strings/5.7.0";
var of = new z5(js2);
var Fr4;
(function(e) {
  e.current = "", e.NFC = "NFC", e.NFD = "NFD", e.NFKC = "NFKC", e.NFKD = "NFKD";
})(Fr4 || (Fr4 = {}));
var fr3;
(function(e) {
  e.UNEXPECTED_CONTINUE = "unexpected continuation byte", e.BAD_PREFIX = "bad codepoint prefix", e.OVERRUN = "string overrun", e.MISSING_CONTINUE = "missing continuation byte", e.OUT_OF_RANGE = "out of UTF-8 range", e.UTF16_SURROGATE = "UTF-16 surrogate", e.OVERLONG = "overlong representation";
})(fr3 || (fr3 = {}));
function Qs2(e, t, r3, i3, n4) {
  return of.throwArgumentError(`invalid codepoint at offset ${t}; ${e}`, "bytes", r3);
}
function sf(e, t, r3, i3, n4) {
  if (e === fr3.BAD_PREFIX || e === fr3.UNEXPECTED_CONTINUE) {
    let o4 = 0;
    for (let h7 = t + 1; h7 < r3.length && r3[h7] >> 6 === 2; h7++) o4++;
    return o4;
  }
  return e === fr3.OVERRUN ? r3.length - t - 1 : 0;
}
function Js2(e, t, r3, i3, n4) {
  return e === fr3.OVERLONG ? (i3.push(n4), 0) : (i3.push(65533), sf(e, t, r3));
}
Object.freeze({ error: Qs2, ignore: sf, replace: Js2 });
function Ci3(e, t = Fr4.current) {
  t != Fr4.current && (of.checkNormalize(), e = e.normalize(t));
  let r3 = [];
  for (let i3 = 0; i3 < e.length; i3++) {
    const n4 = e.charCodeAt(i3);
    if (n4 < 128) r3.push(n4);
    else if (n4 < 2048) r3.push(n4 >> 6 | 192), r3.push(n4 & 63 | 128);
    else if ((n4 & 64512) == 55296) {
      i3++;
      const o4 = e.charCodeAt(i3);
      if (i3 >= e.length || (o4 & 64512) !== 56320) throw new Error("invalid utf-8 string");
      const h7 = 65536 + ((n4 & 1023) << 10) + (o4 & 1023);
      r3.push(h7 >> 18 | 240), r3.push(h7 >> 12 & 63 | 128), r3.push(h7 >> 6 & 63 | 128), r3.push(h7 & 63 | 128);
    } else r3.push(n4 >> 12 | 224), r3.push(n4 >> 6 & 63 | 128), r3.push(n4 & 63 | 128);
  }
  return Ot4(r3);
}
function Gs2(e) {
  if (e.length % 4 !== 0) throw new Error("bad data");
  let t = [];
  for (let r3 = 0; r3 < e.length; r3 += 4) t.push(parseInt(e.substring(r3, r3 + 4), 16));
  return t;
}
function Ri3(e, t) {
  t || (t = function(n4) {
    return [parseInt(n4, 16)];
  });
  let r3 = 0, i3 = {};
  return e.split(",").forEach((n4) => {
    let o4 = n4.split(":");
    r3 += parseInt(o4[0], 16), i3[r3] = t(o4[1]);
  }), i3;
}
function af(e) {
  let t = 0;
  return e.split(",").map((r3) => {
    let i3 = r3.split("-");
    i3.length === 1 ? i3[1] = "0" : i3[1] === "" && (i3[1] = "1");
    let n4 = t + parseInt(i3[0], 16);
    return t = parseInt(i3[1], 16), { l: n4, h: t };
  });
}
af("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"), "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((e) => parseInt(e, 16)), Ri3("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"), Ri3("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"), Ri3("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", Gs2), af("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
var uf = "hash/5.7.0";
function Ys2(e) {
  e = atob(e);
  const t = [];
  for (let r3 = 0; r3 < e.length; r3++) t.push(e.charCodeAt(r3));
  return Ot4(t);
}
function hf(e, t) {
  t == null && (t = 1);
  const r3 = [], i3 = r3.forEach, n4 = function(o4, h7) {
    i3.call(o4, function(p5) {
      h7 > 0 && Array.isArray(p5) ? n4(p5, h7 - 1) : r3.push(p5);
    });
  };
  return n4(e, t), r3;
}
function Vs3(e) {
  const t = {};
  for (let r3 = 0; r3 < e.length; r3++) {
    const i3 = e[r3];
    t[i3[0]] = i3[1];
  }
  return t;
}
function Ws2(e) {
  let t = 0;
  function r3() {
    return e[t++] << 8 | e[t++];
  }
  let i3 = r3(), n4 = 1, o4 = [0, 1];
  for (let H3 = 1; H3 < i3; H3++) o4.push(n4 += r3());
  let h7 = r3(), p5 = t;
  t += h7;
  let A5 = 0, v7 = 0;
  function w6() {
    return A5 == 0 && (v7 = v7 << 8 | e[t++], A5 = 8), v7 >> --A5 & 1;
  }
  const y10 = 31, S7 = Math.pow(2, y10), N4 = S7 >>> 1, I5 = N4 >> 1, C5 = S7 - 1;
  let D5 = 0;
  for (let H3 = 0; H3 < y10; H3++) D5 = D5 << 1 | w6();
  let U5 = [], J2 = 0, Bt5 = S7;
  for (; ; ) {
    let H3 = Math.floor(((D5 - J2 + 1) * n4 - 1) / Bt5), L4 = 0, Pt5 = i3;
    for (; Pt5 - L4 > 1; ) {
      let Vt5 = L4 + Pt5 >>> 1;
      H3 < o4[Vt5] ? Pt5 = Vt5 : L4 = Vt5;
    }
    if (L4 == 0) break;
    U5.push(L4);
    let W3 = J2 + Math.floor(Bt5 * o4[L4] / n4), Rt5 = J2 + Math.floor(Bt5 * o4[L4 + 1] / n4) - 1;
    for (; !((W3 ^ Rt5) & N4); ) D5 = D5 << 1 & C5 | w6(), W3 = W3 << 1 & C5, Rt5 = Rt5 << 1 & C5 | 1;
    for (; W3 & ~Rt5 & I5; ) D5 = D5 & N4 | D5 << 1 & C5 >>> 1 | w6(), W3 = W3 << 1 ^ N4, Rt5 = (Rt5 ^ N4) << 1 | N4 | 1;
    J2 = W3, Bt5 = 1 + Rt5 - W3;
  }
  let G5 = i3 - 4;
  return U5.map((H3) => {
    switch (H3 - G5) {
      case 3:
        return G5 + 65792 + (e[p5++] << 16 | e[p5++] << 8 | e[p5++]);
      case 2:
        return G5 + 256 + (e[p5++] << 8 | e[p5++]);
      case 1:
        return G5 + e[p5++];
      default:
        return H3 - 1;
    }
  });
}
function Xs3(e) {
  let t = 0;
  return () => e[t++];
}
function $s2(e) {
  return Xs3(Ws2(e));
}
function Zs2(e) {
  return e & 1 ? ~e >> 1 : e >> 1;
}
function t0(e, t) {
  let r3 = Array(e);
  for (let i3 = 0; i3 < e; i3++) r3[i3] = 1 + t();
  return r3;
}
function cf(e, t) {
  let r3 = Array(e);
  for (let i3 = 0, n4 = -1; i3 < e; i3++) r3[i3] = n4 += 1 + t();
  return r3;
}
function e0(e, t) {
  let r3 = Array(e);
  for (let i3 = 0, n4 = 0; i3 < e; i3++) r3[i3] = n4 += Zs2(t());
  return r3;
}
function Ur3(e, t) {
  let r3 = cf(e(), e), i3 = e(), n4 = cf(i3, e), o4 = t0(i3, e);
  for (let h7 = 0; h7 < i3; h7++) for (let p5 = 0; p5 < o4[h7]; p5++) r3.push(n4[h7] + p5);
  return t ? r3.map((h7) => t[h7]) : r3;
}
function r0(e) {
  let t = [];
  for (; ; ) {
    let r3 = e();
    if (r3 == 0) break;
    t.push(n0(r3, e));
  }
  for (; ; ) {
    let r3 = e() - 1;
    if (r3 < 0) break;
    t.push(f0(r3, e));
  }
  return Vs3(hf(t));
}
function i0(e) {
  let t = [];
  for (; ; ) {
    let r3 = e();
    if (r3 == 0) break;
    t.push(r3);
  }
  return t;
}
function lf(e, t, r3) {
  let i3 = Array(e).fill(void 0).map(() => []);
  for (let n4 = 0; n4 < t; n4++) e0(e, r3).forEach((o4, h7) => i3[h7].push(o4));
  return i3;
}
function n0(e, t) {
  let r3 = 1 + t(), i3 = t(), n4 = i0(t), o4 = lf(n4.length, 1 + e, t);
  return hf(o4.map((h7, p5) => {
    const A5 = h7[0], v7 = h7.slice(1);
    return Array(n4[p5]).fill(void 0).map((w6, y10) => {
      let S7 = y10 * i3;
      return [A5 + y10 * r3, v7.map((N4) => N4 + S7)];
    });
  }));
}
function f0(e, t) {
  let r3 = 1 + t();
  return lf(r3, 1 + e, t).map((n4) => [n4[0], n4.slice(1)]);
}
function o0(e) {
  let t = Ur3(e).sort((i3, n4) => i3 - n4);
  return r3();
  function r3() {
    let i3 = [];
    for (; ; ) {
      let v7 = Ur3(e, t);
      if (v7.length == 0) break;
      i3.push({ set: new Set(v7), node: r3() });
    }
    i3.sort((v7, w6) => w6.set.size - v7.set.size);
    let n4 = e(), o4 = n4 % 3;
    n4 = n4 / 3 | 0;
    let h7 = !!(n4 & 1);
    n4 >>= 1;
    let p5 = n4 == 1, A5 = n4 == 2;
    return { branches: i3, valid: o4, fe0f: h7, save: p5, check: A5 };
  }
}
function s0() {
  return $s2(Ys2("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
var kr3 = s0();
new Set(Ur3(kr3)), new Set(Ur3(kr3)), r0(kr3), o0(kr3), new z5(uf);
var a0 = new Uint8Array(32);
a0.fill(0);
var u0 = `Ethereum Signed Message:
`;
function df(e) {
  return typeof e == "string" && (e = Ci3(e)), Ii3(Ds2([Ci3(u0), Ci3(String(e.length)), e]));
}
var h0 = "rlp/5.7.0";
new z5(h0);
var c0 = "address/5.7.0";
var yr3 = new z5(c0);
function pf(e) {
  Jt4(e, 20) || yr3.throwArgumentError("invalid address", "address", e), e = e.toLowerCase();
  const t = e.substring(2).split(""), r3 = new Uint8Array(40);
  for (let n4 = 0; n4 < 40; n4++) r3[n4] = t[n4].charCodeAt(0);
  const i3 = Ot4(Ii3(r3));
  for (let n4 = 0; n4 < 40; n4 += 2) i3[n4 >> 1] >> 4 >= 8 && (t[n4] = t[n4].toUpperCase()), (i3[n4 >> 1] & 15) >= 8 && (t[n4 + 1] = t[n4 + 1].toUpperCase());
  return "0x" + t.join("");
}
var l0 = 9007199254740991;
function d0(e) {
  return Math.log10 ? Math.log10(e) : Math.log(e) / Math.LN10;
}
var Oi2 = {};
for (let e = 0; e < 10; e++) Oi2[String(e)] = String(e);
for (let e = 0; e < 26; e++) Oi2[String.fromCharCode(65 + e)] = String(10 + e);
var vf = Math.floor(d0(l0));
function p0(e) {
  e = e.toUpperCase(), e = e.substring(4) + e.substring(0, 2) + "00";
  let t = e.split("").map((i3) => Oi2[i3]).join("");
  for (; t.length >= vf; ) {
    let i3 = t.substring(0, vf);
    t = parseInt(i3, 10) % 97 + t.substring(i3.length);
  }
  let r3 = String(98 - parseInt(t, 10) % 97);
  for (; r3.length < 2; ) r3 = "0" + r3;
  return r3;
}
function v0(e) {
  let t = null;
  if (typeof e != "string" && yr3.throwArgumentError("invalid address", "address", e), e.match(/^(0x)?[0-9a-fA-F]{40}$/)) e.substring(0, 2) !== "0x" && (e = "0x" + e), t = pf(e), e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && t !== e && yr3.throwArgumentError("bad address checksum", "address", e);
  else if (e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (e.substring(2, 4) !== p0(e) && yr3.throwArgumentError("bad icap checksum", "address", e), t = Ls2(e.substring(4)); t.length < 40; ) t = "0" + t;
    t = pf("0x" + t);
  } else yr3.throwArgumentError("invalid address", "address", e);
  return t;
}
var g0 = "properties/5.7.0";
new z5(g0);
function wr3(e, t, r3) {
  Object.defineProperty(e, t, { enumerable: true, value: r3, writable: false });
}
new z5(uf);
var m0 = new Uint8Array(32);
m0.fill(0), V4.from(-1);
var A0 = V4.from(0);
var b0 = V4.from(1);
V4.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), oe2(b0.toHexString(), 32), oe2(A0.toHexString(), 32);
var se3 = {};
var Q3 = {};
var xr3 = gf;
function gf(e, t) {
  if (!e) throw new Error(t || "Assertion failed");
}
gf.equal = function(t, r3, i3) {
  if (t != r3) throw new Error(i3 || "Assertion failed: " + t + " != " + r3);
};
var Pi3 = { exports: {} };
typeof Object.create == "function" ? Pi3.exports = function(t, r3) {
  r3 && (t.super_ = r3, t.prototype = Object.create(r3.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }));
} : Pi3.exports = function(t, r3) {
  if (r3) {
    t.super_ = r3;
    var i3 = function() {
    };
    i3.prototype = r3.prototype, t.prototype = new i3(), t.prototype.constructor = t;
  }
};
var y0 = xr3;
var w0 = Pi3.exports;
Q3.inherits = w0;
function x0(e, t) {
  return (e.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= e.length ? false : (e.charCodeAt(t + 1) & 64512) === 56320;
}
function M0(e, t) {
  if (Array.isArray(e)) return e.slice();
  if (!e) return [];
  var r3 = [];
  if (typeof e == "string") if (t) {
    if (t === "hex") for (e = e.replace(/[^a-z0-9]+/ig, ""), e.length % 2 !== 0 && (e = "0" + e), n4 = 0; n4 < e.length; n4 += 2) r3.push(parseInt(e[n4] + e[n4 + 1], 16));
  } else for (var i3 = 0, n4 = 0; n4 < e.length; n4++) {
    var o4 = e.charCodeAt(n4);
    o4 < 128 ? r3[i3++] = o4 : o4 < 2048 ? (r3[i3++] = o4 >> 6 | 192, r3[i3++] = o4 & 63 | 128) : x0(e, n4) ? (o4 = 65536 + ((o4 & 1023) << 10) + (e.charCodeAt(++n4) & 1023), r3[i3++] = o4 >> 18 | 240, r3[i3++] = o4 >> 12 & 63 | 128, r3[i3++] = o4 >> 6 & 63 | 128, r3[i3++] = o4 & 63 | 128) : (r3[i3++] = o4 >> 12 | 224, r3[i3++] = o4 >> 6 & 63 | 128, r3[i3++] = o4 & 63 | 128);
  }
  else for (n4 = 0; n4 < e.length; n4++) r3[n4] = e[n4] | 0;
  return r3;
}
Q3.toArray = M0;
function E0(e) {
  for (var t = "", r3 = 0; r3 < e.length; r3++) t += Af(e[r3].toString(16));
  return t;
}
Q3.toHex = E0;
function mf(e) {
  var t = e >>> 24 | e >>> 8 & 65280 | e << 8 & 16711680 | (e & 255) << 24;
  return t >>> 0;
}
Q3.htonl = mf;
function S0(e, t) {
  for (var r3 = "", i3 = 0; i3 < e.length; i3++) {
    var n4 = e[i3];
    t === "little" && (n4 = mf(n4)), r3 += bf(n4.toString(16));
  }
  return r3;
}
Q3.toHex32 = S0;
function Af(e) {
  return e.length === 1 ? "0" + e : e;
}
Q3.zero2 = Af;
function bf(e) {
  return e.length === 7 ? "0" + e : e.length === 6 ? "00" + e : e.length === 5 ? "000" + e : e.length === 4 ? "0000" + e : e.length === 3 ? "00000" + e : e.length === 2 ? "000000" + e : e.length === 1 ? "0000000" + e : e;
}
Q3.zero8 = bf;
function I0(e, t, r3, i3) {
  var n4 = r3 - t;
  y0(n4 % 4 === 0);
  for (var o4 = new Array(n4 / 4), h7 = 0, p5 = t; h7 < o4.length; h7++, p5 += 4) {
    var A5;
    i3 === "big" ? A5 = e[p5] << 24 | e[p5 + 1] << 16 | e[p5 + 2] << 8 | e[p5 + 3] : A5 = e[p5 + 3] << 24 | e[p5 + 2] << 16 | e[p5 + 1] << 8 | e[p5], o4[h7] = A5 >>> 0;
  }
  return o4;
}
Q3.join32 = I0;
function N0(e, t) {
  for (var r3 = new Array(e.length * 4), i3 = 0, n4 = 0; i3 < e.length; i3++, n4 += 4) {
    var o4 = e[i3];
    t === "big" ? (r3[n4] = o4 >>> 24, r3[n4 + 1] = o4 >>> 16 & 255, r3[n4 + 2] = o4 >>> 8 & 255, r3[n4 + 3] = o4 & 255) : (r3[n4 + 3] = o4 >>> 24, r3[n4 + 2] = o4 >>> 16 & 255, r3[n4 + 1] = o4 >>> 8 & 255, r3[n4] = o4 & 255);
  }
  return r3;
}
Q3.split32 = N0;
function _0(e, t) {
  return e >>> t | e << 32 - t;
}
Q3.rotr32 = _0;
function B0(e, t) {
  return e << t | e >>> 32 - t;
}
Q3.rotl32 = B0;
function C0(e, t) {
  return e + t >>> 0;
}
Q3.sum32 = C0;
function R0(e, t, r3) {
  return e + t + r3 >>> 0;
}
Q3.sum32_3 = R0;
function O0(e, t, r3, i3) {
  return e + t + r3 + i3 >>> 0;
}
Q3.sum32_4 = O0;
function P0(e, t, r3, i3, n4) {
  return e + t + r3 + i3 + n4 >>> 0;
}
Q3.sum32_5 = P0;
function T0(e, t, r3, i3) {
  var n4 = e[t], o4 = e[t + 1], h7 = i3 + o4 >>> 0, p5 = (h7 < i3 ? 1 : 0) + r3 + n4;
  e[t] = p5 >>> 0, e[t + 1] = h7;
}
Q3.sum64 = T0;
function D0(e, t, r3, i3) {
  var n4 = t + i3 >>> 0, o4 = (n4 < t ? 1 : 0) + e + r3;
  return o4 >>> 0;
}
Q3.sum64_hi = D0;
function F0(e, t, r3, i3) {
  var n4 = t + i3;
  return n4 >>> 0;
}
Q3.sum64_lo = F0;
function U0(e, t, r3, i3, n4, o4, h7, p5) {
  var A5 = 0, v7 = t;
  v7 = v7 + i3 >>> 0, A5 += v7 < t ? 1 : 0, v7 = v7 + o4 >>> 0, A5 += v7 < o4 ? 1 : 0, v7 = v7 + p5 >>> 0, A5 += v7 < p5 ? 1 : 0;
  var w6 = e + r3 + n4 + h7 + A5;
  return w6 >>> 0;
}
Q3.sum64_4_hi = U0;
function k0(e, t, r3, i3, n4, o4, h7, p5) {
  var A5 = t + i3 + o4 + p5;
  return A5 >>> 0;
}
Q3.sum64_4_lo = k0;
function q0(e, t, r3, i3, n4, o4, h7, p5, A5, v7) {
  var w6 = 0, y10 = t;
  y10 = y10 + i3 >>> 0, w6 += y10 < t ? 1 : 0, y10 = y10 + o4 >>> 0, w6 += y10 < o4 ? 1 : 0, y10 = y10 + p5 >>> 0, w6 += y10 < p5 ? 1 : 0, y10 = y10 + v7 >>> 0, w6 += y10 < v7 ? 1 : 0;
  var S7 = e + r3 + n4 + h7 + A5 + w6;
  return S7 >>> 0;
}
Q3.sum64_5_hi = q0;
function K0(e, t, r3, i3, n4, o4, h7, p5, A5, v7) {
  var w6 = t + i3 + o4 + p5 + v7;
  return w6 >>> 0;
}
Q3.sum64_5_lo = K0;
function H0(e, t, r3) {
  var i3 = t << 32 - r3 | e >>> r3;
  return i3 >>> 0;
}
Q3.rotr64_hi = H0;
function L0(e, t, r3) {
  var i3 = e << 32 - r3 | t >>> r3;
  return i3 >>> 0;
}
Q3.rotr64_lo = L0;
function z0(e, t, r3) {
  return e >>> r3;
}
Q3.shr64_hi = z0;
function j0(e, t, r3) {
  var i3 = e << 32 - r3 | t >>> r3;
  return i3 >>> 0;
}
Q3.shr64_lo = j0;
var or4 = {};
var yf = Q3;
var Q0 = xr3;
function qr3() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
or4.BlockHash = qr3, qr3.prototype.update = function(t, r3) {
  if (t = yf.toArray(t, r3), this.pending ? this.pending = this.pending.concat(t) : this.pending = t, this.pendingTotal += t.length, this.pending.length >= this._delta8) {
    t = this.pending;
    var i3 = t.length % this._delta8;
    this.pending = t.slice(t.length - i3, t.length), this.pending.length === 0 && (this.pending = null), t = yf.join32(t, 0, t.length - i3, this.endian);
    for (var n4 = 0; n4 < t.length; n4 += this._delta32) this._update(t, n4, n4 + this._delta32);
  }
  return this;
}, qr3.prototype.digest = function(t) {
  return this.update(this._pad()), Q0(this.pending === null), this._digest(t);
}, qr3.prototype._pad = function() {
  var t = this.pendingTotal, r3 = this._delta8, i3 = r3 - (t + this.padLength) % r3, n4 = new Array(i3 + this.padLength);
  n4[0] = 128;
  for (var o4 = 1; o4 < i3; o4++) n4[o4] = 0;
  if (t <<= 3, this.endian === "big") {
    for (var h7 = 8; h7 < this.padLength; h7++) n4[o4++] = 0;
    n4[o4++] = 0, n4[o4++] = 0, n4[o4++] = 0, n4[o4++] = 0, n4[o4++] = t >>> 24 & 255, n4[o4++] = t >>> 16 & 255, n4[o4++] = t >>> 8 & 255, n4[o4++] = t & 255;
  } else for (n4[o4++] = t & 255, n4[o4++] = t >>> 8 & 255, n4[o4++] = t >>> 16 & 255, n4[o4++] = t >>> 24 & 255, n4[o4++] = 0, n4[o4++] = 0, n4[o4++] = 0, n4[o4++] = 0, h7 = 8; h7 < this.padLength; h7++) n4[o4++] = 0;
  return n4;
};
var sr3 = {};
var ae2 = {};
var J0 = Q3;
var ue4 = J0.rotr32;
function G0(e, t, r3, i3) {
  if (e === 0) return wf(t, r3, i3);
  if (e === 1 || e === 3) return Mf(t, r3, i3);
  if (e === 2) return xf(t, r3, i3);
}
ae2.ft_1 = G0;
function wf(e, t, r3) {
  return e & t ^ ~e & r3;
}
ae2.ch32 = wf;
function xf(e, t, r3) {
  return e & t ^ e & r3 ^ t & r3;
}
ae2.maj32 = xf;
function Mf(e, t, r3) {
  return e ^ t ^ r3;
}
ae2.p32 = Mf;
function Y0(e) {
  return ue4(e, 2) ^ ue4(e, 13) ^ ue4(e, 22);
}
ae2.s0_256 = Y0;
function V0(e) {
  return ue4(e, 6) ^ ue4(e, 11) ^ ue4(e, 25);
}
ae2.s1_256 = V0;
function W0(e) {
  return ue4(e, 7) ^ ue4(e, 18) ^ e >>> 3;
}
ae2.g0_256 = W0;
function X0(e) {
  return ue4(e, 17) ^ ue4(e, 19) ^ e >>> 10;
}
ae2.g1_256 = X0;
var ar3 = Q3;
var $0 = or4;
var Z0 = ae2;
var Ti3 = ar3.rotl32;
var Mr3 = ar3.sum32;
var ta = ar3.sum32_5;
var ea = Z0.ft_1;
var Ef = $0.BlockHash;
var ra = [1518500249, 1859775393, 2400959708, 3395469782];
function he4() {
  if (!(this instanceof he4)) return new he4();
  Ef.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
}
ar3.inherits(he4, Ef);
var ia = he4;
he4.blockSize = 512, he4.outSize = 160, he4.hmacStrength = 80, he4.padLength = 64, he4.prototype._update = function(t, r3) {
  for (var i3 = this.W, n4 = 0; n4 < 16; n4++) i3[n4] = t[r3 + n4];
  for (; n4 < i3.length; n4++) i3[n4] = Ti3(i3[n4 - 3] ^ i3[n4 - 8] ^ i3[n4 - 14] ^ i3[n4 - 16], 1);
  var o4 = this.h[0], h7 = this.h[1], p5 = this.h[2], A5 = this.h[3], v7 = this.h[4];
  for (n4 = 0; n4 < i3.length; n4++) {
    var w6 = ~~(n4 / 20), y10 = ta(Ti3(o4, 5), ea(w6, h7, p5, A5), v7, i3[n4], ra[w6]);
    v7 = A5, A5 = p5, p5 = Ti3(h7, 30), h7 = o4, o4 = y10;
  }
  this.h[0] = Mr3(this.h[0], o4), this.h[1] = Mr3(this.h[1], h7), this.h[2] = Mr3(this.h[2], p5), this.h[3] = Mr3(this.h[3], A5), this.h[4] = Mr3(this.h[4], v7);
}, he4.prototype._digest = function(t) {
  return t === "hex" ? ar3.toHex32(this.h, "big") : ar3.split32(this.h, "big");
};
var ur3 = Q3;
var na = or4;
var hr3 = ae2;
var fa2 = xr3;
var ie3 = ur3.sum32;
var oa = ur3.sum32_4;
var sa = ur3.sum32_5;
var aa = hr3.ch32;
var ua2 = hr3.maj32;
var ha = hr3.s0_256;
var ca = hr3.s1_256;
var la2 = hr3.g0_256;
var da = hr3.g1_256;
var Sf = na.BlockHash;
var pa = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
function ce2() {
  if (!(this instanceof ce2)) return new ce2();
  Sf.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = pa, this.W = new Array(64);
}
ur3.inherits(ce2, Sf);
var If = ce2;
ce2.blockSize = 512, ce2.outSize = 256, ce2.hmacStrength = 192, ce2.padLength = 64, ce2.prototype._update = function(t, r3) {
  for (var i3 = this.W, n4 = 0; n4 < 16; n4++) i3[n4] = t[r3 + n4];
  for (; n4 < i3.length; n4++) i3[n4] = oa(da(i3[n4 - 2]), i3[n4 - 7], la2(i3[n4 - 15]), i3[n4 - 16]);
  var o4 = this.h[0], h7 = this.h[1], p5 = this.h[2], A5 = this.h[3], v7 = this.h[4], w6 = this.h[5], y10 = this.h[6], S7 = this.h[7];
  for (fa2(this.k.length === i3.length), n4 = 0; n4 < i3.length; n4++) {
    var N4 = sa(S7, ca(v7), aa(v7, w6, y10), this.k[n4], i3[n4]), I5 = ie3(ha(o4), ua2(o4, h7, p5));
    S7 = y10, y10 = w6, w6 = v7, v7 = ie3(A5, N4), A5 = p5, p5 = h7, h7 = o4, o4 = ie3(N4, I5);
  }
  this.h[0] = ie3(this.h[0], o4), this.h[1] = ie3(this.h[1], h7), this.h[2] = ie3(this.h[2], p5), this.h[3] = ie3(this.h[3], A5), this.h[4] = ie3(this.h[4], v7), this.h[5] = ie3(this.h[5], w6), this.h[6] = ie3(this.h[6], y10), this.h[7] = ie3(this.h[7], S7);
}, ce2.prototype._digest = function(t) {
  return t === "hex" ? ur3.toHex32(this.h, "big") : ur3.split32(this.h, "big");
};
var Di3 = Q3;
var Nf = If;
function ye4() {
  if (!(this instanceof ye4)) return new ye4();
  Nf.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
}
Di3.inherits(ye4, Nf);
var va = ye4;
ye4.blockSize = 512, ye4.outSize = 224, ye4.hmacStrength = 192, ye4.padLength = 64, ye4.prototype._digest = function(t) {
  return t === "hex" ? Di3.toHex32(this.h.slice(0, 7), "big") : Di3.split32(this.h.slice(0, 7), "big");
};
var jt4 = Q3;
var ga = or4;
var ma = xr3;
var le3 = jt4.rotr64_hi;
var de3 = jt4.rotr64_lo;
var _f = jt4.shr64_hi;
var Bf = jt4.shr64_lo;
var Be3 = jt4.sum64;
var Fi3 = jt4.sum64_hi;
var Ui3 = jt4.sum64_lo;
var Aa = jt4.sum64_4_hi;
var ba = jt4.sum64_4_lo;
var ya2 = jt4.sum64_5_hi;
var wa = jt4.sum64_5_lo;
var Cf = ga.BlockHash;
var xa = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
function ne3() {
  if (!(this instanceof ne3)) return new ne3();
  Cf.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = xa, this.W = new Array(160);
}
jt4.inherits(ne3, Cf);
var Rf = ne3;
ne3.blockSize = 1024, ne3.outSize = 512, ne3.hmacStrength = 192, ne3.padLength = 128, ne3.prototype._prepareBlock = function(t, r3) {
  for (var i3 = this.W, n4 = 0; n4 < 32; n4++) i3[n4] = t[r3 + n4];
  for (; n4 < i3.length; n4 += 2) {
    var o4 = Pa(i3[n4 - 4], i3[n4 - 3]), h7 = Ta(i3[n4 - 4], i3[n4 - 3]), p5 = i3[n4 - 14], A5 = i3[n4 - 13], v7 = Ra(i3[n4 - 30], i3[n4 - 29]), w6 = Oa(i3[n4 - 30], i3[n4 - 29]), y10 = i3[n4 - 32], S7 = i3[n4 - 31];
    i3[n4] = Aa(o4, h7, p5, A5, v7, w6, y10, S7), i3[n4 + 1] = ba(o4, h7, p5, A5, v7, w6, y10, S7);
  }
}, ne3.prototype._update = function(t, r3) {
  this._prepareBlock(t, r3);
  var i3 = this.W, n4 = this.h[0], o4 = this.h[1], h7 = this.h[2], p5 = this.h[3], A5 = this.h[4], v7 = this.h[5], w6 = this.h[6], y10 = this.h[7], S7 = this.h[8], N4 = this.h[9], I5 = this.h[10], C5 = this.h[11], D5 = this.h[12], U5 = this.h[13], J2 = this.h[14], Bt5 = this.h[15];
  ma(this.k.length === i3.length);
  for (var G5 = 0; G5 < i3.length; G5 += 2) {
    var H3 = J2, L4 = Bt5, Pt5 = Ba2(S7, N4), W3 = Ca(S7, N4), Rt5 = Ma(S7, N4, I5, C5, D5), Vt5 = Ea(S7, N4, I5, C5, D5, U5), Y6 = this.k[G5], Wt5 = this.k[G5 + 1], b6 = i3[G5], f6 = i3[G5 + 1], a5 = ya2(H3, L4, Pt5, W3, Rt5, Vt5, Y6, Wt5, b6, f6), c7 = wa(H3, L4, Pt5, W3, Rt5, Vt5, Y6, Wt5, b6, f6);
    H3 = Na2(n4, o4), L4 = _a(n4, o4), Pt5 = Sa(n4, o4, h7, p5, A5), W3 = Ia2(n4, o4, h7, p5, A5, v7);
    var d5 = Fi3(H3, L4, Pt5, W3), m2 = Ui3(H3, L4, Pt5, W3);
    J2 = D5, Bt5 = U5, D5 = I5, U5 = C5, I5 = S7, C5 = N4, S7 = Fi3(w6, y10, a5, c7), N4 = Ui3(y10, y10, a5, c7), w6 = A5, y10 = v7, A5 = h7, v7 = p5, h7 = n4, p5 = o4, n4 = Fi3(a5, c7, d5, m2), o4 = Ui3(a5, c7, d5, m2);
  }
  Be3(this.h, 0, n4, o4), Be3(this.h, 2, h7, p5), Be3(this.h, 4, A5, v7), Be3(this.h, 6, w6, y10), Be3(this.h, 8, S7, N4), Be3(this.h, 10, I5, C5), Be3(this.h, 12, D5, U5), Be3(this.h, 14, J2, Bt5);
}, ne3.prototype._digest = function(t) {
  return t === "hex" ? jt4.toHex32(this.h, "big") : jt4.split32(this.h, "big");
};
function Ma(e, t, r3, i3, n4) {
  var o4 = e & r3 ^ ~e & n4;
  return o4 < 0 && (o4 += 4294967296), o4;
}
function Ea(e, t, r3, i3, n4, o4) {
  var h7 = t & i3 ^ ~t & o4;
  return h7 < 0 && (h7 += 4294967296), h7;
}
function Sa(e, t, r3, i3, n4) {
  var o4 = e & r3 ^ e & n4 ^ r3 & n4;
  return o4 < 0 && (o4 += 4294967296), o4;
}
function Ia2(e, t, r3, i3, n4, o4) {
  var h7 = t & i3 ^ t & o4 ^ i3 & o4;
  return h7 < 0 && (h7 += 4294967296), h7;
}
function Na2(e, t) {
  var r3 = le3(e, t, 28), i3 = le3(t, e, 2), n4 = le3(t, e, 7), o4 = r3 ^ i3 ^ n4;
  return o4 < 0 && (o4 += 4294967296), o4;
}
function _a(e, t) {
  var r3 = de3(e, t, 28), i3 = de3(t, e, 2), n4 = de3(t, e, 7), o4 = r3 ^ i3 ^ n4;
  return o4 < 0 && (o4 += 4294967296), o4;
}
function Ba2(e, t) {
  var r3 = le3(e, t, 14), i3 = le3(e, t, 18), n4 = le3(t, e, 9), o4 = r3 ^ i3 ^ n4;
  return o4 < 0 && (o4 += 4294967296), o4;
}
function Ca(e, t) {
  var r3 = de3(e, t, 14), i3 = de3(e, t, 18), n4 = de3(t, e, 9), o4 = r3 ^ i3 ^ n4;
  return o4 < 0 && (o4 += 4294967296), o4;
}
function Ra(e, t) {
  var r3 = le3(e, t, 1), i3 = le3(e, t, 8), n4 = _f(e, t, 7), o4 = r3 ^ i3 ^ n4;
  return o4 < 0 && (o4 += 4294967296), o4;
}
function Oa(e, t) {
  var r3 = de3(e, t, 1), i3 = de3(e, t, 8), n4 = Bf(e, t, 7), o4 = r3 ^ i3 ^ n4;
  return o4 < 0 && (o4 += 4294967296), o4;
}
function Pa(e, t) {
  var r3 = le3(e, t, 19), i3 = le3(t, e, 29), n4 = _f(e, t, 6), o4 = r3 ^ i3 ^ n4;
  return o4 < 0 && (o4 += 4294967296), o4;
}
function Ta(e, t) {
  var r3 = de3(e, t, 19), i3 = de3(t, e, 29), n4 = Bf(e, t, 6), o4 = r3 ^ i3 ^ n4;
  return o4 < 0 && (o4 += 4294967296), o4;
}
var ki3 = Q3;
var Of = Rf;
function we3() {
  if (!(this instanceof we3)) return new we3();
  Of.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
}
ki3.inherits(we3, Of);
var Da = we3;
we3.blockSize = 1024, we3.outSize = 384, we3.hmacStrength = 192, we3.padLength = 128, we3.prototype._digest = function(t) {
  return t === "hex" ? ki3.toHex32(this.h.slice(0, 12), "big") : ki3.split32(this.h.slice(0, 12), "big");
}, sr3.sha1 = ia, sr3.sha224 = va, sr3.sha256 = If, sr3.sha384 = Da, sr3.sha512 = Rf;
var Pf = {};
var Xe4 = Q3;
var Fa = or4;
var Kr3 = Xe4.rotl32;
var Tf = Xe4.sum32;
var Er3 = Xe4.sum32_3;
var Df = Xe4.sum32_4;
var Ff = Fa.BlockHash;
function pe4() {
  if (!(this instanceof pe4)) return new pe4();
  Ff.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
Xe4.inherits(pe4, Ff), Pf.ripemd160 = pe4, pe4.blockSize = 512, pe4.outSize = 160, pe4.hmacStrength = 192, pe4.padLength = 64, pe4.prototype._update = function(t, r3) {
  for (var i3 = this.h[0], n4 = this.h[1], o4 = this.h[2], h7 = this.h[3], p5 = this.h[4], A5 = i3, v7 = n4, w6 = o4, y10 = h7, S7 = p5, N4 = 0; N4 < 80; N4++) {
    var I5 = Tf(Kr3(Df(i3, Uf(N4, n4, o4, h7), t[qa[N4] + r3], Ua(N4)), Ha[N4]), p5);
    i3 = p5, p5 = h7, h7 = Kr3(o4, 10), o4 = n4, n4 = I5, I5 = Tf(Kr3(Df(A5, Uf(79 - N4, v7, w6, y10), t[Ka[N4] + r3], ka(N4)), La[N4]), S7), A5 = S7, S7 = y10, y10 = Kr3(w6, 10), w6 = v7, v7 = I5;
  }
  I5 = Er3(this.h[1], o4, y10), this.h[1] = Er3(this.h[2], h7, S7), this.h[2] = Er3(this.h[3], p5, A5), this.h[3] = Er3(this.h[4], i3, v7), this.h[4] = Er3(this.h[0], n4, w6), this.h[0] = I5;
}, pe4.prototype._digest = function(t) {
  return t === "hex" ? Xe4.toHex32(this.h, "little") : Xe4.split32(this.h, "little");
};
function Uf(e, t, r3, i3) {
  return e <= 15 ? t ^ r3 ^ i3 : e <= 31 ? t & r3 | ~t & i3 : e <= 47 ? (t | ~r3) ^ i3 : e <= 63 ? t & i3 | r3 & ~i3 : t ^ (r3 | ~i3);
}
function Ua(e) {
  return e <= 15 ? 0 : e <= 31 ? 1518500249 : e <= 47 ? 1859775393 : e <= 63 ? 2400959708 : 2840853838;
}
function ka(e) {
  return e <= 15 ? 1352829926 : e <= 31 ? 1548603684 : e <= 47 ? 1836072691 : e <= 63 ? 2053994217 : 0;
}
var qa = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var Ka = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var Ha = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var La = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
var za = Q3;
var ja = xr3;
function cr3(e, t, r3) {
  if (!(this instanceof cr3)) return new cr3(e, t, r3);
  this.Hash = e, this.blockSize = e.blockSize / 8, this.outSize = e.outSize / 8, this.inner = null, this.outer = null, this._init(za.toArray(t, r3));
}
var Qa = cr3;
cr3.prototype._init = function(t) {
  t.length > this.blockSize && (t = new this.Hash().update(t).digest()), ja(t.length <= this.blockSize);
  for (var r3 = t.length; r3 < this.blockSize; r3++) t.push(0);
  for (r3 = 0; r3 < t.length; r3++) t[r3] ^= 54;
  for (this.inner = new this.Hash().update(t), r3 = 0; r3 < t.length; r3++) t[r3] ^= 106;
  this.outer = new this.Hash().update(t);
}, cr3.prototype.update = function(t, r3) {
  return this.inner.update(t, r3), this;
}, cr3.prototype.digest = function(t) {
  return this.outer.update(this.inner.digest()), this.outer.digest(t);
}, function(e) {
  var t = e;
  t.utils = Q3, t.common = or4, t.sha = sr3, t.ripemd = Pf, t.hmac = Qa, t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
}(se3);
function lr3(e, t, r3) {
  return r3 = { path: t, exports: {}, require: function(i3, n4) {
    return Ja(i3, n4 ?? r3.path);
  } }, e(r3, r3.exports), r3.exports;
}
function Ja() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var qi3 = kf;
function kf(e, t) {
  if (!e) throw new Error(t || "Assertion failed");
}
kf.equal = function(t, r3, i3) {
  if (t != r3) throw new Error(i3 || "Assertion failed: " + t + " != " + r3);
};
var fe3 = lr3(function(e, t) {
  var r3 = t;
  function i3(h7, p5) {
    if (Array.isArray(h7)) return h7.slice();
    if (!h7) return [];
    var A5 = [];
    if (typeof h7 != "string") {
      for (var v7 = 0; v7 < h7.length; v7++) A5[v7] = h7[v7] | 0;
      return A5;
    }
    if (p5 === "hex") {
      h7 = h7.replace(/[^a-z0-9]+/ig, ""), h7.length % 2 !== 0 && (h7 = "0" + h7);
      for (var v7 = 0; v7 < h7.length; v7 += 2) A5.push(parseInt(h7[v7] + h7[v7 + 1], 16));
    } else for (var v7 = 0; v7 < h7.length; v7++) {
      var w6 = h7.charCodeAt(v7), y10 = w6 >> 8, S7 = w6 & 255;
      y10 ? A5.push(y10, S7) : A5.push(S7);
    }
    return A5;
  }
  r3.toArray = i3;
  function n4(h7) {
    return h7.length === 1 ? "0" + h7 : h7;
  }
  r3.zero2 = n4;
  function o4(h7) {
    for (var p5 = "", A5 = 0; A5 < h7.length; A5++) p5 += n4(h7[A5].toString(16));
    return p5;
  }
  r3.toHex = o4, r3.encode = function(p5, A5) {
    return A5 === "hex" ? o4(p5) : p5;
  };
});
var Gt4 = lr3(function(e, t) {
  var r3 = t;
  r3.assert = qi3, r3.toArray = fe3.toArray, r3.zero2 = fe3.zero2, r3.toHex = fe3.toHex, r3.encode = fe3.encode;
  function i3(A5, v7, w6) {
    var y10 = new Array(Math.max(A5.bitLength(), w6) + 1);
    y10.fill(0);
    for (var S7 = 1 << v7 + 1, N4 = A5.clone(), I5 = 0; I5 < y10.length; I5++) {
      var C5, D5 = N4.andln(S7 - 1);
      N4.isOdd() ? (D5 > (S7 >> 1) - 1 ? C5 = (S7 >> 1) - D5 : C5 = D5, N4.isubn(C5)) : C5 = 0, y10[I5] = C5, N4.iushrn(1);
    }
    return y10;
  }
  r3.getNAF = i3;
  function n4(A5, v7) {
    var w6 = [[], []];
    A5 = A5.clone(), v7 = v7.clone();
    for (var y10 = 0, S7 = 0, N4; A5.cmpn(-y10) > 0 || v7.cmpn(-S7) > 0; ) {
      var I5 = A5.andln(3) + y10 & 3, C5 = v7.andln(3) + S7 & 3;
      I5 === 3 && (I5 = -1), C5 === 3 && (C5 = -1);
      var D5;
      I5 & 1 ? (N4 = A5.andln(7) + y10 & 7, (N4 === 3 || N4 === 5) && C5 === 2 ? D5 = -I5 : D5 = I5) : D5 = 0, w6[0].push(D5);
      var U5;
      C5 & 1 ? (N4 = v7.andln(7) + S7 & 7, (N4 === 3 || N4 === 5) && I5 === 2 ? U5 = -C5 : U5 = C5) : U5 = 0, w6[1].push(U5), 2 * y10 === D5 + 1 && (y10 = 1 - y10), 2 * S7 === U5 + 1 && (S7 = 1 - S7), A5.iushrn(1), v7.iushrn(1);
    }
    return w6;
  }
  r3.getJSF = n4;
  function o4(A5, v7, w6) {
    var y10 = "_" + v7;
    A5.prototype[v7] = function() {
      return this[y10] !== void 0 ? this[y10] : this[y10] = w6.call(this);
    };
  }
  r3.cachedProperty = o4;
  function h7(A5) {
    return typeof A5 == "string" ? r3.toArray(A5, "hex") : A5;
  }
  r3.parseBytes = h7;
  function p5(A5) {
    return new K5(A5, "hex", "le");
  }
  r3.intFromLE = p5;
});
var Hr3 = Gt4.getNAF;
var Ga = Gt4.getJSF;
var Lr3 = Gt4.assert;
function Ce4(e, t) {
  this.type = e, this.p = new K5(t.p, 16), this.red = t.prime ? K5.red(t.prime) : K5.mont(this.p), this.zero = new K5(0).toRed(this.red), this.one = new K5(1).toRed(this.red), this.two = new K5(2).toRed(this.red), this.n = t.n && new K5(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var r3 = this.n && this.p.div(this.n);
  !r3 || r3.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
}
var $e = Ce4;
Ce4.prototype.point = function() {
  throw new Error("Not implemented");
}, Ce4.prototype.validate = function() {
  throw new Error("Not implemented");
}, Ce4.prototype._fixedNafMul = function(t, r3) {
  Lr3(t.precomputed);
  var i3 = t._getDoubles(), n4 = Hr3(r3, 1, this._bitLength), o4 = (1 << i3.step + 1) - (i3.step % 2 === 0 ? 2 : 1);
  o4 /= 3;
  var h7 = [], p5, A5;
  for (p5 = 0; p5 < n4.length; p5 += i3.step) {
    A5 = 0;
    for (var v7 = p5 + i3.step - 1; v7 >= p5; v7--) A5 = (A5 << 1) + n4[v7];
    h7.push(A5);
  }
  for (var w6 = this.jpoint(null, null, null), y10 = this.jpoint(null, null, null), S7 = o4; S7 > 0; S7--) {
    for (p5 = 0; p5 < h7.length; p5++) A5 = h7[p5], A5 === S7 ? y10 = y10.mixedAdd(i3.points[p5]) : A5 === -S7 && (y10 = y10.mixedAdd(i3.points[p5].neg()));
    w6 = w6.add(y10);
  }
  return w6.toP();
}, Ce4.prototype._wnafMul = function(t, r3) {
  var i3 = 4, n4 = t._getNAFPoints(i3);
  i3 = n4.wnd;
  for (var o4 = n4.points, h7 = Hr3(r3, i3, this._bitLength), p5 = this.jpoint(null, null, null), A5 = h7.length - 1; A5 >= 0; A5--) {
    for (var v7 = 0; A5 >= 0 && h7[A5] === 0; A5--) v7++;
    if (A5 >= 0 && v7++, p5 = p5.dblp(v7), A5 < 0) break;
    var w6 = h7[A5];
    Lr3(w6 !== 0), t.type === "affine" ? w6 > 0 ? p5 = p5.mixedAdd(o4[w6 - 1 >> 1]) : p5 = p5.mixedAdd(o4[-w6 - 1 >> 1].neg()) : w6 > 0 ? p5 = p5.add(o4[w6 - 1 >> 1]) : p5 = p5.add(o4[-w6 - 1 >> 1].neg());
  }
  return t.type === "affine" ? p5.toP() : p5;
}, Ce4.prototype._wnafMulAdd = function(t, r3, i3, n4, o4) {
  var h7 = this._wnafT1, p5 = this._wnafT2, A5 = this._wnafT3, v7 = 0, w6, y10, S7;
  for (w6 = 0; w6 < n4; w6++) {
    S7 = r3[w6];
    var N4 = S7._getNAFPoints(t);
    h7[w6] = N4.wnd, p5[w6] = N4.points;
  }
  for (w6 = n4 - 1; w6 >= 1; w6 -= 2) {
    var I5 = w6 - 1, C5 = w6;
    if (h7[I5] !== 1 || h7[C5] !== 1) {
      A5[I5] = Hr3(i3[I5], h7[I5], this._bitLength), A5[C5] = Hr3(i3[C5], h7[C5], this._bitLength), v7 = Math.max(A5[I5].length, v7), v7 = Math.max(A5[C5].length, v7);
      continue;
    }
    var D5 = [r3[I5], null, null, r3[C5]];
    r3[I5].y.cmp(r3[C5].y) === 0 ? (D5[1] = r3[I5].add(r3[C5]), D5[2] = r3[I5].toJ().mixedAdd(r3[C5].neg())) : r3[I5].y.cmp(r3[C5].y.redNeg()) === 0 ? (D5[1] = r3[I5].toJ().mixedAdd(r3[C5]), D5[2] = r3[I5].add(r3[C5].neg())) : (D5[1] = r3[I5].toJ().mixedAdd(r3[C5]), D5[2] = r3[I5].toJ().mixedAdd(r3[C5].neg()));
    var U5 = [-3, -1, -5, -7, 0, 7, 5, 1, 3], J2 = Ga(i3[I5], i3[C5]);
    for (v7 = Math.max(J2[0].length, v7), A5[I5] = new Array(v7), A5[C5] = new Array(v7), y10 = 0; y10 < v7; y10++) {
      var Bt5 = J2[0][y10] | 0, G5 = J2[1][y10] | 0;
      A5[I5][y10] = U5[(Bt5 + 1) * 3 + (G5 + 1)], A5[C5][y10] = 0, p5[I5] = D5;
    }
  }
  var H3 = this.jpoint(null, null, null), L4 = this._wnafT4;
  for (w6 = v7; w6 >= 0; w6--) {
    for (var Pt5 = 0; w6 >= 0; ) {
      var W3 = true;
      for (y10 = 0; y10 < n4; y10++) L4[y10] = A5[y10][w6] | 0, L4[y10] !== 0 && (W3 = false);
      if (!W3) break;
      Pt5++, w6--;
    }
    if (w6 >= 0 && Pt5++, H3 = H3.dblp(Pt5), w6 < 0) break;
    for (y10 = 0; y10 < n4; y10++) {
      var Rt5 = L4[y10];
      Rt5 !== 0 && (Rt5 > 0 ? S7 = p5[y10][Rt5 - 1 >> 1] : Rt5 < 0 && (S7 = p5[y10][-Rt5 - 1 >> 1].neg()), S7.type === "affine" ? H3 = H3.mixedAdd(S7) : H3 = H3.add(S7));
    }
  }
  for (w6 = 0; w6 < n4; w6++) p5[w6] = null;
  return o4 ? H3 : H3.toP();
};
function Zt3(e, t) {
  this.curve = e, this.type = t, this.precomputed = null;
}
Ce4.BasePoint = Zt3, Zt3.prototype.eq = function() {
  throw new Error("Not implemented");
}, Zt3.prototype.validate = function() {
  return this.curve.validate(this);
}, Ce4.prototype.decodePoint = function(t, r3) {
  t = Gt4.toArray(t, r3);
  var i3 = this.p.byteLength();
  if ((t[0] === 4 || t[0] === 6 || t[0] === 7) && t.length - 1 === 2 * i3) {
    t[0] === 6 ? Lr3(t[t.length - 1] % 2 === 0) : t[0] === 7 && Lr3(t[t.length - 1] % 2 === 1);
    var n4 = this.point(t.slice(1, 1 + i3), t.slice(1 + i3, 1 + 2 * i3));
    return n4;
  } else if ((t[0] === 2 || t[0] === 3) && t.length - 1 === i3) return this.pointFromX(t.slice(1, 1 + i3), t[0] === 3);
  throw new Error("Unknown point format");
}, Zt3.prototype.encodeCompressed = function(t) {
  return this.encode(t, true);
}, Zt3.prototype._encode = function(t) {
  var r3 = this.curve.p.byteLength(), i3 = this.getX().toArray("be", r3);
  return t ? [this.getY().isEven() ? 2 : 3].concat(i3) : [4].concat(i3, this.getY().toArray("be", r3));
}, Zt3.prototype.encode = function(t, r3) {
  return Gt4.encode(this._encode(r3), t);
}, Zt3.prototype.precompute = function(t) {
  if (this.precomputed) return this;
  var r3 = { doubles: null, naf: null, beta: null };
  return r3.naf = this._getNAFPoints(8), r3.doubles = this._getDoubles(4, t), r3.beta = this._getBeta(), this.precomputed = r3, this;
}, Zt3.prototype._hasDoubles = function(t) {
  if (!this.precomputed) return false;
  var r3 = this.precomputed.doubles;
  return r3 ? r3.points.length >= Math.ceil((t.bitLength() + 1) / r3.step) : false;
}, Zt3.prototype._getDoubles = function(t, r3) {
  if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
  for (var i3 = [this], n4 = this, o4 = 0; o4 < r3; o4 += t) {
    for (var h7 = 0; h7 < t; h7++) n4 = n4.dbl();
    i3.push(n4);
  }
  return { step: t, points: i3 };
}, Zt3.prototype._getNAFPoints = function(t) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  for (var r3 = [this], i3 = (1 << t) - 1, n4 = i3 === 1 ? null : this.dbl(), o4 = 1; o4 < i3; o4++) r3[o4] = r3[o4 - 1].add(n4);
  return { wnd: t, points: r3 };
}, Zt3.prototype._getBeta = function() {
  return null;
}, Zt3.prototype.dblp = function(t) {
  for (var r3 = this, i3 = 0; i3 < t; i3++) r3 = r3.dbl();
  return r3;
};
var Ki3 = lr3(function(e) {
  typeof Object.create == "function" ? e.exports = function(r3, i3) {
    i3 && (r3.super_ = i3, r3.prototype = Object.create(i3.prototype, { constructor: { value: r3, enumerable: false, writable: true, configurable: true } }));
  } : e.exports = function(r3, i3) {
    if (i3) {
      r3.super_ = i3;
      var n4 = function() {
      };
      n4.prototype = i3.prototype, r3.prototype = new n4(), r3.prototype.constructor = r3;
    }
  };
});
var Ya = Gt4.assert;
function te4(e) {
  $e.call(this, "short", e), this.a = new K5(e.a, 16).toRed(this.red), this.b = new K5(e.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(e), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
Ki3(te4, $e);
var Va = te4;
te4.prototype._getEndomorphism = function(t) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var r3, i3;
    if (t.beta) r3 = new K5(t.beta, 16).toRed(this.red);
    else {
      var n4 = this._getEndoRoots(this.p);
      r3 = n4[0].cmp(n4[1]) < 0 ? n4[0] : n4[1], r3 = r3.toRed(this.red);
    }
    if (t.lambda) i3 = new K5(t.lambda, 16);
    else {
      var o4 = this._getEndoRoots(this.n);
      this.g.mul(o4[0]).x.cmp(this.g.x.redMul(r3)) === 0 ? i3 = o4[0] : (i3 = o4[1], Ya(this.g.mul(i3).x.cmp(this.g.x.redMul(r3)) === 0));
    }
    var h7;
    return t.basis ? h7 = t.basis.map(function(p5) {
      return { a: new K5(p5.a, 16), b: new K5(p5.b, 16) };
    }) : h7 = this._getEndoBasis(i3), { beta: r3, lambda: i3, basis: h7 };
  }
}, te4.prototype._getEndoRoots = function(t) {
  var r3 = t === this.p ? this.red : K5.mont(t), i3 = new K5(2).toRed(r3).redInvm(), n4 = i3.redNeg(), o4 = new K5(3).toRed(r3).redNeg().redSqrt().redMul(i3), h7 = n4.redAdd(o4).fromRed(), p5 = n4.redSub(o4).fromRed();
  return [h7, p5];
}, te4.prototype._getEndoBasis = function(t) {
  for (var r3 = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), i3 = t, n4 = this.n.clone(), o4 = new K5(1), h7 = new K5(0), p5 = new K5(0), A5 = new K5(1), v7, w6, y10, S7, N4, I5, C5, D5 = 0, U5, J2; i3.cmpn(0) !== 0; ) {
    var Bt5 = n4.div(i3);
    U5 = n4.sub(Bt5.mul(i3)), J2 = p5.sub(Bt5.mul(o4));
    var G5 = A5.sub(Bt5.mul(h7));
    if (!y10 && U5.cmp(r3) < 0) v7 = C5.neg(), w6 = o4, y10 = U5.neg(), S7 = J2;
    else if (y10 && ++D5 === 2) break;
    C5 = U5, n4 = i3, i3 = U5, p5 = o4, o4 = J2, A5 = h7, h7 = G5;
  }
  N4 = U5.neg(), I5 = J2;
  var H3 = y10.sqr().add(S7.sqr()), L4 = N4.sqr().add(I5.sqr());
  return L4.cmp(H3) >= 0 && (N4 = v7, I5 = w6), y10.negative && (y10 = y10.neg(), S7 = S7.neg()), N4.negative && (N4 = N4.neg(), I5 = I5.neg()), [{ a: y10, b: S7 }, { a: N4, b: I5 }];
}, te4.prototype._endoSplit = function(t) {
  var r3 = this.endo.basis, i3 = r3[0], n4 = r3[1], o4 = n4.b.mul(t).divRound(this.n), h7 = i3.b.neg().mul(t).divRound(this.n), p5 = o4.mul(i3.a), A5 = h7.mul(n4.a), v7 = o4.mul(i3.b), w6 = h7.mul(n4.b), y10 = t.sub(p5).sub(A5), S7 = v7.add(w6).neg();
  return { k1: y10, k2: S7 };
}, te4.prototype.pointFromX = function(t, r3) {
  t = new K5(t, 16), t.red || (t = t.toRed(this.red));
  var i3 = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b), n4 = i3.redSqrt();
  if (n4.redSqr().redSub(i3).cmp(this.zero) !== 0) throw new Error("invalid point");
  var o4 = n4.fromRed().isOdd();
  return (r3 && !o4 || !r3 && o4) && (n4 = n4.redNeg()), this.point(t, n4);
}, te4.prototype.validate = function(t) {
  if (t.inf) return true;
  var r3 = t.x, i3 = t.y, n4 = this.a.redMul(r3), o4 = r3.redSqr().redMul(r3).redIAdd(n4).redIAdd(this.b);
  return i3.redSqr().redISub(o4).cmpn(0) === 0;
}, te4.prototype._endoWnafMulAdd = function(t, r3, i3) {
  for (var n4 = this._endoWnafT1, o4 = this._endoWnafT2, h7 = 0; h7 < t.length; h7++) {
    var p5 = this._endoSplit(r3[h7]), A5 = t[h7], v7 = A5._getBeta();
    p5.k1.negative && (p5.k1.ineg(), A5 = A5.neg(true)), p5.k2.negative && (p5.k2.ineg(), v7 = v7.neg(true)), n4[h7 * 2] = A5, n4[h7 * 2 + 1] = v7, o4[h7 * 2] = p5.k1, o4[h7 * 2 + 1] = p5.k2;
  }
  for (var w6 = this._wnafMulAdd(1, n4, o4, h7 * 2, i3), y10 = 0; y10 < h7 * 2; y10++) n4[y10] = null, o4[y10] = null;
  return w6;
};
function Dt3(e, t, r3, i3) {
  $e.BasePoint.call(this, e, "affine"), t === null && r3 === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new K5(t, 16), this.y = new K5(r3, 16), i3 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
}
Ki3(Dt3, $e.BasePoint), te4.prototype.point = function(t, r3, i3) {
  return new Dt3(this, t, r3, i3);
}, te4.prototype.pointFromJSON = function(t, r3) {
  return Dt3.fromJSON(this, t, r3);
}, Dt3.prototype._getBeta = function() {
  if (this.curve.endo) {
    var t = this.precomputed;
    if (t && t.beta) return t.beta;
    var r3 = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (t) {
      var i3 = this.curve, n4 = function(o4) {
        return i3.point(o4.x.redMul(i3.endo.beta), o4.y);
      };
      t.beta = r3, r3.precomputed = { beta: null, naf: t.naf && { wnd: t.naf.wnd, points: t.naf.points.map(n4) }, doubles: t.doubles && { step: t.doubles.step, points: t.doubles.points.map(n4) } };
    }
    return r3;
  }
}, Dt3.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
}, Dt3.fromJSON = function(t, r3, i3) {
  typeof r3 == "string" && (r3 = JSON.parse(r3));
  var n4 = t.point(r3[0], r3[1], i3);
  if (!r3[2]) return n4;
  function o4(p5) {
    return t.point(p5[0], p5[1], i3);
  }
  var h7 = r3[2];
  return n4.precomputed = { beta: null, doubles: h7.doubles && { step: h7.doubles.step, points: [n4].concat(h7.doubles.points.map(o4)) }, naf: h7.naf && { wnd: h7.naf.wnd, points: [n4].concat(h7.naf.points.map(o4)) } }, n4;
}, Dt3.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
}, Dt3.prototype.isInfinity = function() {
  return this.inf;
}, Dt3.prototype.add = function(t) {
  if (this.inf) return t;
  if (t.inf) return this;
  if (this.eq(t)) return this.dbl();
  if (this.neg().eq(t)) return this.curve.point(null, null);
  if (this.x.cmp(t.x) === 0) return this.curve.point(null, null);
  var r3 = this.y.redSub(t.y);
  r3.cmpn(0) !== 0 && (r3 = r3.redMul(this.x.redSub(t.x).redInvm()));
  var i3 = r3.redSqr().redISub(this.x).redISub(t.x), n4 = r3.redMul(this.x.redSub(i3)).redISub(this.y);
  return this.curve.point(i3, n4);
}, Dt3.prototype.dbl = function() {
  if (this.inf) return this;
  var t = this.y.redAdd(this.y);
  if (t.cmpn(0) === 0) return this.curve.point(null, null);
  var r3 = this.curve.a, i3 = this.x.redSqr(), n4 = t.redInvm(), o4 = i3.redAdd(i3).redIAdd(i3).redIAdd(r3).redMul(n4), h7 = o4.redSqr().redISub(this.x.redAdd(this.x)), p5 = o4.redMul(this.x.redSub(h7)).redISub(this.y);
  return this.curve.point(h7, p5);
}, Dt3.prototype.getX = function() {
  return this.x.fromRed();
}, Dt3.prototype.getY = function() {
  return this.y.fromRed();
}, Dt3.prototype.mul = function(t) {
  return t = new K5(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t);
}, Dt3.prototype.mulAdd = function(t, r3, i3) {
  var n4 = [this, r3], o4 = [t, i3];
  return this.curve.endo ? this.curve._endoWnafMulAdd(n4, o4) : this.curve._wnafMulAdd(1, n4, o4, 2);
}, Dt3.prototype.jmulAdd = function(t, r3, i3) {
  var n4 = [this, r3], o4 = [t, i3];
  return this.curve.endo ? this.curve._endoWnafMulAdd(n4, o4, true) : this.curve._wnafMulAdd(1, n4, o4, 2, true);
}, Dt3.prototype.eq = function(t) {
  return this === t || this.inf === t.inf && (this.inf || this.x.cmp(t.x) === 0 && this.y.cmp(t.y) === 0);
}, Dt3.prototype.neg = function(t) {
  if (this.inf) return this;
  var r3 = this.curve.point(this.x, this.y.redNeg());
  if (t && this.precomputed) {
    var i3 = this.precomputed, n4 = function(o4) {
      return o4.neg();
    };
    r3.precomputed = { naf: i3.naf && { wnd: i3.naf.wnd, points: i3.naf.points.map(n4) }, doubles: i3.doubles && { step: i3.doubles.step, points: i3.doubles.points.map(n4) } };
  }
  return r3;
}, Dt3.prototype.toJ = function() {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var t = this.curve.jpoint(this.x, this.y, this.curve.one);
  return t;
};
function Ft3(e, t, r3, i3) {
  $e.BasePoint.call(this, e, "jacobian"), t === null && r3 === null && i3 === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new K5(0)) : (this.x = new K5(t, 16), this.y = new K5(r3, 16), this.z = new K5(i3, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
Ki3(Ft3, $e.BasePoint), te4.prototype.jpoint = function(t, r3, i3) {
  return new Ft3(this, t, r3, i3);
}, Ft3.prototype.toP = function() {
  if (this.isInfinity()) return this.curve.point(null, null);
  var t = this.z.redInvm(), r3 = t.redSqr(), i3 = this.x.redMul(r3), n4 = this.y.redMul(r3).redMul(t);
  return this.curve.point(i3, n4);
}, Ft3.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
}, Ft3.prototype.add = function(t) {
  if (this.isInfinity()) return t;
  if (t.isInfinity()) return this;
  var r3 = t.z.redSqr(), i3 = this.z.redSqr(), n4 = this.x.redMul(r3), o4 = t.x.redMul(i3), h7 = this.y.redMul(r3.redMul(t.z)), p5 = t.y.redMul(i3.redMul(this.z)), A5 = n4.redSub(o4), v7 = h7.redSub(p5);
  if (A5.cmpn(0) === 0) return v7.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var w6 = A5.redSqr(), y10 = w6.redMul(A5), S7 = n4.redMul(w6), N4 = v7.redSqr().redIAdd(y10).redISub(S7).redISub(S7), I5 = v7.redMul(S7.redISub(N4)).redISub(h7.redMul(y10)), C5 = this.z.redMul(t.z).redMul(A5);
  return this.curve.jpoint(N4, I5, C5);
}, Ft3.prototype.mixedAdd = function(t) {
  if (this.isInfinity()) return t.toJ();
  if (t.isInfinity()) return this;
  var r3 = this.z.redSqr(), i3 = this.x, n4 = t.x.redMul(r3), o4 = this.y, h7 = t.y.redMul(r3).redMul(this.z), p5 = i3.redSub(n4), A5 = o4.redSub(h7);
  if (p5.cmpn(0) === 0) return A5.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var v7 = p5.redSqr(), w6 = v7.redMul(p5), y10 = i3.redMul(v7), S7 = A5.redSqr().redIAdd(w6).redISub(y10).redISub(y10), N4 = A5.redMul(y10.redISub(S7)).redISub(o4.redMul(w6)), I5 = this.z.redMul(p5);
  return this.curve.jpoint(S7, N4, I5);
}, Ft3.prototype.dblp = function(t) {
  if (t === 0) return this;
  if (this.isInfinity()) return this;
  if (!t) return this.dbl();
  var r3;
  if (this.curve.zeroA || this.curve.threeA) {
    var i3 = this;
    for (r3 = 0; r3 < t; r3++) i3 = i3.dbl();
    return i3;
  }
  var n4 = this.curve.a, o4 = this.curve.tinv, h7 = this.x, p5 = this.y, A5 = this.z, v7 = A5.redSqr().redSqr(), w6 = p5.redAdd(p5);
  for (r3 = 0; r3 < t; r3++) {
    var y10 = h7.redSqr(), S7 = w6.redSqr(), N4 = S7.redSqr(), I5 = y10.redAdd(y10).redIAdd(y10).redIAdd(n4.redMul(v7)), C5 = h7.redMul(S7), D5 = I5.redSqr().redISub(C5.redAdd(C5)), U5 = C5.redISub(D5), J2 = I5.redMul(U5);
    J2 = J2.redIAdd(J2).redISub(N4);
    var Bt5 = w6.redMul(A5);
    r3 + 1 < t && (v7 = v7.redMul(N4)), h7 = D5, A5 = Bt5, w6 = J2;
  }
  return this.curve.jpoint(h7, w6.redMul(o4), A5);
}, Ft3.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
}, Ft3.prototype._zeroDbl = function() {
  var t, r3, i3;
  if (this.zOne) {
    var n4 = this.x.redSqr(), o4 = this.y.redSqr(), h7 = o4.redSqr(), p5 = this.x.redAdd(o4).redSqr().redISub(n4).redISub(h7);
    p5 = p5.redIAdd(p5);
    var A5 = n4.redAdd(n4).redIAdd(n4), v7 = A5.redSqr().redISub(p5).redISub(p5), w6 = h7.redIAdd(h7);
    w6 = w6.redIAdd(w6), w6 = w6.redIAdd(w6), t = v7, r3 = A5.redMul(p5.redISub(v7)).redISub(w6), i3 = this.y.redAdd(this.y);
  } else {
    var y10 = this.x.redSqr(), S7 = this.y.redSqr(), N4 = S7.redSqr(), I5 = this.x.redAdd(S7).redSqr().redISub(y10).redISub(N4);
    I5 = I5.redIAdd(I5);
    var C5 = y10.redAdd(y10).redIAdd(y10), D5 = C5.redSqr(), U5 = N4.redIAdd(N4);
    U5 = U5.redIAdd(U5), U5 = U5.redIAdd(U5), t = D5.redISub(I5).redISub(I5), r3 = C5.redMul(I5.redISub(t)).redISub(U5), i3 = this.y.redMul(this.z), i3 = i3.redIAdd(i3);
  }
  return this.curve.jpoint(t, r3, i3);
}, Ft3.prototype._threeDbl = function() {
  var t, r3, i3;
  if (this.zOne) {
    var n4 = this.x.redSqr(), o4 = this.y.redSqr(), h7 = o4.redSqr(), p5 = this.x.redAdd(o4).redSqr().redISub(n4).redISub(h7);
    p5 = p5.redIAdd(p5);
    var A5 = n4.redAdd(n4).redIAdd(n4).redIAdd(this.curve.a), v7 = A5.redSqr().redISub(p5).redISub(p5);
    t = v7;
    var w6 = h7.redIAdd(h7);
    w6 = w6.redIAdd(w6), w6 = w6.redIAdd(w6), r3 = A5.redMul(p5.redISub(v7)).redISub(w6), i3 = this.y.redAdd(this.y);
  } else {
    var y10 = this.z.redSqr(), S7 = this.y.redSqr(), N4 = this.x.redMul(S7), I5 = this.x.redSub(y10).redMul(this.x.redAdd(y10));
    I5 = I5.redAdd(I5).redIAdd(I5);
    var C5 = N4.redIAdd(N4);
    C5 = C5.redIAdd(C5);
    var D5 = C5.redAdd(C5);
    t = I5.redSqr().redISub(D5), i3 = this.y.redAdd(this.z).redSqr().redISub(S7).redISub(y10);
    var U5 = S7.redSqr();
    U5 = U5.redIAdd(U5), U5 = U5.redIAdd(U5), U5 = U5.redIAdd(U5), r3 = I5.redMul(C5.redISub(t)).redISub(U5);
  }
  return this.curve.jpoint(t, r3, i3);
}, Ft3.prototype._dbl = function() {
  var t = this.curve.a, r3 = this.x, i3 = this.y, n4 = this.z, o4 = n4.redSqr().redSqr(), h7 = r3.redSqr(), p5 = i3.redSqr(), A5 = h7.redAdd(h7).redIAdd(h7).redIAdd(t.redMul(o4)), v7 = r3.redAdd(r3);
  v7 = v7.redIAdd(v7);
  var w6 = v7.redMul(p5), y10 = A5.redSqr().redISub(w6.redAdd(w6)), S7 = w6.redISub(y10), N4 = p5.redSqr();
  N4 = N4.redIAdd(N4), N4 = N4.redIAdd(N4), N4 = N4.redIAdd(N4);
  var I5 = A5.redMul(S7).redISub(N4), C5 = i3.redAdd(i3).redMul(n4);
  return this.curve.jpoint(y10, I5, C5);
}, Ft3.prototype.trpl = function() {
  if (!this.curve.zeroA) return this.dbl().add(this);
  var t = this.x.redSqr(), r3 = this.y.redSqr(), i3 = this.z.redSqr(), n4 = r3.redSqr(), o4 = t.redAdd(t).redIAdd(t), h7 = o4.redSqr(), p5 = this.x.redAdd(r3).redSqr().redISub(t).redISub(n4);
  p5 = p5.redIAdd(p5), p5 = p5.redAdd(p5).redIAdd(p5), p5 = p5.redISub(h7);
  var A5 = p5.redSqr(), v7 = n4.redIAdd(n4);
  v7 = v7.redIAdd(v7), v7 = v7.redIAdd(v7), v7 = v7.redIAdd(v7);
  var w6 = o4.redIAdd(p5).redSqr().redISub(h7).redISub(A5).redISub(v7), y10 = r3.redMul(w6);
  y10 = y10.redIAdd(y10), y10 = y10.redIAdd(y10);
  var S7 = this.x.redMul(A5).redISub(y10);
  S7 = S7.redIAdd(S7), S7 = S7.redIAdd(S7);
  var N4 = this.y.redMul(w6.redMul(v7.redISub(w6)).redISub(p5.redMul(A5)));
  N4 = N4.redIAdd(N4), N4 = N4.redIAdd(N4), N4 = N4.redIAdd(N4);
  var I5 = this.z.redAdd(p5).redSqr().redISub(i3).redISub(A5);
  return this.curve.jpoint(S7, N4, I5);
}, Ft3.prototype.mul = function(t, r3) {
  return t = new K5(t, r3), this.curve._wnafMul(this, t);
}, Ft3.prototype.eq = function(t) {
  if (t.type === "affine") return this.eq(t.toJ());
  if (this === t) return true;
  var r3 = this.z.redSqr(), i3 = t.z.redSqr();
  if (this.x.redMul(i3).redISub(t.x.redMul(r3)).cmpn(0) !== 0) return false;
  var n4 = r3.redMul(this.z), o4 = i3.redMul(t.z);
  return this.y.redMul(o4).redISub(t.y.redMul(n4)).cmpn(0) === 0;
}, Ft3.prototype.eqXToP = function(t) {
  var r3 = this.z.redSqr(), i3 = t.toRed(this.curve.red).redMul(r3);
  if (this.x.cmp(i3) === 0) return true;
  for (var n4 = t.clone(), o4 = this.curve.redN.redMul(r3); ; ) {
    if (n4.iadd(this.curve.n), n4.cmp(this.curve.p) >= 0) return false;
    if (i3.redIAdd(o4), this.x.cmp(i3) === 0) return true;
  }
}, Ft3.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
}, Ft3.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var zr4 = lr3(function(e, t) {
  var r3 = t;
  r3.base = $e, r3.short = Va, r3.mont = null, r3.edwards = null;
});
var jr3 = lr3(function(e, t) {
  var r3 = t, i3 = Gt4.assert;
  function n4(p5) {
    p5.type === "short" ? this.curve = new zr4.short(p5) : p5.type === "edwards" ? this.curve = new zr4.edwards(p5) : this.curve = new zr4.mont(p5), this.g = this.curve.g, this.n = this.curve.n, this.hash = p5.hash, i3(this.g.validate(), "Invalid curve"), i3(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  r3.PresetCurve = n4;
  function o4(p5, A5) {
    Object.defineProperty(r3, p5, { configurable: true, enumerable: true, get: function() {
      var v7 = new n4(A5);
      return Object.defineProperty(r3, p5, { configurable: true, enumerable: true, value: v7 }), v7;
    } });
  }
  o4("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: se3.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), o4("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: se3.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), o4("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: se3.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), o4("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: se3.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), o4("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: se3.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), o4("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: se3.sha256, gRed: false, g: ["9"] }), o4("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: se3.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
  var h7;
  try {
    h7 = null.crash();
  } catch {
    h7 = void 0;
  }
  o4("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: se3.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", h7] });
});
function Re2(e) {
  if (!(this instanceof Re2)) return new Re2(e);
  this.hash = e.hash, this.predResist = !!e.predResist, this.outLen = this.hash.outSize, this.minEntropy = e.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = fe3.toArray(e.entropy, e.entropyEnc || "hex"), r3 = fe3.toArray(e.nonce, e.nonceEnc || "hex"), i3 = fe3.toArray(e.pers, e.persEnc || "hex");
  qi3(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(t, r3, i3);
}
var qf = Re2;
Re2.prototype._init = function(t, r3, i3) {
  var n4 = t.concat(r3).concat(i3);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var o4 = 0; o4 < this.V.length; o4++) this.K[o4] = 0, this.V[o4] = 1;
  this._update(n4), this._reseed = 1, this.reseedInterval = 281474976710656;
}, Re2.prototype._hmac = function() {
  return new se3.hmac(this.hash, this.K);
}, Re2.prototype._update = function(t) {
  var r3 = this._hmac().update(this.V).update([0]);
  t && (r3 = r3.update(t)), this.K = r3.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest());
}, Re2.prototype.reseed = function(t, r3, i3, n4) {
  typeof r3 != "string" && (n4 = i3, i3 = r3, r3 = null), t = fe3.toArray(t, r3), i3 = fe3.toArray(i3, n4), qi3(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(t.concat(i3 || [])), this._reseed = 1;
}, Re2.prototype.generate = function(t, r3, i3, n4) {
  if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
  typeof r3 != "string" && (n4 = i3, i3 = r3, r3 = null), i3 && (i3 = fe3.toArray(i3, n4 || "hex"), this._update(i3));
  for (var o4 = []; o4.length < t; ) this.V = this._hmac().update(this.V).digest(), o4 = o4.concat(this.V);
  var h7 = o4.slice(0, t);
  return this._update(i3), this._reseed++, fe3.encode(h7, r3);
};
var Hi2 = Gt4.assert;
function kt4(e, t) {
  this.ec = e, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
}
var Li3 = kt4;
kt4.fromPublic = function(t, r3, i3) {
  return r3 instanceof kt4 ? r3 : new kt4(t, { pub: r3, pubEnc: i3 });
}, kt4.fromPrivate = function(t, r3, i3) {
  return r3 instanceof kt4 ? r3 : new kt4(t, { priv: r3, privEnc: i3 });
}, kt4.prototype.validate = function() {
  var t = this.getPublic();
  return t.isInfinity() ? { result: false, reason: "Invalid public key" } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
}, kt4.prototype.getPublic = function(t, r3) {
  return typeof t == "string" && (r3 = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r3 ? this.pub.encode(r3, t) : this.pub;
}, kt4.prototype.getPrivate = function(t) {
  return t === "hex" ? this.priv.toString(16, 2) : this.priv;
}, kt4.prototype._importPrivate = function(t, r3) {
  this.priv = new K5(t, r3 || 16), this.priv = this.priv.umod(this.ec.curve.n);
}, kt4.prototype._importPublic = function(t, r3) {
  if (t.x || t.y) {
    this.ec.curve.type === "mont" ? Hi2(t.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Hi2(t.x && t.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(t.x, t.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(t, r3);
}, kt4.prototype.derive = function(t) {
  return t.validate() || Hi2(t.validate(), "public point not validated"), t.mul(this.priv).getX();
}, kt4.prototype.sign = function(t, r3, i3) {
  return this.ec.sign(t, this, r3, i3);
}, kt4.prototype.verify = function(t, r3) {
  return this.ec.verify(t, r3, this);
}, kt4.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var Wa = Gt4.assert;
function Qr3(e, t) {
  if (e instanceof Qr3) return e;
  this._importDER(e, t) || (Wa(e.r && e.s, "Signature without r or s"), this.r = new K5(e.r, 16), this.s = new K5(e.s, 16), e.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = e.recoveryParam);
}
var Jr3 = Qr3;
function Xa() {
  this.place = 0;
}
function zi3(e, t) {
  var r3 = e[t.place++];
  if (!(r3 & 128)) return r3;
  var i3 = r3 & 15;
  if (i3 === 0 || i3 > 4) return false;
  for (var n4 = 0, o4 = 0, h7 = t.place; o4 < i3; o4++, h7++) n4 <<= 8, n4 |= e[h7], n4 >>>= 0;
  return n4 <= 127 ? false : (t.place = h7, n4);
}
function Kf(e) {
  for (var t = 0, r3 = e.length - 1; !e[t] && !(e[t + 1] & 128) && t < r3; ) t++;
  return t === 0 ? e : e.slice(t);
}
Qr3.prototype._importDER = function(t, r3) {
  t = Gt4.toArray(t, r3);
  var i3 = new Xa();
  if (t[i3.place++] !== 48) return false;
  var n4 = zi3(t, i3);
  if (n4 === false || n4 + i3.place !== t.length || t[i3.place++] !== 2) return false;
  var o4 = zi3(t, i3);
  if (o4 === false) return false;
  var h7 = t.slice(i3.place, o4 + i3.place);
  if (i3.place += o4, t[i3.place++] !== 2) return false;
  var p5 = zi3(t, i3);
  if (p5 === false || t.length !== p5 + i3.place) return false;
  var A5 = t.slice(i3.place, p5 + i3.place);
  if (h7[0] === 0) if (h7[1] & 128) h7 = h7.slice(1);
  else return false;
  if (A5[0] === 0) if (A5[1] & 128) A5 = A5.slice(1);
  else return false;
  return this.r = new K5(h7), this.s = new K5(A5), this.recoveryParam = null, true;
};
function ji3(e, t) {
  if (t < 128) {
    e.push(t);
    return;
  }
  var r3 = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (e.push(r3 | 128); --r3; ) e.push(t >>> (r3 << 3) & 255);
  e.push(t);
}
Qr3.prototype.toDER = function(t) {
  var r3 = this.r.toArray(), i3 = this.s.toArray();
  for (r3[0] & 128 && (r3 = [0].concat(r3)), i3[0] & 128 && (i3 = [0].concat(i3)), r3 = Kf(r3), i3 = Kf(i3); !i3[0] && !(i3[1] & 128); ) i3 = i3.slice(1);
  var n4 = [2];
  ji3(n4, r3.length), n4 = n4.concat(r3), n4.push(2), ji3(n4, i3.length);
  var o4 = n4.concat(i3), h7 = [48];
  return ji3(h7, o4.length), h7 = h7.concat(o4), Gt4.encode(h7, t);
};
var $a = function() {
  throw new Error("unsupported");
};
var Hf = Gt4.assert;
function ee4(e) {
  if (!(this instanceof ee4)) return new ee4(e);
  typeof e == "string" && (Hf(Object.prototype.hasOwnProperty.call(jr3, e), "Unknown curve " + e), e = jr3[e]), e instanceof jr3.PresetCurve && (e = { curve: e }), this.curve = e.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e.curve.g, this.g.precompute(e.curve.n.bitLength() + 1), this.hash = e.hash || e.curve.hash;
}
var Za = ee4;
ee4.prototype.keyPair = function(t) {
  return new Li3(this, t);
}, ee4.prototype.keyFromPrivate = function(t, r3) {
  return Li3.fromPrivate(this, t, r3);
}, ee4.prototype.keyFromPublic = function(t, r3) {
  return Li3.fromPublic(this, t, r3);
}, ee4.prototype.genKeyPair = function(t) {
  t || (t = {});
  for (var r3 = new qf({ hash: this.hash, pers: t.pers, persEnc: t.persEnc || "utf8", entropy: t.entropy || $a(this.hash.hmacStrength), entropyEnc: t.entropy && t.entropyEnc || "utf8", nonce: this.n.toArray() }), i3 = this.n.byteLength(), n4 = this.n.sub(new K5(2)); ; ) {
    var o4 = new K5(r3.generate(i3));
    if (!(o4.cmp(n4) > 0)) return o4.iaddn(1), this.keyFromPrivate(o4);
  }
}, ee4.prototype._truncateToN = function(t, r3) {
  var i3 = t.byteLength() * 8 - this.n.bitLength();
  return i3 > 0 && (t = t.ushrn(i3)), !r3 && t.cmp(this.n) >= 0 ? t.sub(this.n) : t;
}, ee4.prototype.sign = function(t, r3, i3, n4) {
  typeof i3 == "object" && (n4 = i3, i3 = null), n4 || (n4 = {}), r3 = this.keyFromPrivate(r3, i3), t = this._truncateToN(new K5(t, 16));
  for (var o4 = this.n.byteLength(), h7 = r3.getPrivate().toArray("be", o4), p5 = t.toArray("be", o4), A5 = new qf({ hash: this.hash, entropy: h7, nonce: p5, pers: n4.pers, persEnc: n4.persEnc || "utf8" }), v7 = this.n.sub(new K5(1)), w6 = 0; ; w6++) {
    var y10 = n4.k ? n4.k(w6) : new K5(A5.generate(this.n.byteLength()));
    if (y10 = this._truncateToN(y10, true), !(y10.cmpn(1) <= 0 || y10.cmp(v7) >= 0)) {
      var S7 = this.g.mul(y10);
      if (!S7.isInfinity()) {
        var N4 = S7.getX(), I5 = N4.umod(this.n);
        if (I5.cmpn(0) !== 0) {
          var C5 = y10.invm(this.n).mul(I5.mul(r3.getPrivate()).iadd(t));
          if (C5 = C5.umod(this.n), C5.cmpn(0) !== 0) {
            var D5 = (S7.getY().isOdd() ? 1 : 0) | (N4.cmp(I5) !== 0 ? 2 : 0);
            return n4.canonical && C5.cmp(this.nh) > 0 && (C5 = this.n.sub(C5), D5 ^= 1), new Jr3({ r: I5, s: C5, recoveryParam: D5 });
          }
        }
      }
    }
  }
}, ee4.prototype.verify = function(t, r3, i3, n4) {
  t = this._truncateToN(new K5(t, 16)), i3 = this.keyFromPublic(i3, n4), r3 = new Jr3(r3, "hex");
  var o4 = r3.r, h7 = r3.s;
  if (o4.cmpn(1) < 0 || o4.cmp(this.n) >= 0 || h7.cmpn(1) < 0 || h7.cmp(this.n) >= 0) return false;
  var p5 = h7.invm(this.n), A5 = p5.mul(t).umod(this.n), v7 = p5.mul(o4).umod(this.n), w6;
  return this.curve._maxwellTrick ? (w6 = this.g.jmulAdd(A5, i3.getPublic(), v7), w6.isInfinity() ? false : w6.eqXToP(o4)) : (w6 = this.g.mulAdd(A5, i3.getPublic(), v7), w6.isInfinity() ? false : w6.getX().umod(this.n).cmp(o4) === 0);
}, ee4.prototype.recoverPubKey = function(e, t, r3, i3) {
  Hf((3 & r3) === r3, "The recovery param is more than two bits"), t = new Jr3(t, i3);
  var n4 = this.n, o4 = new K5(e), h7 = t.r, p5 = t.s, A5 = r3 & 1, v7 = r3 >> 1;
  if (h7.cmp(this.curve.p.umod(this.curve.n)) >= 0 && v7) throw new Error("Unable to find sencond key candinate");
  v7 ? h7 = this.curve.pointFromX(h7.add(this.curve.n), A5) : h7 = this.curve.pointFromX(h7, A5);
  var w6 = t.r.invm(n4), y10 = n4.sub(o4).mul(w6).umod(n4), S7 = p5.mul(w6).umod(n4);
  return this.g.mulAdd(y10, h7, S7);
}, ee4.prototype.getKeyRecoveryParam = function(e, t, r3, i3) {
  if (t = new Jr3(t, i3), t.recoveryParam !== null) return t.recoveryParam;
  for (var n4 = 0; n4 < 4; n4++) {
    var o4;
    try {
      o4 = this.recoverPubKey(e, t, n4);
    } catch {
      continue;
    }
    if (o4.eq(r3)) return n4;
  }
  throw new Error("Unable to find valid recovery factor");
};
var tu = lr3(function(e, t) {
  var r3 = t;
  r3.version = "6.5.4", r3.utils = Gt4, r3.rand = function() {
    throw new Error("unsupported");
  }, r3.curve = zr4, r3.curves = jr3, r3.ec = Za, r3.eddsa = null;
});
var eu = tu.ec;
var ru = "signing-key/5.7.0";
var Qi = new z5(ru);
var Ji = null;
function ve2() {
  return Ji || (Ji = new eu("secp256k1")), Ji;
}
var iu = class {
  constructor(t) {
    wr3(this, "curve", "secp256k1"), wr3(this, "privateKey", Kt4(t)), Us2(this.privateKey) !== 32 && Qi.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const r3 = ve2().keyFromPrivate(Ot4(this.privateKey));
    wr3(this, "publicKey", "0x" + r3.getPublic(false, "hex")), wr3(this, "compressedPublicKey", "0x" + r3.getPublic(true, "hex")), wr3(this, "_isSigningKey", true);
  }
  _addPoint(t) {
    const r3 = ve2().keyFromPublic(Ot4(this.publicKey)), i3 = ve2().keyFromPublic(Ot4(t));
    return "0x" + r3.pub.add(i3.pub).encodeCompressed("hex");
  }
  signDigest(t) {
    const r3 = ve2().keyFromPrivate(Ot4(this.privateKey)), i3 = Ot4(t);
    i3.length !== 32 && Qi.throwArgumentError("bad digest length", "digest", t);
    const n4 = r3.sign(i3, { canonical: true });
    return Wn3({ recoveryParam: n4.recoveryParam, r: oe2("0x" + n4.r.toString(16), 32), s: oe2("0x" + n4.s.toString(16), 32) });
  }
  computeSharedSecret(t) {
    const r3 = ve2().keyFromPrivate(Ot4(this.privateKey)), i3 = ve2().keyFromPublic(Ot4(Lf(t)));
    return oe2("0x" + r3.derive(i3.getPublic()).toString(16), 32);
  }
  static isSigningKey(t) {
    return !!(t && t._isSigningKey);
  }
};
function nu(e, t) {
  const r3 = Wn3(t), i3 = { r: Ot4(r3.r), s: Ot4(r3.s) };
  return "0x" + ve2().recoverPubKey(Ot4(e), i3, r3.recoveryParam).encode("hex", false);
}
function Lf(e, t) {
  const r3 = Ot4(e);
  if (r3.length === 32) {
    const i3 = new iu(r3);
    return t ? "0x" + ve2().keyFromPrivate(r3).getPublic(true, "hex") : i3.publicKey;
  } else {
    if (r3.length === 33) return t ? Kt4(r3) : "0x" + ve2().keyFromPublic(r3).getPublic(false, "hex");
    if (r3.length === 65) return t ? "0x" + ve2().keyFromPublic(r3).getPublic(true, "hex") : Kt4(r3);
  }
  return Qi.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var fu = "transactions/5.7.0";
new z5(fu);
var zf;
(function(e) {
  e[e.legacy = 0] = "legacy", e[e.eip2930 = 1] = "eip2930", e[e.eip1559 = 2] = "eip1559";
})(zf || (zf = {}));
function ou(e) {
  const t = Lf(e);
  return v0(Vn3(Ii3(Vn3(t, 1)), 12));
}
function su(e, t) {
  return ou(nu(Ot4(e), t));
}
var au = "https://rpc.walletconnect.org/v1";
async function jf(e, t, r3, i3, n4, o4) {
  switch (r3.t) {
    case "eip191":
      return Qf(e, t, r3.s);
    case "eip1271":
      return await Jf(e, t, r3.s, i3, n4, o4);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${r3.t}`);
  }
}
function Qf(e, t, r3) {
  return su(df(t), r3).toLowerCase() === e.toLowerCase();
}
async function Jf(e, t, r3, i3, n4, o4) {
  try {
    const h7 = "0x1626ba7e", p5 = "0000000000000000000000000000000000000000000000000000000000000040", A5 = "0000000000000000000000000000000000000000000000000000000000000041", v7 = r3.substring(2), w6 = df(t).substring(2), y10 = h7 + w6 + p5 + A5 + v7, S7 = await fetch(`${o4 || au}/?chainId=${i3}&projectId=${n4}`, { method: "POST", body: JSON.stringify({ id: uu(), jsonrpc: "2.0", method: "eth_call", params: [{ to: e, data: y10 }, "latest"] }) }), { result: N4 } = await S7.json();
    return N4 ? N4.slice(0, h7.length).toLowerCase() === h7.toLowerCase() : false;
  } catch (h7) {
    return console.error("isValidEip1271Signature: ", h7), false;
  }
}
function uu() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var hu = Object.defineProperty;
var cu = Object.defineProperties;
var lu = Object.getOwnPropertyDescriptors;
var Gf = Object.getOwnPropertySymbols;
var du = Object.prototype.hasOwnProperty;
var pu = Object.prototype.propertyIsEnumerable;
var Yf = (e, t, r3) => t in e ? hu(e, t, { enumerable: true, configurable: true, writable: true, value: r3 }) : e[t] = r3;
var Gi3 = (e, t) => {
  for (var r3 in t || (t = {})) du.call(t, r3) && Yf(e, r3, t[r3]);
  if (Gf) for (var r3 of Gf(t)) pu.call(t, r3) && Yf(e, r3, t[r3]);
  return e;
};
var Vf = (e, t) => cu(e, lu(t));
var vu = "did:pkh:";
var Gr3 = (e) => e == null ? void 0 : e.split(":");
var Yi2 = (e) => {
  const t = e && Gr3(e);
  if (t) return e.includes(vu) ? t[3] : t[1];
};
var gu = (e) => {
  const t = e && Gr3(e);
  if (t) return t[2] + ":" + t[3];
};
var Vi3 = (e) => {
  const t = e && Gr3(e);
  if (t) return t.pop();
};
async function mu(e) {
  const { cacao: t, projectId: r3 } = e, { s: i3, p: n4 } = t, o4 = Wf(n4, n4.iss), h7 = Vi3(n4.iss);
  return await jf(h7, o4, i3, Yi2(n4.iss), r3);
}
var Wf = (e, t) => {
  const r3 = `${e.domain} wants you to sign in with your Ethereum account:`, i3 = Vi3(t);
  if (!e.aud && !e.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let n4 = e.statement || void 0;
  const o4 = `URI: ${e.aud || e.uri}`, h7 = `Version: ${e.version}`, p5 = `Chain ID: ${Yi2(t)}`, A5 = `Nonce: ${e.nonce}`, v7 = `Issued At: ${e.iat}`, w6 = e.exp ? `Expiration Time: ${e.exp}` : void 0, y10 = e.nbf ? `Not Before: ${e.nbf}` : void 0, S7 = e.requestId ? `Request ID: ${e.requestId}` : void 0, N4 = e.resources ? `Resources:${e.resources.map((C5) => `
- ${C5}`).join("")}` : void 0, I5 = Vr3(e.resources);
  if (I5) {
    const C5 = Oe(I5);
    n4 = $i3(n4, C5);
  }
  return [r3, i3, "", n4, "", o4, h7, p5, A5, v7, w6, y10, S7, N4].filter((C5) => C5 != null).join(`
`);
};
function to3(e) {
  return Buffer.from(JSON.stringify(e)).toString("base64");
}
function eo3(e) {
  return JSON.parse(Buffer.from(e, "base64").toString("utf-8"));
}
function ge4(e) {
  if (!e) throw new Error("No recap provided, value is undefined");
  if (!e.att) throw new Error("No `att` property found");
  const t = Object.keys(e.att);
  if (!(t != null && t.length)) throw new Error("No resources found in `att` property");
  t.forEach((r3) => {
    const i3 = e.att[r3];
    if (Array.isArray(i3)) throw new Error(`Resource must be an object: ${r3}`);
    if (typeof i3 != "object") throw new Error(`Resource must be an object: ${r3}`);
    if (!Object.keys(i3).length) throw new Error(`Resource object is empty: ${r3}`);
    Object.keys(i3).forEach((n4) => {
      const o4 = i3[n4];
      if (!Array.isArray(o4)) throw new Error(`Ability limits ${n4} must be an array of objects, found: ${o4}`);
      if (!o4.length) throw new Error(`Value of ${n4} is empty array, must be an array with objects`);
      o4.forEach((h7) => {
        if (typeof h7 != "object") throw new Error(`Ability limits (${n4}) must be an array of objects, found: ${h7}`);
      });
    });
  });
}
function ro3(e, t, r3, i3 = {}) {
  return r3 == null ? void 0 : r3.sort((n4, o4) => n4.localeCompare(o4)), { att: { [e]: Wi(t, r3, i3) } };
}
function Wi(e, t, r3 = {}) {
  t = t == null ? void 0 : t.sort((n4, o4) => n4.localeCompare(o4));
  const i3 = t.map((n4) => ({ [`${e}/${n4}`]: [r3] }));
  return Object.assign({}, ...i3);
}
function Yr3(e) {
  return ge4(e), `urn:recap:${to3(e).replace(/=/g, "")}`;
}
function Oe(e) {
  const t = eo3(e.replace("urn:recap:", ""));
  return ge4(t), t;
}
function xu(e, t, r3) {
  const i3 = ro3(e, t, r3);
  return Yr3(i3);
}
function Xi(e) {
  return e && e.includes("urn:recap:");
}
function Mu(e, t) {
  const r3 = Oe(e), i3 = Oe(t), n4 = no3(r3, i3);
  return Yr3(n4);
}
function no3(e, t) {
  ge4(e), ge4(t);
  const r3 = Object.keys(e.att).concat(Object.keys(t.att)).sort((n4, o4) => n4.localeCompare(o4)), i3 = { att: {} };
  return r3.forEach((n4) => {
    var o4, h7;
    Object.keys(((o4 = e.att) == null ? void 0 : o4[n4]) || {}).concat(Object.keys(((h7 = t.att) == null ? void 0 : h7[n4]) || {})).sort((p5, A5) => p5.localeCompare(A5)).forEach((p5) => {
      var A5, v7;
      i3.att[n4] = Vf(Gi3({}, i3.att[n4]), { [p5]: ((A5 = e.att[n4]) == null ? void 0 : A5[p5]) || ((v7 = t.att[n4]) == null ? void 0 : v7[p5]) });
    });
  }), i3;
}
function $i3(e = "", t) {
  ge4(t);
  const r3 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (e.includes(r3)) return e;
  const i3 = [];
  let n4 = 0;
  Object.keys(t.att).forEach((p5) => {
    const A5 = Object.keys(t.att[p5]).map((y10) => ({ ability: y10.split("/")[0], action: y10.split("/")[1] }));
    A5.sort((y10, S7) => y10.action.localeCompare(S7.action));
    const v7 = {};
    A5.forEach((y10) => {
      v7[y10.ability] || (v7[y10.ability] = []), v7[y10.ability].push(y10.action);
    });
    const w6 = Object.keys(v7).map((y10) => (n4++, `(${n4}) '${y10}': '${v7[y10].join("', '")}' for '${p5}'.`));
    i3.push(w6.join(", ").replace(".,", "."));
  });
  const o4 = i3.join(" "), h7 = `${r3}${o4}`;
  return `${e ? e + " " : ""}${h7}`;
}
function Eu(e) {
  var t;
  const r3 = Oe(e);
  ge4(r3);
  const i3 = (t = r3.att) == null ? void 0 : t.eip155;
  return i3 ? Object.keys(i3).map((n4) => n4.split("/")[1]) : [];
}
function Su(e) {
  const t = Oe(e);
  ge4(t);
  const r3 = [];
  return Object.values(t.att).forEach((i3) => {
    Object.values(i3).forEach((n4) => {
      var o4;
      (o4 = n4 == null ? void 0 : n4[0]) != null && o4.chains && r3.push(n4[0].chains);
    });
  }), [...new Set(r3.flat())];
}
function Vr3(e) {
  if (!e) return;
  const t = e == null ? void 0 : e[e.length - 1];
  return Xi(t) ? t : void 0;
}
var Zi2 = "base10";
var Lt4 = "base16";
var tn3 = "base64pad";
var Iu = "base64url";
var dr3 = "utf8";
var en3 = 0;
var pr3 = 1;
var Sr4 = 2;
var Nu = 0;
var oo3 = 1;
var Ir3 = 12;
var rn3 = 32;
function _u() {
  const e = mn2.generateKeyPair();
  return { privateKey: toString3(e.secretKey, Lt4), publicKey: toString3(e.publicKey, Lt4) };
}
function Bu() {
  const e = (0, import_random3.randomBytes)(rn3);
  return toString3(e, Lt4);
}
function Cu(e, t) {
  const r3 = mn2.sharedKey(fromString3(e, Lt4), fromString3(t, Lt4), true), i3 = new import_hkdf.HKDF(import_sha2562.SHA256, r3).expand(rn3);
  return toString3(i3, Lt4);
}
function Ru(e) {
  const t = (0, import_sha2562.hash)(fromString3(e, Lt4));
  return toString3(t, Lt4);
}
function Ou(e) {
  const t = (0, import_sha2562.hash)(fromString3(e, dr3));
  return toString3(t, Lt4);
}
function nn3(e) {
  return fromString3(`${e}`, Zi2);
}
function Ze4(e) {
  return Number(toString3(e, Zi2));
}
function Pu(e) {
  const t = nn3(typeof e.type < "u" ? e.type : en3);
  if (Ze4(t) === pr3 && typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const r3 = typeof e.senderPublicKey < "u" ? fromString3(e.senderPublicKey, Lt4) : void 0, i3 = typeof e.iv < "u" ? fromString3(e.iv, Lt4) : (0, import_random3.randomBytes)(Ir3), n4 = new import_chacha20poly1305.ChaCha20Poly1305(fromString3(e.symKey, Lt4)).seal(i3, fromString3(e.message, dr3));
  return fn3({ type: t, sealed: n4, iv: i3, senderPublicKey: r3, encoding: e.encoding });
}
function Tu(e, t) {
  const r3 = nn3(Sr4), i3 = (0, import_random3.randomBytes)(Ir3), n4 = fromString3(e, dr3);
  return fn3({ type: r3, sealed: n4, iv: i3, encoding: t });
}
function Du(e) {
  const t = new import_chacha20poly1305.ChaCha20Poly1305(fromString3(e.symKey, Lt4)), { sealed: r3, iv: i3 } = Wr3({ encoded: e.encoded, encoding: e == null ? void 0 : e.encoding }), n4 = t.open(i3, r3);
  if (n4 === null) throw new Error("Failed to decrypt");
  return toString3(n4, dr3);
}
function Fu(e, t) {
  const { sealed: r3 } = Wr3({ encoded: e, encoding: t });
  return toString3(r3, dr3);
}
function fn3(e) {
  const { encoding: t = tn3 } = e;
  if (Ze4(e.type) === Sr4) return toString3(concat3([e.type, e.sealed]), t);
  if (Ze4(e.type) === pr3) {
    if (typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString3(concat3([e.type, e.senderPublicKey, e.iv, e.sealed]), t);
  }
  return toString3(concat3([e.type, e.iv, e.sealed]), t);
}
function Wr3(e) {
  const { encoded: t, encoding: r3 = tn3 } = e, i3 = fromString3(t, r3), n4 = i3.slice(Nu, oo3), o4 = oo3;
  if (Ze4(n4) === pr3) {
    const v7 = o4 + rn3, w6 = v7 + Ir3, y10 = i3.slice(o4, v7), S7 = i3.slice(v7, w6), N4 = i3.slice(w6);
    return { type: n4, sealed: N4, iv: S7, senderPublicKey: y10 };
  }
  if (Ze4(n4) === Sr4) {
    const v7 = i3.slice(o4), w6 = (0, import_random3.randomBytes)(Ir3);
    return { type: n4, sealed: v7, iv: w6 };
  }
  const h7 = o4 + Ir3, p5 = i3.slice(o4, h7), A5 = i3.slice(h7);
  return { type: n4, sealed: A5, iv: p5 };
}
function Uu(e, t) {
  const r3 = Wr3({ encoded: e, encoding: t == null ? void 0 : t.encoding });
  return so3({ type: Ze4(r3.type), senderPublicKey: typeof r3.senderPublicKey < "u" ? toString3(r3.senderPublicKey, Lt4) : void 0, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey });
}
function so3(e) {
  const t = (e == null ? void 0 : e.type) || en3;
  if (t === pr3) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: t, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function ku(e) {
  return e.type === pr3 && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
function qu(e) {
  return e.type === Sr4;
}
function ao3(e) {
  return new import_elliptic.ec("p256").keyFromPublic({ x: Buffer.from(e.x, "base64").toString("hex"), y: Buffer.from(e.y, "base64").toString("hex") }, "hex");
}
function Ku(e) {
  let t = e.replace(/-/g, "+").replace(/_/g, "/");
  const r3 = t.length % 4;
  return r3 > 0 && (t += "=".repeat(4 - r3)), t;
}
function Hu(e) {
  return Buffer.from(Ku(e), "base64");
}
function Lu(e, t) {
  const [r3, i3, n4] = e.split("."), o4 = Hu(n4);
  if (o4.length !== 64) throw new Error("Invalid signature length");
  const h7 = o4.slice(0, 32).toString("hex"), p5 = o4.slice(32, 64).toString("hex"), A5 = `${r3}.${i3}`, v7 = new import_sha2562.SHA256().update(Buffer.from(A5)).digest(), w6 = ao3(t), y10 = Buffer.from(v7).toString("hex");
  if (!w6.verify(y10, { r: h7, s: p5 })) throw new Error("Invalid signature");
  return decodeJWT(e).payload;
}
var uo3 = "irn";
function zu(e) {
  return (e == null ? void 0 : e.relay) || { protocol: uo3 };
}
function ju(e) {
  const t = C[e];
  if (typeof t > "u") throw new Error(`Relay Protocol not supported: ${e}`);
  return t;
}
var Qu = Object.defineProperty;
var Ju = Object.defineProperties;
var Gu = Object.getOwnPropertyDescriptors;
var ho2 = Object.getOwnPropertySymbols;
var Yu = Object.prototype.hasOwnProperty;
var Vu = Object.prototype.propertyIsEnumerable;
var co3 = (e, t, r3) => t in e ? Qu(e, t, { enumerable: true, configurable: true, writable: true, value: r3 }) : e[t] = r3;
var lo2 = (e, t) => {
  for (var r3 in t || (t = {})) Yu.call(t, r3) && co3(e, r3, t[r3]);
  if (ho2) for (var r3 of ho2(t)) Vu.call(t, r3) && co3(e, r3, t[r3]);
  return e;
};
var Wu = (e, t) => Ju(e, Gu(t));
function po2(e, t = "-") {
  const r3 = {}, i3 = "relay" + t;
  return Object.keys(e).forEach((n4) => {
    if (n4.startsWith(i3)) {
      const o4 = n4.replace(i3, ""), h7 = e[n4];
      r3[o4] = h7;
    }
  }), r3;
}
function Xu(e) {
  if (!e.includes("wc:")) {
    const A5 = xi3(e);
    A5 != null && A5.includes("wc:") && (e = A5);
  }
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const t = e.indexOf(":"), r3 = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, i3 = e.substring(0, t), n4 = e.substring(t + 1, r3).split("@"), o4 = typeof r3 < "u" ? e.substring(r3) : "", h7 = Br5.parse(o4), p5 = typeof h7.methods == "string" ? h7.methods.split(",") : void 0;
  return { protocol: i3, topic: vo2(n4[0]), version: parseInt(n4[1], 10), symKey: h7.symKey, relay: po2(h7), methods: p5, expiryTimestamp: h7.expiryTimestamp ? parseInt(h7.expiryTimestamp, 10) : void 0 };
}
function vo2(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function go2(e, t = "-") {
  const r3 = "relay", i3 = {};
  return Object.keys(e).forEach((n4) => {
    const o4 = r3 + t + n4;
    e[n4] && (i3[o4] = e[n4]);
  }), i3;
}
function $u(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + Br5.stringify(lo2(Wu(lo2({ symKey: e.symKey }, go2(e.relay)), { expiryTimestamp: e.expiryTimestamp }), e.methods ? { methods: e.methods.join(",") } : {}));
}
function Zu(e, t, r3) {
  return `${e}?wc_ev=${r3}&topic=${t}`;
}
function tr3(e) {
  const t = [];
  return e.forEach((r3) => {
    const [i3, n4] = r3.split(":");
    t.push(`${i3}:${n4}`);
  }), t;
}
function bo3(e) {
  const t = [];
  return Object.values(e).forEach((r3) => {
    t.push(...tr3(r3.accounts));
  }), t;
}
function yo2(e, t) {
  const r3 = [];
  return Object.values(e).forEach((i3) => {
    tr3(i3.accounts).includes(t) && r3.push(...i3.methods);
  }), r3;
}
function wo3(e, t) {
  const r3 = [];
  return Object.values(e).forEach((i3) => {
    tr3(i3.accounts).includes(t) && r3.push(...i3.events);
  }), r3;
}
function Mo2(e) {
  const t = {};
  return e == null ? void 0 : e.forEach((r3) => {
    const [i3, n4] = r3.split(":");
    t[i3] || (t[i3] = { accounts: [], chains: [], events: [] }), t[i3].accounts.push(r3), t[i3].chains.push(`${i3}:${n4}`);
  }), t;
}
function uh(e, t) {
  t = t.map((i3) => i3.replace("did:pkh:", ""));
  const r3 = Mo2(t);
  for (const [i3, n4] of Object.entries(r3)) n4.methods ? n4.methods = me3(n4.methods, e) : n4.methods = e, n4.events = ["chainChanged", "accountsChanged"];
  return r3;
}
var Eo2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var So2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function xe(e, t) {
  const { message: r3, code: i3 } = So2[e];
  return { message: t ? `${r3} ${t}` : r3, code: i3 };
}
function er3(e, t) {
  const { message: r3, code: i3 } = Eo2[e];
  return { message: t ? `${r3} ${t}` : r3, code: i3 };
}
function Nr4(e, t) {
  return Array.isArray(e) ? typeof t < "u" && e.length ? e.every(t) : true : false;
}
function Xr3(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function Pe3(e) {
  return typeof e > "u";
}
function Yt4(e, t) {
  return t && Pe3(e) ? true : typeof e == "string" && !!e.trim().length;
}
function $r4(e, t) {
  return t && Pe3(e) ? true : typeof e == "number" && !isNaN(e);
}
function hh(e, t) {
  const { requiredNamespaces: r3 } = t, i3 = Object.keys(e.namespaces), n4 = Object.keys(r3);
  let o4 = true;
  return _e3(n4, i3) ? (i3.forEach((h7) => {
    const { accounts: p5, methods: A5, events: v7 } = e.namespaces[h7], w6 = tr3(p5), y10 = r3[h7];
    (!_e3(Or4(h7, y10), w6) || !_e3(y10.methods, A5) || !_e3(y10.events, v7)) && (o4 = false);
  }), o4) : false;
}
function _r4(e) {
  return Yt4(e, false) && e.includes(":") ? e.split(":").length === 2 : false;
}
function Io2(e) {
  if (Yt4(e, false) && e.includes(":")) {
    const t = e.split(":");
    if (t.length === 3) {
      const r3 = t[0] + ":" + t[1];
      return !!t[2] && _r4(r3);
    }
  }
  return false;
}
function ch(e) {
  function t(r3) {
    try {
      return typeof new URL(r3) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (Yt4(e, false)) {
      if (t(e)) return true;
      const r3 = xi3(e);
      return t(r3);
    }
  } catch {
  }
  return false;
}
function lh(e) {
  var t;
  return (t = e == null ? void 0 : e.proposer) == null ? void 0 : t.publicKey;
}
function dh(e) {
  return e == null ? void 0 : e.topic;
}
function ph(e, t) {
  let r3 = null;
  return Yt4(e == null ? void 0 : e.publicKey, false) || (r3 = xe("MISSING_OR_INVALID", `${t} controller public key should be a string`)), r3;
}
function an3(e) {
  let t = true;
  return Nr4(e) ? e.length && (t = e.every((r3) => Yt4(r3, false))) : t = false, t;
}
function No2(e, t, r3) {
  let i3 = null;
  return Nr4(t) && t.length ? t.forEach((n4) => {
    i3 || _r4(n4) || (i3 = er3("UNSUPPORTED_CHAINS", `${r3}, chain ${n4} should be a string and conform to "namespace:chainId" format`));
  }) : _r4(e) || (i3 = er3("UNSUPPORTED_CHAINS", `${r3}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), i3;
}
function _o3(e, t, r3) {
  let i3 = null;
  return Object.entries(e).forEach(([n4, o4]) => {
    if (i3) return;
    const h7 = No2(n4, Or4(n4, o4), `${t} ${r3}`);
    h7 && (i3 = h7);
  }), i3;
}
function Bo2(e, t) {
  let r3 = null;
  return Nr4(e) ? e.forEach((i3) => {
    r3 || Io2(i3) || (r3 = er3("UNSUPPORTED_ACCOUNTS", `${t}, account ${i3} should be a string and conform to "namespace:chainId:address" format`));
  }) : r3 = er3("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), r3;
}
function Co3(e, t) {
  let r3 = null;
  return Object.values(e).forEach((i3) => {
    if (r3) return;
    const n4 = Bo2(i3 == null ? void 0 : i3.accounts, `${t} namespace`);
    n4 && (r3 = n4);
  }), r3;
}
function Ro3(e, t) {
  let r3 = null;
  return an3(e == null ? void 0 : e.methods) ? an3(e == null ? void 0 : e.events) || (r3 = er3("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : r3 = er3("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`), r3;
}
function un3(e, t) {
  let r3 = null;
  return Object.values(e).forEach((i3) => {
    if (r3) return;
    const n4 = Ro3(i3, `${t}, namespace`);
    n4 && (r3 = n4);
  }), r3;
}
function vh(e, t, r3) {
  let i3 = null;
  if (e && Xr3(e)) {
    const n4 = un3(e, t);
    n4 && (i3 = n4);
    const o4 = _o3(e, t, r3);
    o4 && (i3 = o4);
  } else i3 = xe("MISSING_OR_INVALID", `${t}, ${r3} should be an object with data`);
  return i3;
}
function Oo2(e, t) {
  let r3 = null;
  if (e && Xr3(e)) {
    const i3 = un3(e, t);
    i3 && (r3 = i3);
    const n4 = Co3(e, t);
    n4 && (r3 = n4);
  } else r3 = xe("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`);
  return r3;
}
function Po4(e) {
  return Yt4(e.protocol, true);
}
function gh(e, t) {
  let r3 = false;
  return t && !e ? r3 = true : e && Nr4(e) && e.length && e.forEach((i3) => {
    r3 = Po4(i3);
  }), r3;
}
function mh(e) {
  return typeof e == "number";
}
function Ah(e) {
  return typeof e < "u" && typeof e !== null;
}
function bh(e) {
  return !(!e || typeof e != "object" || !e.code || !$r4(e.code, false) || !e.message || !Yt4(e.message, false));
}
function yh(e) {
  return !(Pe3(e) || !Yt4(e.method, false));
}
function wh(e) {
  return !(Pe3(e) || Pe3(e.result) && Pe3(e.error) || !$r4(e.id, false) || !Yt4(e.jsonrpc, false));
}
function xh(e) {
  return !(Pe3(e) || !Yt4(e.name, false));
}
function Mh(e, t) {
  return !(!_r4(t) || !bo3(e).includes(t));
}
function Eh(e, t, r3) {
  return Yt4(r3, false) ? yo2(e, t).includes(r3) : false;
}
function Sh(e, t, r3) {
  return Yt4(r3, false) ? wo3(e, t).includes(r3) : false;
}
function To3(e, t, r3) {
  let i3 = null;
  const n4 = Ih(e), o4 = Nh(t), h7 = Object.keys(n4), p5 = Object.keys(o4), A5 = Do2(Object.keys(e)), v7 = Do2(Object.keys(t)), w6 = A5.filter((y10) => !v7.includes(y10));
  return w6.length && (i3 = xe("NON_CONFORMING_NAMESPACES", `${r3} namespaces keys don't satisfy requiredNamespaces.
      Required: ${w6.toString()}
      Received: ${Object.keys(t).toString()}`)), _e3(h7, p5) || (i3 = xe("NON_CONFORMING_NAMESPACES", `${r3} namespaces chains don't satisfy required namespaces.
      Required: ${h7.toString()}
      Approved: ${p5.toString()}`)), Object.keys(t).forEach((y10) => {
    if (!y10.includes(":") || i3) return;
    const S7 = tr3(t[y10].accounts);
    S7.includes(y10) || (i3 = xe("NON_CONFORMING_NAMESPACES", `${r3} namespaces accounts don't satisfy namespace accounts for ${y10}
        Required: ${y10}
        Approved: ${S7.toString()}`));
  }), h7.forEach((y10) => {
    i3 || (_e3(n4[y10].methods, o4[y10].methods) ? _e3(n4[y10].events, o4[y10].events) || (i3 = xe("NON_CONFORMING_NAMESPACES", `${r3} namespaces events don't satisfy namespace events for ${y10}`)) : i3 = xe("NON_CONFORMING_NAMESPACES", `${r3} namespaces methods don't satisfy namespace methods for ${y10}`));
  }), i3;
}
function Ih(e) {
  const t = {};
  return Object.keys(e).forEach((r3) => {
    var i3;
    r3.includes(":") ? t[r3] = e[r3] : (i3 = e[r3].chains) == null || i3.forEach((n4) => {
      t[n4] = { methods: e[r3].methods, events: e[r3].events };
    });
  }), t;
}
function Do2(e) {
  return [...new Set(e.map((t) => t.includes(":") ? t.split(":")[0] : t))];
}
function Nh(e) {
  const t = {};
  return Object.keys(e).forEach((r3) => {
    if (r3.includes(":")) t[r3] = e[r3];
    else {
      const i3 = tr3(e[r3].accounts);
      i3 == null ? void 0 : i3.forEach((n4) => {
        t[n4] = { accounts: e[r3].accounts.filter((o4) => o4.includes(`${n4}:`)), methods: e[r3].methods, events: e[r3].events };
      });
    }
  }), t;
}
function _h(e, t) {
  return $r4(e, false) && e <= t.max && e >= t.min;
}
function Bh() {
  const e = We4();
  return new Promise((t) => {
    switch (e) {
      case qt4.browser:
        t(Fo2());
        break;
      case qt4.reactNative:
        t(Uo2());
        break;
      case qt4.node:
        t(ko2());
        break;
      default:
        t(true);
    }
  });
}
function Fo2() {
  return gr3() && (navigator == null ? void 0 : navigator.onLine);
}
async function Uo2() {
  if (rr4() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function ko2() {
  return true;
}
function Ch(e) {
  switch (We4()) {
    case qt4.browser:
      qo2(e);
      break;
    case qt4.reactNative:
      Ko2(e);
      break;
    case qt4.node:
      break;
  }
}
function qo2(e) {
  !rr4() && gr3() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function Ko2(e) {
  rr4() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((t) => e(t == null ? void 0 : t.isConnected)));
}
var hn3 = {};
var Rh = class {
  static get(t) {
    return hn3[t];
  }
  static set(t, r3) {
    hn3[t] = r3;
  }
  static delete(t) {
    delete hn3[t];
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events11 = __toESM(require_events());
var w3 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser3();
var b3 = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var a4 = (c7) => c7.split("?")[0];
var h6 = 10;
var S5 = w3();
var f4 = class {
  constructor(e) {
    if (this.url = e, this.events = new import_events11.EventEmitter(), this.registering = false, !isWsUrl(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n4) => {
        this.onClose(n4), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e));
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  register(e = this.url) {
    if (!isWsUrl(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n4, o4) => {
        this.events.once("register_error", (s2) => {
          this.resetMaxListeners(), o4(s2);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return o4(new Error("WebSocket connection is missing or invalid"));
          n4(this.socket);
        });
      });
    }
    return this.url = e, this.registering = true, new Promise((t, n4) => {
      const o4 = new URLSearchParams(e).get("origin"), s2 = (0, esm_exports.isReactNative)() ? { headers: { origin: o4 } } : { rejectUnauthorized: !isLocalhostUrl(e) }, i3 = new S5(e, [], s2);
      b3() ? i3.onerror = (r3) => {
        const l7 = r3;
        n4(this.emitError(l7.error));
      } : i3.on("error", (r3) => {
        n4(this.emitError(r3));
      }), i3.onopen = () => {
        this.onOpen(i3), t(i3);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = false, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const t = typeof e.data == "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n4 = this.parseError(t), o4 = n4.message || n4.toString(), s2 = formatJsonRpcError(e, o4);
    this.events.emit("payload", s2);
  }
  parseError(e, t = this.url) {
    return parseConnectionError(e, a4(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h6 && this.events.setMaxListeners(h6);
  }
  emitError(e) {
    const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${a4(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
var be5 = "wc";
var fe4 = 2;
var ne4 = "core";
var O6 = `${be5}@2:${ne4}:`;
var Xe5 = { name: ne4, logger: "error" };
var Ze5 = { database: ":memory:" };
var Qe4 = "crypto";
var _e4 = "client_ed25519_seed";
var et3 = import_time7.ONE_DAY;
var tt4 = "keychain";
var it3 = "0.3";
var st3 = "messages";
var rt2 = "0.3";
var nt3 = import_time7.SIX_HOURS;
var ot3 = "publisher";
var at2 = "irn";
var ct2 = "error";
var Ee4 = "wss://relay.walletconnect.org";
var ht3 = "relayer";
var w4 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var lt3 = "_subscription";
var T2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var ut3 = 0.1;
var oe3 = "2.17.0";
var F4 = { link_mode: "link_mode", relay: "relay" };
var dt3 = "0.3";
var gt2 = "WALLETCONNECT_CLIENT_ID";
var ve3 = "WALLETCONNECT_LINK_MODE_APPS";
var A3 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var pt3 = "subscription";
var yt2 = "0.3";
var Dt4 = import_time7.FIVE_SECONDS * 1e3;
var mt3 = "pairing";
var bt3 = "0.3";
var j5 = { wc_pairingDelete: { req: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time7.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time7.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time7.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time7.ONE_DAY, prompt: false, tag: 0 } } };
var q2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var P3 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var ft3 = "history";
var _t3 = "0.3";
var Et4 = "expirer";
var R4 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var vt2 = "0.3";
var wt3 = "verify-api";
var Is3 = "https://verify.walletconnect.com";
var It3 = "https://verify.walletconnect.org";
var Z3 = It3;
var Tt5 = `${Z3}/v3`;
var Ct4 = [Is3, It3];
var St4 = "echo";
var Pt4 = "https://echo.walletconnect.com";
var z6 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var M5 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var Cs3 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var Ss3 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var Ps3 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var Rs3 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Rt4 = 0.1;
var xt4 = "event-client";
var Ot5 = 86400;
var At4 = "https://pulse.walletconnect.org/batch";
function xs3(o4, e) {
  if (o4.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s2 = 0; s2 < t.length; s2++) t[s2] = 255;
  for (var i3 = 0; i3 < o4.length; i3++) {
    var r3 = o4.charAt(i3), n4 = r3.charCodeAt(0);
    if (t[n4] !== 255) throw new TypeError(r3 + " is ambiguous");
    t[n4] = i3;
  }
  var a5 = o4.length, c7 = o4.charAt(0), h7 = Math.log(a5) / Math.log(256), d5 = Math.log(256) / Math.log(a5);
  function g4(l7) {
    if (l7 instanceof Uint8Array || (ArrayBuffer.isView(l7) ? l7 = new Uint8Array(l7.buffer, l7.byteOffset, l7.byteLength) : Array.isArray(l7) && (l7 = Uint8Array.from(l7))), !(l7 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (l7.length === 0) return "";
    for (var p5 = 0, E6 = 0, D5 = 0, f6 = l7.length; D5 !== f6 && l7[D5] === 0; ) D5++, p5++;
    for (var N4 = (f6 - D5) * d5 + 1 >>> 0, C5 = new Uint8Array(N4); D5 !== f6; ) {
      for (var L4 = l7[D5], $5 = 0, x7 = N4 - 1; (L4 !== 0 || $5 < E6) && x7 !== -1; x7--, $5++) L4 += 256 * C5[x7] >>> 0, C5[x7] = L4 % a5 >>> 0, L4 = L4 / a5 >>> 0;
      if (L4 !== 0) throw new Error("Non-zero carry");
      E6 = $5, D5++;
    }
    for (var k6 = N4 - E6; k6 !== N4 && C5[k6] === 0; ) k6++;
    for (var ie5 = c7.repeat(p5); k6 < N4; ++k6) ie5 += o4.charAt(C5[k6]);
    return ie5;
  }
  function m2(l7) {
    if (typeof l7 != "string") throw new TypeError("Expected String");
    if (l7.length === 0) return new Uint8Array();
    var p5 = 0;
    if (l7[p5] !== " ") {
      for (var E6 = 0, D5 = 0; l7[p5] === c7; ) E6++, p5++;
      for (var f6 = (l7.length - p5) * h7 + 1 >>> 0, N4 = new Uint8Array(f6); l7[p5]; ) {
        var C5 = t[l7.charCodeAt(p5)];
        if (C5 === 255) return;
        for (var L4 = 0, $5 = f6 - 1; (C5 !== 0 || L4 < D5) && $5 !== -1; $5--, L4++) C5 += a5 * N4[$5] >>> 0, N4[$5] = C5 % 256 >>> 0, C5 = C5 / 256 >>> 0;
        if (C5 !== 0) throw new Error("Non-zero carry");
        D5 = L4, p5++;
      }
      if (l7[p5] !== " ") {
        for (var x7 = f6 - D5; x7 !== f6 && N4[x7] === 0; ) x7++;
        for (var k6 = new Uint8Array(E6 + (f6 - x7)), ie5 = E6; x7 !== f6; ) k6[ie5++] = N4[x7++];
        return k6;
      }
    }
  }
  function b6(l7) {
    var p5 = m2(l7);
    if (p5) return p5;
    throw new Error(`Non-${e} character`);
  }
  return { encode: g4, decodeUnsafe: m2, decode: b6 };
}
var Os3 = xs3;
var As3 = Os3;
var Nt4 = (o4) => {
  if (o4 instanceof Uint8Array && o4.constructor.name === "Uint8Array") return o4;
  if (o4 instanceof ArrayBuffer) return new Uint8Array(o4);
  if (ArrayBuffer.isView(o4)) return new Uint8Array(o4.buffer, o4.byteOffset, o4.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Ns3 = (o4) => new TextEncoder().encode(o4);
var Ls3 = (o4) => new TextDecoder().decode(o4);
var zs3 = class {
  constructor(e, t, s2) {
    this.name = e, this.prefix = t, this.baseEncode = s2;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var ks3 = class {
  constructor(e, t, s2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Lt5(this, e);
  }
};
var Ms3 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Lt5(this, e);
  }
  decode(e) {
    const t = e[0], s2 = this.decoders[t];
    if (s2) return s2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Lt5 = (o4, e) => new Ms3({ ...o4.decoders || { [o4.prefix]: o4 }, ...e.decoders || { [e.prefix]: e } });
var $s3 = class {
  constructor(e, t, s2, i3) {
    this.name = e, this.prefix = t, this.baseEncode = s2, this.baseDecode = i3, this.encoder = new zs3(e, t, s2), this.decoder = new ks3(e, t, i3);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var ae3 = ({ name: o4, prefix: e, encode: t, decode: s2 }) => new $s3(o4, e, t, s2);
var Q4 = ({ prefix: o4, name: e, alphabet: t }) => {
  const { encode: s2, decode: i3 } = As3(t, e);
  return ae3({ prefix: o4, name: e, encode: s2, decode: (r3) => Nt4(i3(r3)) });
};
var Fs3 = (o4, e, t, s2) => {
  const i3 = {};
  for (let d5 = 0; d5 < e.length; ++d5) i3[e[d5]] = d5;
  let r3 = o4.length;
  for (; o4[r3 - 1] === "="; ) --r3;
  const n4 = new Uint8Array(r3 * t / 8 | 0);
  let a5 = 0, c7 = 0, h7 = 0;
  for (let d5 = 0; d5 < r3; ++d5) {
    const g4 = i3[o4[d5]];
    if (g4 === void 0) throw new SyntaxError(`Non-${s2} character`);
    c7 = c7 << t | g4, a5 += t, a5 >= 8 && (a5 -= 8, n4[h7++] = 255 & c7 >> a5);
  }
  if (a5 >= t || 255 & c7 << 8 - a5) throw new SyntaxError("Unexpected end of data");
  return n4;
};
var Us3 = (o4, e, t) => {
  const s2 = e[e.length - 1] === "=", i3 = (1 << t) - 1;
  let r3 = "", n4 = 0, a5 = 0;
  for (let c7 = 0; c7 < o4.length; ++c7) for (a5 = a5 << 8 | o4[c7], n4 += 8; n4 > t; ) n4 -= t, r3 += e[i3 & a5 >> n4];
  if (n4 && (r3 += e[i3 & a5 << t - n4]), s2) for (; r3.length * t & 7; ) r3 += "=";
  return r3;
};
var _3 = ({ name: o4, prefix: e, bitsPerChar: t, alphabet: s2 }) => ae3({ prefix: e, name: o4, encode(i3) {
  return Us3(i3, s2, t);
}, decode(i3) {
  return Fs3(i3, s2, t, o4);
} });
var Ks3 = ae3({ prefix: "\0", name: "identity", encode: (o4) => Ls3(o4), decode: (o4) => Ns3(o4) });
var Bs3 = Object.freeze({ __proto__: null, identity: Ks3 });
var Vs4 = _3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var js3 = Object.freeze({ __proto__: null, base2: Vs4 });
var qs3 = _3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Gs3 = Object.freeze({ __proto__: null, base8: qs3 });
var Hs4 = Q4({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Ys3 = Object.freeze({ __proto__: null, base10: Hs4 });
var Js3 = _3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Ws3 = _3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Xs4 = Object.freeze({ __proto__: null, base16: Js3, base16upper: Ws3 });
var Zs3 = _3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Qs3 = _3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var er4 = _3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var tr4 = _3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var ir3 = _3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var sr4 = _3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var rr5 = _3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var nr5 = _3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var or5 = _3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var ar4 = Object.freeze({ __proto__: null, base32: Zs3, base32upper: Qs3, base32pad: er4, base32padupper: tr4, base32hex: ir3, base32hexupper: sr4, base32hexpad: rr5, base32hexpadupper: nr5, base32z: or5 });
var cr4 = Q4({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var hr4 = Q4({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var lr4 = Object.freeze({ __proto__: null, base36: cr4, base36upper: hr4 });
var ur4 = Q4({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var dr4 = Q4({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var gr4 = Object.freeze({ __proto__: null, base58btc: ur4, base58flickr: dr4 });
var pr4 = _3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var yr4 = _3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Dr5 = _3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var mr4 = _3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var br4 = Object.freeze({ __proto__: null, base64: pr4, base64pad: yr4, base64url: Dr5, base64urlpad: mr4 });
var zt4 = Array.from("");
var fr4 = zt4.reduce((o4, e, t) => (o4[t] = e, o4), []);
var _r5 = zt4.reduce((o4, e, t) => (o4[e.codePointAt(0)] = t, o4), []);
function Er4(o4) {
  return o4.reduce((e, t) => (e += fr4[t], e), "");
}
function vr4(o4) {
  const e = [];
  for (const t of o4) {
    const s2 = _r5[t.codePointAt(0)];
    if (s2 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(s2);
  }
  return new Uint8Array(e);
}
var wr4 = ae3({ prefix: "", name: "base256emoji", encode: Er4, decode: vr4 });
var Ir4 = Object.freeze({ __proto__: null, base256emoji: wr4 });
var Tr5 = Mt4;
var kt5 = 128;
var Cr5 = 127;
var Sr5 = ~Cr5;
var Pr4 = Math.pow(2, 31);
function Mt4(o4, e, t) {
  e = e || [], t = t || 0;
  for (var s2 = t; o4 >= Pr4; ) e[t++] = o4 & 255 | kt5, o4 /= 128;
  for (; o4 & Sr5; ) e[t++] = o4 & 255 | kt5, o4 >>>= 7;
  return e[t] = o4 | 0, Mt4.bytes = t - s2 + 1, e;
}
var Rr5 = we4;
var xr4 = 128;
var $t5 = 127;
function we4(o4, s2) {
  var t = 0, s2 = s2 || 0, i3 = 0, r3 = s2, n4, a5 = o4.length;
  do {
    if (r3 >= a5) throw we4.bytes = 0, new RangeError("Could not decode varint");
    n4 = o4[r3++], t += i3 < 28 ? (n4 & $t5) << i3 : (n4 & $t5) * Math.pow(2, i3), i3 += 7;
  } while (n4 >= xr4);
  return we4.bytes = r3 - s2, t;
}
var Or5 = Math.pow(2, 7);
var Ar5 = Math.pow(2, 14);
var Nr5 = Math.pow(2, 21);
var Lr4 = Math.pow(2, 28);
var zr5 = Math.pow(2, 35);
var kr4 = Math.pow(2, 42);
var Mr4 = Math.pow(2, 49);
var $r5 = Math.pow(2, 56);
var Fr5 = Math.pow(2, 63);
var Ur4 = function(o4) {
  return o4 < Or5 ? 1 : o4 < Ar5 ? 2 : o4 < Nr5 ? 3 : o4 < Lr4 ? 4 : o4 < zr5 ? 5 : o4 < kr4 ? 6 : o4 < Mr4 ? 7 : o4 < $r5 ? 8 : o4 < Fr5 ? 9 : 10;
};
var Kr4 = { encode: Tr5, decode: Rr5, encodingLength: Ur4 };
var Ft4 = Kr4;
var Ut4 = (o4, e, t = 0) => (Ft4.encode(o4, e, t), e);
var Kt5 = (o4) => Ft4.encodingLength(o4);
var Ie3 = (o4, e) => {
  const t = e.byteLength, s2 = Kt5(o4), i3 = s2 + Kt5(t), r3 = new Uint8Array(i3 + t);
  return Ut4(o4, r3, 0), Ut4(t, r3, s2), r3.set(e, i3), new Br6(o4, t, e, r3);
};
var Br6 = class {
  constructor(e, t, s2, i3) {
    this.code = e, this.size = t, this.digest = s2, this.bytes = i3;
  }
};
var Bt4 = ({ name: o4, code: e, encode: t }) => new Vr4(o4, e, t);
var Vr4 = class {
  constructor(e, t, s2) {
    this.name = e, this.code = t, this.encode = s2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? Ie3(this.code, t) : t.then((s2) => Ie3(this.code, s2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var Vt4 = (o4) => async (e) => new Uint8Array(await crypto.subtle.digest(o4, e));
var jr4 = Bt4({ name: "sha2-256", code: 18, encode: Vt4("SHA-256") });
var qr4 = Bt4({ name: "sha2-512", code: 19, encode: Vt4("SHA-512") });
var Gr4 = Object.freeze({ __proto__: null, sha256: jr4, sha512: qr4 });
var jt5 = 0;
var Hr4 = "identity";
var qt5 = Nt4;
var Yr4 = (o4) => Ie3(jt5, qt5(o4));
var Jr4 = { code: jt5, name: Hr4, encode: qt5, digest: Yr4 };
var Wr4 = Object.freeze({ __proto__: null, identity: Jr4 });
new TextEncoder(), new TextDecoder();
var Gt5 = { ...Bs3, ...js3, ...Gs3, ...Ys3, ...Xs4, ...ar4, ...lr4, ...gr4, ...br4, ...Ir4 };
({ ...Gr4, ...Wr4 });
function Xr4(o4 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(o4) : new Uint8Array(o4);
}
function Ht5(o4, e, t, s2) {
  return { name: o4, prefix: e, encoder: { name: o4, prefix: e, encode: t }, decoder: { decode: s2 } };
}
var Yt5 = Ht5("utf8", "u", (o4) => "u" + new TextDecoder("utf8").decode(o4), (o4) => new TextEncoder().encode(o4.substring(1)));
var Te2 = Ht5("ascii", "a", (o4) => {
  let e = "a";
  for (let t = 0; t < o4.length; t++) e += String.fromCharCode(o4[t]);
  return e;
}, (o4) => {
  o4 = o4.substring(1);
  const e = Xr4(o4.length);
  for (let t = 0; t < o4.length; t++) e[t] = o4.charCodeAt(t);
  return e;
});
var Zr3 = { utf8: Yt5, "utf-8": Yt5, hex: Gt5.base16, latin1: Te2, ascii: Te2, binary: Te2, ...Gt5 };
function Qr4(o4, e = "utf8") {
  const t = Zr3[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(o4, "utf8") : t.decoder.decode(`${t.prefix}${o4}`);
}
var Jt5 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = tt4, this.version = it3, this.initialized = false, this.storagePrefix = O6, this.init = async () => {
      if (!this.initialized) {
        const s2 = await this.getKeyChain();
        typeof s2 < "u" && (this.keychain = s2), this.initialized = true;
      }
    }, this.has = (s2) => (this.isInitialized(), this.keychain.has(s2)), this.set = async (s2, i3) => {
      this.isInitialized(), this.keychain.set(s2, i3), await this.persist();
    }, this.get = (s2) => {
      this.isInitialized();
      const i3 = this.keychain.get(s2);
      if (typeof i3 > "u") {
        const { message: r3 } = xe("NO_MATCHING_KEY", `${this.name}: ${s2}`);
        throw new Error(r3);
      }
      return i3;
    }, this.del = async (s2) => {
      this.isInitialized(), this.keychain.delete(s2), await this.persist();
    }, this.core = e, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, cs2(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ls(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Wt4 = class {
  constructor(e, t, s2) {
    this.core = e, this.logger = t, this.name = Qe4, this.randomSessionIdentifier = Bu(), this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (i3) => (this.isInitialized(), this.keychain.has(i3)), this.getClientId = async () => {
      this.isInitialized();
      const i3 = await this.getClientSeed(), r3 = generateKeyPair(i3);
      return encodeIss(r3.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i3 = _u();
      return this.setPrivateKey(i3.publicKey, i3.privateKey);
    }, this.signJWT = async (i3) => {
      this.isInitialized();
      const r3 = await this.getClientSeed(), n4 = generateKeyPair(r3), a5 = this.randomSessionIdentifier, c7 = et3;
      return await signJWT(a5, i3, c7, n4);
    }, this.generateSharedKey = (i3, r3, n4) => {
      this.isInitialized();
      const a5 = this.getPrivateKey(i3), c7 = Cu(a5, r3);
      return this.setSymKey(c7, n4);
    }, this.setSymKey = async (i3, r3) => {
      this.isInitialized();
      const n4 = r3 || Ru(i3);
      return await this.keychain.set(n4, i3), n4;
    }, this.deleteKeyPair = async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }, this.deleteSymKey = async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }, this.encode = async (i3, r3, n4) => {
      this.isInitialized();
      const a5 = so3(n4), c7 = safeJsonStringify(r3);
      if (qu(a5)) return Tu(c7, n4 == null ? void 0 : n4.encoding);
      if (ku(a5)) {
        const m2 = a5.senderPublicKey, b6 = a5.receiverPublicKey;
        i3 = await this.generateSharedKey(m2, b6);
      }
      const h7 = this.getSymKey(i3), { type: d5, senderPublicKey: g4 } = a5;
      return Pu({ type: d5, symKey: h7, message: c7, senderPublicKey: g4, encoding: n4 == null ? void 0 : n4.encoding });
    }, this.decode = async (i3, r3, n4) => {
      this.isInitialized();
      const a5 = Uu(r3, n4);
      if (qu(a5)) {
        const c7 = Fu(r3, n4 == null ? void 0 : n4.encoding);
        return safeJsonParse(c7);
      }
      if (ku(a5)) {
        const c7 = a5.receiverPublicKey, h7 = a5.senderPublicKey;
        i3 = await this.generateSharedKey(c7, h7);
      }
      try {
        const c7 = this.getSymKey(i3), h7 = Du({ symKey: c7, encoded: r3, encoding: n4 == null ? void 0 : n4.encoding });
        return safeJsonParse(h7);
      } catch (c7) {
        this.logger.error(`Failed to decode message from topic: '${i3}', clientId: '${await this.getClientId()}'`), this.logger.error(c7);
      }
    }, this.getPayloadType = (i3, r3 = tn3) => {
      const n4 = Wr3({ encoded: i3, encoding: r3 });
      return Ze4(n4.type);
    }, this.getPayloadSenderPublicKey = (i3, r3 = tn3) => {
      const n4 = Wr3({ encoded: i3, encoding: r3 });
      return n4.senderPublicKey ? toString3(n4.senderPublicKey, Lt4) : void 0;
    }, this.core = e, this.logger = E(t, this.name), this.keychain = s2 || new Jt5(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(_e4);
    } catch {
      e = Bu(), await this.keychain.set(_e4, e);
    }
    return Qr4(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Xt4 = class extends a3 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = st3, this.version = rt2, this.initialized = false, this.storagePrefix = O6, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s2 = await this.getRelayerMessages();
          typeof s2 < "u" && (this.messages = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (s2, i3) => {
      this.isInitialized();
      const r3 = Ou(i3);
      let n4 = this.messages.get(s2);
      return typeof n4 > "u" && (n4 = {}), typeof n4[r3] < "u" || (n4[r3] = i3, this.messages.set(s2, n4), await this.persist()), r3;
    }, this.get = (s2) => {
      this.isInitialized();
      let i3 = this.messages.get(s2);
      return typeof i3 > "u" && (i3 = {}), i3;
    }, this.has = (s2, i3) => {
      this.isInitialized();
      const r3 = this.get(s2), n4 = Ou(i3);
      return typeof r3[n4] < "u";
    }, this.del = async (s2) => {
      this.isInitialized(), this.messages.delete(s2), await this.persist();
    }, this.logger = E(e, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, cs2(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ls(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var en4 = class extends g2 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events12.EventEmitter(), this.name = ot3, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time7.toMiliseconds)(import_time7.ONE_MINUTE), this.failedPublishTimeout = (0, import_time7.toMiliseconds)(import_time7.ONE_SECOND), this.needsTransportRestart = false, this.publish = async (s2, i3, r3) => {
      var n4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s2, message: i3, opts: r3 } });
      const a5 = (r3 == null ? void 0 : r3.ttl) || nt3, c7 = zu(r3), h7 = (r3 == null ? void 0 : r3.prompt) || false, d5 = (r3 == null ? void 0 : r3.tag) || 0, g4 = (r3 == null ? void 0 : r3.id) || getBigIntRpcId().toString(), m2 = { topic: s2, message: i3, opts: { ttl: a5, relay: c7, prompt: h7, tag: d5, id: g4, attestation: r3 == null ? void 0 : r3.attestation } }, b6 = `Failed to publish payload, please try again. id:${g4} tag:${d5}`, l7 = Date.now();
      let p5, E6 = 1;
      try {
        for (; p5 === void 0; ) {
          if (Date.now() - l7 > this.publishTimeout) throw new Error(b6);
          this.logger.trace({ id: g4, attempts: E6 }, `publisher.publish - attempt ${E6}`), p5 = await await ms2(this.rpcPublish(s2, i3, a5, c7, h7, d5, g4, r3 == null ? void 0 : r3.attestation).catch((D5) => this.logger.warn(D5)), this.publishTimeout, b6), E6++, p5 || await new Promise((D5) => setTimeout(D5, this.failedPublishTimeout));
        }
        this.relayer.events.emit(w4.publish, m2), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: g4, topic: s2, message: i3, opts: r3 } });
      } catch (D5) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(D5), (n4 = r3 == null ? void 0 : r3.internal) != null && n4.throwOnFailedPublish) throw D5;
        this.queue.set(g4, m2);
      }
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  rpcPublish(e, t, s2, i3, r3, n4, a5, c7) {
    var h7, d5, g4, m2;
    const b6 = { method: ju(i3.protocol).publish, params: { topic: e, message: t, ttl: s2, prompt: r3, tag: n4, attestation: c7 }, id: a5 };
    return Pe3((h7 = b6.params) == null ? void 0 : h7.prompt) && ((d5 = b6.params) == null || delete d5.prompt), Pe3((g4 = b6.params) == null ? void 0 : g4.tag) && ((m2 = b6.params) == null || delete m2.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: b6 }), this.relayer.request(b6);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: s2, opts: i3 } = e;
      await this.publish(t, s2, i3);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r2.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(w4.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(w4.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var tn4 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const s2 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...s2, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const s2 = this.get(e);
      if (!this.exists(e, t)) return;
      const i3 = s2.filter((r3) => r3 !== t);
      if (!i3.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i3);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var sn4 = Object.defineProperty;
var rn4 = Object.defineProperties;
var nn4 = Object.getOwnPropertyDescriptors;
var Zt4 = Object.getOwnPropertySymbols;
var on3 = Object.prototype.hasOwnProperty;
var an4 = Object.prototype.propertyIsEnumerable;
var Qt4 = (o4, e, t) => e in o4 ? sn4(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var ee5 = (o4, e) => {
  for (var t in e || (e = {})) on3.call(e, t) && Qt4(o4, t, e[t]);
  if (Zt4) for (var t of Zt4(e)) an4.call(e, t) && Qt4(o4, t, e[t]);
  return o4;
};
var Ce5 = (o4, e) => rn4(o4, nn4(e));
var ei3 = class extends d4 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new tn4(), this.events = new import_events12.EventEmitter(), this.name = pt3, this.version = yt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O6, this.subscribeTimeout = (0, import_time7.toMiliseconds)(import_time7.ONE_MINUTE), this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = true;
    }, this.subscribe = async (s2, i3) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i3 } });
      try {
        const r3 = zu(i3), n4 = { topic: s2, relay: r3, transportType: i3 == null ? void 0 : i3.transportType };
        this.pending.set(s2, n4);
        const a5 = await this.rpcSubscribe(s2, r3, i3 == null ? void 0 : i3.transportType);
        return typeof a5 == "string" && (this.onSubscribe(a5, n4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i3 } })), a5;
      } catch (r3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r3), r3;
      }
    }, this.unsubscribe = async (s2, i3) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i3 == null ? void 0 : i3.id) < "u" ? await this.unsubscribeById(s2, i3.id, i3) : await this.unsubscribeByTopic(s2, i3);
    }, this.isSubscribed = async (s2) => {
      if (this.topics.includes(s2)) return true;
      const i3 = `${this.pendingSubscriptionWatchLabel}_${s2}`;
      return await new Promise((r3, n4) => {
        const a5 = new import_time7.Watch();
        a5.start(i3);
        const c7 = setInterval(() => {
          !this.pending.has(s2) && this.topics.includes(s2) && (clearInterval(c7), a5.stop(i3), r3(true)), a5.elapsed(i3) >= Dt4 && (clearInterval(c7), a5.stop(i3), n4(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let s2 = false;
    try {
      s2 = this.getSubscription(e).topic === t;
    } catch {
    }
    return s2;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const s2 = this.topicMap.get(e);
    await Promise.all(s2.map(async (i3) => await this.unsubscribeById(e, i3, t)));
  }
  async unsubscribeById(e, t, s2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    try {
      const i3 = zu(s2);
      await this.rpcUnsubscribe(e, t, i3);
      const r3 = er3("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, r3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    } catch (i3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i3), i3;
    }
  }
  async rpcSubscribe(e, t, s2 = F4.relay) {
    s2 === F4.relay && await this.restartToComplete();
    const i3 = { method: ju(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      const r3 = Ou(e + this.clientId);
      return s2 === F4.link_mode ? (setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(i3).catch((n4) => this.logger.warn(n4));
      }, (0, import_time7.toMiliseconds)(import_time7.ONE_SECOND)), r3) : await await ms2(this.relayer.request(i3).catch((n4) => this.logger.warn(n4)), this.subscribeTimeout) ? r3 : null;
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(w4.connection_stalled);
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, s2 = { method: ju(t.protocol).batchSubscribe, params: { topics: e.map((i3) => i3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    try {
      return await await ms2(this.relayer.request(s2).catch((i3) => this.logger.warn(i3)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(w4.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, s2 = { method: ju(t.protocol).batchFetchMessages, params: { topics: e.map((r3) => r3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    let i3;
    try {
      i3 = await await ms2(this.relayer.request(s2).catch((r3) => this.logger.warn(r3)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(w4.connection_stalled);
    }
    return i3;
  }
  rpcUnsubscribe(e, t, s2) {
    const i3 = { method: ju(s2.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 }), this.relayer.request(i3);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, Ce5(ee5({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, ee5({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, s2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s2), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, ee5({}, t)), this.topicMap.set(t.topic, e), this.events.emit(A3.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const s2 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(s2.topic, e), this.events.emit(A3.deleted, Ce5(ee5({}, s2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(A3.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const s2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(s2), await this.batchSubscribe(s2);
      }
    }
    this.events.emit(A3.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length) return;
    const t = await this.rpcBatchSubscribe(e);
    Nr4(t) && this.onBatchSubscribe(t.map((s2, i3) => Ce5(ee5({}, e[i3]), { id: s2 })));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(t.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r2.pulse, async () => {
      await this.checkPending();
    }), this.events.on(A3.created, async (e) => {
      const t = A3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(A3.deleted, async (e) => {
      const t = A3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var cn4 = Object.defineProperty;
var ti2 = Object.getOwnPropertySymbols;
var hn4 = Object.prototype.hasOwnProperty;
var ln4 = Object.prototype.propertyIsEnumerable;
var ii2 = (o4, e, t) => e in o4 ? cn4(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var un4 = (o4, e) => {
  for (var t in e || (e = {})) hn4.call(e, t) && ii2(o4, t, e[t]);
  if (ti2) for (var t of ti2(e)) ln4.call(e, t) && ii2(o4, t, e[t]);
  return o4;
};
var si3 = class extends u2 {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events12.EventEmitter(), this.name = ht3, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = false, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = (0, import_time7.toMiliseconds)(import_time7.THIRTY_SECONDS + import_time7.ONE_SECOND), this.request = async (t) => {
      var s2, i3;
      this.logger.debug("Publishing Request Payload");
      const r3 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        const n4 = this.provider.request(t);
        this.requestsInFlight.set(r3, { promise: n4, request: t }), this.logger.trace({ id: r3, method: t.method, topic: (s2 = t.params) == null ? void 0 : s2.topic }, "relayer.request - attempt to publish...");
        const a5 = await new Promise(async (c7, h7) => {
          const d5 = () => {
            h7(new Error(`relayer.request - publish interrupted, id: ${r3}`));
          };
          this.provider.on(T2.disconnect, d5);
          const g4 = await n4;
          this.provider.off(T2.disconnect, d5), c7(g4);
        });
        return this.logger.trace({ id: r3, method: t.method, topic: (i3 = t.params) == null ? void 0 : i3.topic }, "relayer.request - published"), a5;
      } catch (n4) {
        throw this.logger.debug(`Failed to Publish Request: ${r3}`), n4;
      } finally {
        this.requestsInFlight.delete(r3);
      }
    }, this.resetPingTimeout = () => {
      if (bi3()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var t, s2, i3;
          (i3 = (s2 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s2.socket) == null || i3.terminate();
        }, this.heartBeatTimeout);
      } catch (t) {
        this.logger.warn(t);
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(w4.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(w4.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(T2.payload, this.onPayloadHandler), this.provider.on(T2.connect, this.onConnectHandler), this.provider.on(T2.disconnect, this.onDisconnectHandler), this.provider.on(T2.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E(e.logger, this.name) : (0, import_pino.default)(k({ level: e.logger || ct2 })), this.messages = new Xt4(this.logger, e.core), this.subscriber = new ei3(this, this.logger), this.publisher = new en4(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ee4, this.projectId = e.projectId, this.bundleId = ns(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 1;
  }
  get connecting() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 0;
  }
  async publish(e, t, s2) {
    this.isInitialized(), await this.publisher.publish(e, t, s2), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: F4.relay });
  }
  async subscribe(e, t) {
    var s2;
    this.isInitialized(), (t == null ? void 0 : t.transportType) === "relay" && await this.toEstablishConnection();
    let i3 = ((s2 = this.subscriber.topicMap.get(e)) == null ? void 0 : s2[0]) || "", r3;
    const n4 = (a5) => {
      a5.topic === e && (this.subscriber.off(A3.created, n4), r3());
    };
    return await Promise.all([new Promise((a5) => {
      r3 = a5, this.subscriber.on(A3.created, n4);
    }), new Promise(async (a5) => {
      i3 = await this.subscriber.subscribe(e, t) || i3, a5();
    })]), i3;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((e) => e.promise));
    } catch (e) {
      this.logger.warn(e);
    }
    this.hasExperiencedNetworkDisruption || this.connected ? await ms2(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    try {
      await new Promise(async (t, s2) => {
        const i3 = () => {
          this.provider.off(T2.disconnect, i3), s2(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(T2.disconnect, i3), await ms2(this.provider.connect(), (0, import_time7.toMiliseconds)(import_time7.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((r3) => {
          s2(r3);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((r3) => {
          this.logger.error(r3), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = false, t();
      });
    } catch (t) {
      this.logger.error(t);
      const s2 = t;
      if (this.hasExperiencedNetworkDisruption = true, !this.isConnectionStalled(s2.message)) throw t;
    } finally {
      this.connectionAttemptInProgress = false;
    }
  }
  async restartTransport(e) {
    this.connectionAttemptInProgress || (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Bh()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((s2, i3) => s2.publishedAt - i3.publishedAt);
    this.logger.trace(`Batch of ${t.length} message events sorted`);
    for (const s2 of t) try {
      await this.onMessageEvent(s2);
    } catch (i3) {
      this.logger.warn(i3);
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: s2 } = e;
    if (!t.sessionExists) {
      const i3 = ws2(import_time7.FIVE_MINUTES), r3 = { topic: s2, expiry: i3, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s2, r3);
    }
    this.events.emit(w4.message, e), await this.recordMessageEvent(e);
  }
  startPingTimeout() {
    var e, t, s2, i3, r3;
    if (bi3()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((r3 = (i3 = (s2 = this.provider) == null ? void 0 : s2.connection) == null ? void 0 : i3.socket) == null || r3.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (n4) {
      this.logger.warn(n4);
    }
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o2(new f4(ss({ sdkVersion: oe3, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    await this.messages.set(t, s2);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    if (!s2 || s2.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${s2}`), true;
    if (!await this.subscriber.isSubscribed(t)) return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const i3 = this.messages.has(t, s2);
    return i3 && this.logger.debug(`Ignoring duplicate message: ${s2}`), i3;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(lt3)) return;
      const t = e.params, { topic: s2, message: i3, publishedAt: r3, attestation: n4 } = t.data, a5 = { topic: s2, message: i3, publishedAt: r3, transportType: F4.relay, attestation: n4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(un4({ type: "event", event: t.id }, a5)), this.events.emit(t.id, a5), await this.acknowledgePayload(e), await this.onMessageEvent(a5);
    } else isJsonRpcResponse(e) && this.events.emit(w4.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(w4.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(T2.payload, this.onPayloadHandler), this.provider.off(T2.connect, this.onConnectHandler), this.provider.off(T2.disconnect, this.onDisconnectHandler), this.provider.off(T2.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await Bh();
    Ch(async (t) => {
      e !== t && (e = t, t ? await this.restartTransport().catch((s2) => this.logger.error(s2)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(w4.disconnect), this.connectionAttemptInProgress = false, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e));
    }, (0, import_time7.toMiliseconds)(ut3))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.connected && (clearInterval(t), e());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
};
var dn4 = Object.defineProperty;
var ri3 = Object.getOwnPropertySymbols;
var gn3 = Object.prototype.hasOwnProperty;
var pn4 = Object.prototype.propertyIsEnumerable;
var ni3 = (o4, e, t) => e in o4 ? dn4(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var oi2 = (o4, e) => {
  for (var t in e || (e = {})) gn3.call(e, t) && ni3(o4, t, e[t]);
  if (ri3) for (var t of ri3(e)) pn4.call(e, t) && ni3(o4, t, e[t]);
  return o4;
};
var ai2 = class extends p3 {
  constructor(e, t, s2, i3 = O6, r3 = void 0) {
    super(e, t, s2, i3), this.core = e, this.logger = t, this.name = s2, this.map = /* @__PURE__ */ new Map(), this.version = dt3, this.cached = [], this.initialized = false, this.storagePrefix = O6, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n4) => {
        this.getKey && n4 !== null && !Pe3(n4) ? this.map.set(this.getKey(n4), n4) : lh(n4) ? this.map.set(n4.id, n4) : dh(n4) && this.map.set(n4.topic, n4);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (n4, a5) => {
      this.isInitialized(), this.map.has(n4) ? await this.update(n4, a5) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: n4, value: a5 }), this.map.set(n4, a5), await this.persist());
    }, this.get = (n4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: n4 }), this.getData(n4)), this.getAll = (n4) => (this.isInitialized(), n4 ? this.values.filter((a5) => Object.keys(n4).every((c7) => (0, import_lodash.default)(a5[c7], n4[c7]))) : this.values), this.update = async (n4, a5) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: n4, update: a5 });
      const c7 = oi2(oi2({}, this.getData(n4)), a5);
      this.map.set(n4, c7), await this.persist();
    }, this.delete = async (n4, a5) => {
      this.isInitialized(), this.map.has(n4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: n4, reason: a5 }), this.map.delete(n4), this.addToRecentlyDeleted(n4), await this.persist());
    }, this.logger = E(t, this.name), this.storagePrefix = i3, this.getKey = r3;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(i3), new Error(i3);
      }
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(s2), new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var ci2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = mt3, this.version = bt3, this.events = new import_events12.default(), this.initialized = false, this.storagePrefix = O6, this.ignoredPayloadTypes = [pr3], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: s2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s2])];
    }, this.create = async (s2) => {
      this.isInitialized();
      const i3 = Bu(), r3 = await this.core.crypto.setSymKey(i3), n4 = ws2(import_time7.FIVE_MINUTES), a5 = { protocol: at2 }, c7 = { topic: r3, expiry: n4, relay: a5, active: false, methods: s2 == null ? void 0 : s2.methods }, h7 = $u({ protocol: this.core.protocol, version: this.core.version, topic: r3, symKey: i3, relay: a5, expiryTimestamp: n4, methods: s2 == null ? void 0 : s2.methods });
      return this.events.emit(q2.create, c7), this.core.expirer.set(r3, n4), await this.pairings.set(r3, c7), await this.core.relayer.subscribe(r3, { transportType: s2 == null ? void 0 : s2.transportType }), { topic: r3, uri: h7 };
    }, this.pair = async (s2) => {
      this.isInitialized();
      const i3 = this.core.eventClient.createEvent({ properties: { topic: s2 == null ? void 0 : s2.uri, trace: [z6.pairing_started] } });
      this.isValidPair(s2, i3);
      const { topic: r3, symKey: n4, relay: a5, expiryTimestamp: c7, methods: h7 } = Xu(s2.uri);
      i3.props.properties.topic = r3, i3.addTrace(z6.pairing_uri_validation_success), i3.addTrace(z6.pairing_uri_not_expired);
      let d5;
      if (this.pairings.keys.includes(r3)) {
        if (d5 = this.pairings.get(r3), i3.addTrace(z6.existing_pairing), d5.active) throw i3.setError(M5.active_pairing_already_exists), new Error(`Pairing already exists: ${r3}. Please try again with a new connection URI.`);
        i3.addTrace(z6.pairing_not_expired);
      }
      const g4 = c7 || ws2(import_time7.FIVE_MINUTES), m2 = { topic: r3, relay: a5, expiry: g4, active: false, methods: h7 };
      this.core.expirer.set(r3, g4), await this.pairings.set(r3, m2), i3.addTrace(z6.store_new_pairing), s2.activatePairing && await this.activate({ topic: r3 }), this.events.emit(q2.create, m2), i3.addTrace(z6.emit_inactive_pairing), this.core.crypto.keychain.has(r3) || await this.core.crypto.setSymKey(n4, r3), i3.addTrace(z6.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i3.setError(M5.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r3, { relay: a5 });
      } catch (b6) {
        throw i3.setError(M5.subscribe_pairing_topic_failure), b6;
      }
      return i3.addTrace(z6.subscribe_pairing_topic_success), m2;
    }, this.activate = async ({ topic: s2 }) => {
      this.isInitialized();
      const i3 = ws2(import_time7.THIRTY_DAYS);
      this.core.expirer.set(s2, i3), await this.pairings.update(s2, { active: true, expiry: i3 });
    }, this.ping = async (s2) => {
      this.isInitialized(), await this.isValidPing(s2);
      const { topic: i3 } = s2;
      if (this.pairings.keys.includes(i3)) {
        const r3 = await this.sendRequest(i3, "wc_pairingPing", {}), { done: n4, resolve: a5, reject: c7 } = gs2();
        this.events.once(Ms2("pairing_ping", r3), ({ error: h7 }) => {
          h7 ? c7(h7) : a5();
        }), await n4();
      }
    }, this.updateExpiry = async ({ topic: s2, expiry: i3 }) => {
      this.isInitialized(), await this.pairings.update(s2, { expiry: i3 });
    }, this.updateMetadata = async ({ topic: s2, metadata: i3 }) => {
      this.isInitialized(), await this.pairings.update(s2, { peerMetadata: i3 });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s2) => {
      this.isInitialized(), await this.isValidDisconnect(s2);
      const { topic: i3 } = s2;
      this.pairings.keys.includes(i3) && (await this.sendRequest(i3, "wc_pairingDelete", er3("USER_DISCONNECTED")), await this.deletePairing(i3));
    }, this.formatUriFromPairing = (s2) => {
      this.isInitialized();
      const { topic: i3, relay: r3, expiry: n4, methods: a5 } = s2, c7 = this.core.crypto.keychain.get(i3);
      return $u({ protocol: this.core.protocol, version: this.core.version, topic: i3, symKey: c7, relay: r3, expiryTimestamp: n4, methods: a5 });
    }, this.sendRequest = async (s2, i3, r3) => {
      const n4 = formatJsonRpcRequest(i3, r3), a5 = await this.core.crypto.encode(s2, n4), c7 = j5[i3].req;
      return this.core.history.set(s2, n4), this.core.relayer.publish(s2, a5, c7), n4.id;
    }, this.sendResult = async (s2, i3, r3) => {
      const n4 = formatJsonRpcResult(s2, r3), a5 = await this.core.crypto.encode(i3, n4), c7 = await this.core.history.get(i3, s2), h7 = j5[c7.request.method].res;
      await this.core.relayer.publish(i3, a5, h7), await this.core.history.resolve(n4);
    }, this.sendError = async (s2, i3, r3) => {
      const n4 = formatJsonRpcError(s2, r3), a5 = await this.core.crypto.encode(i3, n4), c7 = await this.core.history.get(i3, s2), h7 = j5[c7.request.method] ? j5[c7.request.method].res : j5.unregistered_method.res;
      await this.core.relayer.publish(i3, a5, h7), await this.core.history.resolve(n4);
    }, this.deletePairing = async (s2, i3) => {
      await this.core.relayer.unsubscribe(s2), await Promise.all([this.pairings.delete(s2, er3("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s2), i3 ? Promise.resolve() : this.core.expirer.del(s2)]);
    }, this.cleanup = async () => {
      const s2 = this.pairings.getAll().filter((i3) => xs2(i3.expiry));
      await Promise.all(s2.map((i3) => this.deletePairing(i3.topic)));
    }, this.onRelayEventRequest = (s2) => {
      const { topic: i3, payload: r3 } = s2;
      switch (r3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i3, r3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i3, r3);
        default:
          return this.onUnknownRpcMethodRequest(i3, r3);
      }
    }, this.onRelayEventResponse = async (s2) => {
      const { topic: i3, payload: r3 } = s2, n4 = (await this.core.history.get(i3, r3.id)).request.method;
      switch (n4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i3, r3);
        default:
          return this.onUnknownRpcMethodResponse(n4);
      }
    }, this.onPairingPingRequest = async (s2, i3) => {
      const { id: r3 } = i3;
      try {
        this.isValidPing({ topic: s2 }), await this.sendResult(r3, s2, true), this.events.emit(q2.ping, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onPairingPingResponse = (s2, i3) => {
      const { id: r3 } = i3;
      setTimeout(() => {
        isJsonRpcResult(i3) ? this.events.emit(Ms2("pairing_ping", r3), {}) : isJsonRpcError(i3) && this.events.emit(Ms2("pairing_ping", r3), { error: i3.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (s2, i3) => {
      const { id: r3 } = i3;
      try {
        this.isValidDisconnect({ topic: s2 }), await this.deletePairing(s2), this.events.emit(q2.delete, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onUnknownRpcMethodRequest = async (s2, i3) => {
      const { id: r3, method: n4 } = i3;
      try {
        if (this.registeredMethods.includes(n4)) return;
        const a5 = er3("WC_METHOD_UNSUPPORTED", n4);
        await this.sendError(r3, s2, a5), this.logger.error(a5);
      } catch (a5) {
        await this.sendError(r3, s2, a5), this.logger.error(a5);
      }
    }, this.onUnknownRpcMethodResponse = (s2) => {
      this.registeredMethods.includes(s2) || this.logger.error(er3("WC_METHOD_UNSUPPORTED", s2));
    }, this.isValidPair = (s2, i3) => {
      var r3;
      if (!Ah(s2)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `pair() params: ${s2}`);
        throw i3.setError(M5.malformed_pairing_uri), new Error(a5);
      }
      if (!ch(s2.uri)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `pair() uri: ${s2.uri}`);
        throw i3.setError(M5.malformed_pairing_uri), new Error(a5);
      }
      const n4 = Xu(s2 == null ? void 0 : s2.uri);
      if (!((r3 = n4 == null ? void 0 : n4.relay) != null && r3.protocol)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i3.setError(M5.malformed_pairing_uri), new Error(a5);
      }
      if (!(n4 != null && n4.symKey)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i3.setError(M5.malformed_pairing_uri), new Error(a5);
      }
      if (n4 != null && n4.expiryTimestamp && (0, import_time7.toMiliseconds)(n4 == null ? void 0 : n4.expiryTimestamp) < Date.now()) {
        i3.setError(M5.pairing_expired);
        const { message: a5 } = xe("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a5);
      }
    }, this.isValidPing = async (s2) => {
      if (!Ah(s2)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `ping() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i3 } = s2;
      await this.isValidPairingTopic(i3);
    }, this.isValidDisconnect = async (s2) => {
      if (!Ah(s2)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `disconnect() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i3 } = s2;
      await this.isValidPairingTopic(i3);
    }, this.isValidPairingTopic = async (s2) => {
      if (!Yt4(s2, false)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `pairing topic should be a string: ${s2}`);
        throw new Error(i3);
      }
      if (!this.pairings.keys.includes(s2)) {
        const { message: i3 } = xe("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s2}`);
        throw new Error(i3);
      }
      if (xs2(this.pairings.get(s2).expiry)) {
        await this.deletePairing(s2);
        const { message: i3 } = xe("EXPIRED", `pairing topic: ${s2}`);
        throw new Error(i3);
      }
    }, this.core = e, this.logger = E(t, this.name), this.pairings = new ai2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(w4.message, async (e) => {
      const { topic: t, message: s2, transportType: i3 } = e;
      if (!this.pairings.keys.includes(t) || i3 === F4.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s2))) return;
      const r3 = await this.core.crypto.decode(t, s2);
      try {
        isJsonRpcRequest(r3) ? (this.core.history.set(t, r3), this.onRelayEventRequest({ topic: t, payload: r3 })) : isJsonRpcResponse(r3) && (await this.core.history.resolve(r3), await this.onRelayEventResponse({ topic: t, payload: r3 }), this.core.history.delete(t, r3.id));
      } catch (n4) {
        this.logger.error(n4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(R4.expired, async (e) => {
      const { topic: t } = ys2(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(q2.expire, { topic: t }));
    });
  }
};
var hi2 = class extends h5 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events12.EventEmitter(), this.name = ft3, this.version = _t3, this.cached = [], this.initialized = false, this.storagePrefix = O6, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.records.set(s2.id, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (s2, i3, r3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s2, request: i3, chainId: r3 }), this.records.has(i3.id)) return;
      const n4 = { id: i3.id, topic: s2, request: { method: i3.method, params: i3.params || null }, chainId: r3, expiry: ws2(import_time7.THIRTY_DAYS) };
      this.records.set(n4.id, n4), this.persist(), this.events.emit(P3.created, n4);
    }, this.resolve = async (s2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s2 }), !this.records.has(s2.id)) return;
      const i3 = await this.getRecord(s2.id);
      typeof i3.response > "u" && (i3.response = isJsonRpcError(s2) ? { error: s2.error } : { result: s2.result }, this.records.set(i3.id, i3), this.persist(), this.events.emit(P3.updated, i3));
    }, this.get = async (s2, i3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s2, id: i3 }), await this.getRecord(i3)), this.delete = (s2, i3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i3 }), this.values.forEach((r3) => {
        if (r3.topic === s2) {
          if (typeof i3 < "u" && r3.id !== i3) return;
          this.records.delete(r3.id), this.events.emit(P3.deleted, r3);
        }
      }), this.persist();
    }, this.exists = async (s2, i3) => (this.isInitialized(), this.records.has(i3) ? (await this.getRecord(i3)).topic === s2 : false), this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const s2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(s2);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(P3.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(P3.created, (e) => {
      const t = P3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(P3.updated, (e) => {
      const t = P3.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(P3.deleted, (e) => {
      const t = P3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r2.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time7.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(P3.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var li3 = class extends x4 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events12.EventEmitter(), this.name = Et4, this.version = vt2, this.cached = [], this.initialized = false, this.storagePrefix = O6, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.expirations.set(s2.target, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (s2) => {
      try {
        const i3 = this.formatTarget(s2);
        return typeof this.getExpiration(i3) < "u";
      } catch {
        return false;
      }
    }, this.set = (s2, i3) => {
      this.isInitialized();
      const r3 = this.formatTarget(s2), n4 = { target: r3, expiry: i3 };
      this.expirations.set(r3, n4), this.checkExpiry(r3, n4), this.events.emit(R4.created, { target: r3, expiration: n4 });
    }, this.get = (s2) => {
      this.isInitialized();
      const i3 = this.formatTarget(s2);
      return this.getExpiration(i3);
    }, this.del = (s2) => {
      if (this.isInitialized(), this.has(s2)) {
        const i3 = this.formatTarget(s2), r3 = this.getExpiration(i3);
        this.expirations.delete(i3), this.events.emit(R4.deleted, { target: i3, expiration: r3 });
      }
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return As2(e);
    if (typeof e == "number") return bs2(e);
    const { message: t } = xe("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(R4.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(s2), new Error(s2);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: s2 } = t;
    (0, import_time7.toMiliseconds)(s2) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(R4.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r2.pulse, () => this.checkExpirations()), this.events.on(R4.created, (e) => {
      const t = R4.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(R4.expired, (e) => {
      const t = R4.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(R4.deleted, (e) => {
      const t = R4.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var y8 = {};
Object.defineProperty(y8, "__esModule", { value: true }), y8.getLocalStorage = y8.getLocalStorageOrThrow = y8.getCrypto = y8.getCryptoOrThrow = y8.getLocation = y8.getLocationOrThrow = y8.getNavigator = y8.getNavigatorOrThrow = ui2 = y8.getDocument = y8.getDocumentOrThrow = y8.getFromWindowOrThrow = y8.getFromWindow = void 0;
function U3(o4) {
  let e;
  return typeof window < "u" && typeof window[o4] < "u" && (e = window[o4]), e;
}
y8.getFromWindow = U3;
function G4(o4) {
  const e = U3(o4);
  if (!e) throw new Error(`${o4} is not defined in Window`);
  return e;
}
y8.getFromWindowOrThrow = G4;
function yn2() {
  return G4("document");
}
y8.getDocumentOrThrow = yn2;
function Dn2() {
  return U3("document");
}
var ui2 = y8.getDocument = Dn2;
function mn3() {
  return G4("navigator");
}
y8.getNavigatorOrThrow = mn3;
function bn2() {
  return U3("navigator");
}
y8.getNavigator = bn2;
function fn4() {
  return G4("location");
}
y8.getLocationOrThrow = fn4;
function _n2() {
  return U3("location");
}
y8.getLocation = _n2;
function En4() {
  return G4("crypto");
}
y8.getCryptoOrThrow = En4;
function vn3() {
  return U3("crypto");
}
y8.getCrypto = vn3;
function wn2() {
  return G4("localStorage");
}
y8.getLocalStorageOrThrow = wn2;
function In3() {
  return U3("localStorage");
}
y8.getLocalStorage = In3;
var di3 = class extends y6 {
  constructor(e, t, s2) {
    super(e, t, s2), this.core = e, this.logger = t, this.store = s2, this.name = wt3, this.verifyUrlV3 = Tt5, this.storagePrefix = O6, this.version = fe4, this.init = async () => {
      var i3;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time7.toMiliseconds)((i3 = this.publicKey) == null ? void 0 : i3.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i3) => {
      if (!gr3() || this.isDevEnv) return;
      const r3 = window.location.origin, { id: n4, decryptedId: a5 } = i3, c7 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r3}&id=${n4}&decryptedId=${a5}`;
      try {
        const h7 = ui2(), d5 = this.startAbortTimer(import_time7.ONE_SECOND * 5), g4 = await new Promise((m2, b6) => {
          const l7 = () => {
            window.removeEventListener("message", E6), h7.body.removeChild(p5), b6("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", l7);
          const p5 = h7.createElement("iframe");
          p5.src = c7, p5.style.display = "none", p5.addEventListener("error", l7, { signal: this.abortController.signal });
          const E6 = (D5) => {
            if (D5.data && typeof D5.data == "string") try {
              const f6 = JSON.parse(D5.data);
              if (f6.type === "verify_attestation") {
                if (decodeJWT(f6.attestation).payload.id !== n4) return;
                clearInterval(d5), h7.body.removeChild(p5), this.abortController.signal.removeEventListener("abort", l7), window.removeEventListener("message", E6), m2(f6.attestation === null ? "" : f6.attestation);
              }
            } catch (f6) {
              this.logger.warn(f6);
            }
          };
          h7.body.appendChild(p5), window.addEventListener("message", E6, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", g4), g4;
      } catch (h7) {
        this.logger.warn(h7);
      }
      return "";
    }, this.resolve = async (i3) => {
      if (this.isDevEnv) return "";
      const { attestationId: r3, hash: n4, encryptedId: a5 } = i3;
      if (r3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r3) {
        if (decodeJWT(r3).payload.id !== a5) return;
        const h7 = await this.isValidJwtAttestation(r3);
        if (h7) {
          if (!h7.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h7;
        }
      }
      if (!n4) return;
      const c7 = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      return this.fetchAttestation(n4, c7);
    }, this.fetchAttestation = async (i3, r3) => {
      this.logger.debug(`resolving attestation: ${i3} from url: ${r3}`);
      const n4 = this.startAbortTimer(import_time7.ONE_SECOND * 5), a5 = await fetch(`${r3}/attestation/${i3}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(n4), a5.status === 200 ? await a5.json() : void 0;
    }, this.getVerifyUrl = (i3) => {
      let r3 = i3 || Z3;
      return Ct4.includes(r3) || (this.logger.info(`verify url: ${r3}, not included in trusted list, assigning default: ${Z3}`), r3 = Z3), r3;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i3 = this.startAbortTimer(import_time7.FIVE_SECONDS), r3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i3), await r3.json();
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.persistPublicKey = async (i3) => {
      this.logger.debug("persisting public key to local storage", i3), await this.store.setItem(this.storeKey, i3), this.publicKey = i3;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i3) => {
      const r3 = await this.getPublicKey();
      try {
        if (r3) return this.validateAttestation(i3, r3);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
      const n4 = await this.fetchAndPersistPublicKey();
      try {
        if (n4) return this.validateAttestation(i3, n4);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r3) => {
        const n4 = await this.fetchPublicKey();
        n4 && (await this.persistPublicKey(n4), r3(n4));
      });
      const i3 = await this.fetchPromise;
      return this.fetchPromise = void 0, i3;
    }, this.validateAttestation = (i3, r3) => {
      const n4 = Lu(i3, r3.publicKey), a5 = { hasExpired: (0, import_time7.toMiliseconds)(n4.exp) < Date.now(), payload: n4 };
      if (a5.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a5.payload.origin, isScam: a5.payload.isScam, isVerified: a5.payload.isVerified };
    }, this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = _s2(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time7.toMiliseconds)(e));
  }
};
var gi3 = class extends v4 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.context = St4, this.registerDeviceToken = async (s2) => {
      const { clientId: i3, token: r3, notificationType: n4, enableEncrypted: a5 = false } = s2, c7 = `${Pt4}/${this.projectId}/clients`;
      await fetch(c7, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i3, type: n4, token: r3, always_raw: a5 }) });
    }, this.logger = E(t, this.context);
  }
};
var Tn2 = Object.defineProperty;
var pi3 = Object.getOwnPropertySymbols;
var Cn4 = Object.prototype.hasOwnProperty;
var Sn4 = Object.prototype.propertyIsEnumerable;
var yi4 = (o4, e, t) => e in o4 ? Tn2(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var te5 = (o4, e) => {
  for (var t in e || (e = {})) Cn4.call(e, t) && yi4(o4, t, e[t]);
  if (pi3) for (var t of pi3(e)) Sn4.call(e, t) && yi4(o4, t, e[t]);
  return o4;
};
var Di4 = class extends C3 {
  constructor(e, t, s2 = true) {
    super(e, t, s2), this.core = e, this.logger = t, this.context = xt4, this.storagePrefix = O6, this.storageVersion = Rt4, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = false, this.init = async () => {
      if (!_s2()) try {
        const i3 = { eventId: Ns2(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Pn3(this.core.relayer.protocol, this.core.relayer.version, oe3) } } };
        await this.sendEvent([i3]);
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.createEvent = (i3) => {
      const { event: r3 = "ERROR", type: n4 = "", properties: { topic: a5, trace: c7 } } = i3, h7 = Ns2(), d5 = this.core.projectId || "", g4 = Date.now(), m2 = te5({ eventId: h7, timestamp: g4, props: { event: r3, type: n4, properties: { topic: a5, trace: c7 } }, bundleId: d5, domain: this.getAppDomain() }, this.setMethods(h7));
      return this.telemetryEnabled && (this.events.set(h7, m2), this.shouldPersist = true), m2;
    }, this.getEvent = (i3) => {
      const { eventId: r3, topic: n4 } = i3;
      if (r3) return this.events.get(r3);
      const a5 = Array.from(this.events.values()).find((c7) => c7.props.properties.topic === n4);
      if (a5) return te5(te5({}, a5), this.setMethods(a5.eventId));
    }, this.deleteEvent = (i3) => {
      const { eventId: r3 } = i3;
      this.events.delete(r3), this.shouldPersist = true;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r2.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i3) => {
          (0, import_time7.fromMiliseconds)(Date.now()) - (0, import_time7.fromMiliseconds)(i3.timestamp) > Ot5 && (this.events.delete(i3.eventId), this.shouldPersist = true);
        });
      });
    }, this.setMethods = (i3) => ({ addTrace: (r3) => this.addTrace(i3, r3), setError: (r3) => this.setError(i3, r3) }), this.addTrace = (i3, r3) => {
      const n4 = this.events.get(i3);
      n4 && (n4.props.properties.trace.push(r3), this.events.set(i3, n4), this.shouldPersist = true);
    }, this.setError = (i3, r3) => {
      const n4 = this.events.get(i3);
      n4 && (n4.props.type = r3, n4.timestamp = Date.now(), this.events.set(i3, n4), this.shouldPersist = true);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }, this.restore = async () => {
      try {
        const i3 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i3.length) return;
        i3.forEach((r3) => {
          this.events.set(r3.eventId, te5(te5({}, r3), this.setMethods(r3.eventId)));
        });
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i3 = [];
      for (const [r3, n4] of this.events) n4.props.type && i3.push(n4);
      if (i3.length !== 0) try {
        if ((await this.sendEvent(i3)).ok) for (const r3 of i3) this.events.delete(r3.eventId), this.shouldPersist = true;
      } catch (r3) {
        this.logger.warn(r3);
      }
    }, this.sendEvent = async (i3) => {
      const r3 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${At4}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${oe3}${r3}`, { method: "POST", body: JSON.stringify(i3) });
    }, this.getAppDomain = () => fs().url, this.logger = E(t, this.context), this.telemetryEnabled = s2, s2 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Pn4 = Object.defineProperty;
var mi3 = Object.getOwnPropertySymbols;
var Rn3 = Object.prototype.hasOwnProperty;
var xn3 = Object.prototype.propertyIsEnumerable;
var bi4 = (o4, e, t) => e in o4 ? Pn4(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var fi3 = (o4, e) => {
  for (var t in e || (e = {})) Rn3.call(e, t) && bi4(o4, t, e[t]);
  if (mi3) for (var t of mi3(e)) xn3.call(e, t) && bi4(o4, t, e[t]);
  return o4;
};
var ce3 = class _ce extends n3 {
  constructor(e) {
    var t;
    super(e), this.protocol = be5, this.version = fe4, this.name = ne4, this.events = new import_events12.EventEmitter(), this.initialized = false, this.on = (n4, a5) => this.events.on(n4, a5), this.once = (n4, a5) => this.events.once(n4, a5), this.off = (n4, a5) => this.events.off(n4, a5), this.removeListener = (n4, a5) => this.events.removeListener(n4, a5), this.dispatchEnvelope = ({ topic: n4, message: a5, sessionExists: c7 }) => {
      if (!n4 || !a5) return;
      const h7 = { topic: n4, message: a5, publishedAt: Date.now(), transportType: F4.link_mode };
      this.relayer.onLinkMessageEvent(h7, { sessionExists: c7 });
    }, this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ee4, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s2 = k({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : Xe5.logger }), { logger: i3, chunkLoggerController: r3 } = A({ opts: s2, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = r3, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var n4, a5;
      (n4 = this.logChunkController) != null && n4.downloadLogsBlobInBrowser && ((a5 = this.logChunkController) == null || a5.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(i3, this.name), this.heartbeat = new i(), this.crypto = new Wt4(this, this.logger, e == null ? void 0 : e.keychain), this.history = new hi2(this, this.logger), this.expirer = new li3(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h4(fi3(fi3({}, Ze5), e == null ? void 0 : e.storageOptions)), this.relayer = new si3({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new ci2(this, this.logger), this.verify = new di3(this, this.logger, this.storage), this.echoClient = new gi3(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Di4(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const t = new _ce(e);
    await t.initialize();
    const s2 = await t.crypto.getClientId();
    return await t.storage.setItem(gt2, s2), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(ve3, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(ve3) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var On4 = ce3;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events13 = __toESM(require_events());
var import_time8 = __toESM(require_cjs());
var be6 = "wc";
var Ce6 = 2;
var Le4 = "client";
var ye5 = `${be6}@${Ce6}:${Le4}:`;
var we5 = { name: Le4, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var xe2 = "WALLETCONNECT_DEEPLINK_CHOICE";
var st4 = "proposal";
var it4 = "Proposal expired";
var rt3 = "session";
var z7 = import_time8.SEVEN_DAYS;
var nt4 = "engine";
var v5 = { wc_sessionPropose: { req: { ttl: import_time8.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time8.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time8.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time8.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time8.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var me4 = { min: import_time8.FIVE_MINUTES, max: import_time8.SEVEN_DAYS };
var x5 = { idle: "IDLE", active: "ACTIVE" };
var ot4 = "request";
var at3 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var ct3 = "wc";
var lt4 = "auth";
var pt4 = "authKeys";
var ht4 = "pairingTopics";
var dt4 = "requests";
var oe4 = `${ct3}@${1.5}:${lt4}:`;
var ae4 = `${oe4}:PUB_KEY`;
var ys3 = Object.defineProperty;
var ws3 = Object.defineProperties;
var ms3 = Object.getOwnPropertyDescriptors;
var ut4 = Object.getOwnPropertySymbols;
var _s3 = Object.prototype.hasOwnProperty;
var Es3 = Object.prototype.propertyIsEnumerable;
var gt3 = (q4, o4, e) => o4 in q4 ? ys3(q4, o4, { enumerable: true, configurable: true, writable: true, value: e }) : q4[o4] = e;
var I4 = (q4, o4) => {
  for (var e in o4 || (o4 = {})) _s3.call(o4, e) && gt3(q4, e, o4[e]);
  if (ut4) for (var e of ut4(o4)) Es3.call(o4, e) && gt3(q4, e, o4[e]);
  return q4;
};
var D3 = (q4, o4) => ws3(q4, ms3(o4));
var Rs4 = class extends M4 {
  constructor(o4) {
    super(o4), this.name = nt4, this.events = new import_events13.default(), this.initialized = false, this.requestQueue = { state: x5.idle, queue: [] }, this.sessionRequestQueue = { state: x5.idle, queue: [] }, this.requestQueueDelay = import_time8.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(v5) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time8.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t = D3(I4({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(t);
      const { pairingTopic: s2, requiredNamespaces: i3, optionalNamespaces: r3, sessionProperties: n4, relays: a5 } = t;
      let c7 = s2, h7, p5 = false;
      try {
        c7 && (p5 = this.client.core.pairing.pairings.get(c7).active);
      } catch (E6) {
        throw this.client.logger.error(`connect() -> pairing.get(${c7}) failed`), E6;
      }
      if (!c7 || !p5) {
        const { topic: E6, uri: S7 } = await this.client.core.pairing.create();
        c7 = E6, h7 = S7;
      }
      if (!c7) {
        const { message: E6 } = xe("NO_MATCHING_KEY", `connect() pairing topic: ${c7}`);
        throw new Error(E6);
      }
      const d5 = await this.client.core.crypto.generateKeyPair(), l7 = v5.wc_sessionPropose.req.ttl || import_time8.FIVE_MINUTES, w6 = ws2(l7), m2 = I4({ requiredNamespaces: i3, optionalNamespaces: r3, relays: a5 ?? [{ protocol: at2 }], proposer: { publicKey: d5, metadata: this.client.metadata }, expiryTimestamp: w6, pairingTopic: c7 }, n4 && { sessionProperties: n4 }), { reject: y10, resolve: _5, done: R6 } = gs2(l7, it4);
      this.events.once(Ms2("session_connect"), async ({ error: E6, session: S7 }) => {
        if (E6) y10(E6);
        else if (S7) {
          S7.self.publicKey = d5;
          const M6 = D3(I4({}, S7), { pairingTopic: m2.pairingTopic, requiredNamespaces: m2.requiredNamespaces, optionalNamespaces: m2.optionalNamespaces, transportType: F4.relay });
          await this.client.session.set(S7.topic, M6), await this.setExpiry(S7.topic, S7.expiry), c7 && await this.client.core.pairing.updateMetadata({ topic: c7, metadata: S7.peer.metadata }), this.cleanupDuplicatePairings(M6), _5(M6);
        }
      });
      const V6 = await this.sendRequest({ topic: c7, method: "wc_sessionPropose", params: m2, throwOnFailedPublish: true });
      return await this.setProposal(V6, I4({ id: V6 }, m2)), { uri: h7, approval: R6 };
    }, this.pair = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e);
      } catch (t) {
        throw this.client.logger.error("pair() failed"), t;
      }
    }, this.approve = async (e) => {
      var t, s2, i3;
      const r3 = this.client.core.eventClient.createEvent({ properties: { topic: (t = e == null ? void 0 : e.id) == null ? void 0 : t.toString(), trace: [Cs3.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (N4) {
        throw r3.setError(Ss3.no_internet_connection), N4;
      }
      try {
        await this.isValidProposalId(e == null ? void 0 : e.id);
      } catch (N4) {
        throw this.client.logger.error(`approve() -> proposal.get(${e == null ? void 0 : e.id}) failed`), r3.setError(Ss3.proposal_not_found), N4;
      }
      try {
        await this.isValidApprove(e);
      } catch (N4) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r3.setError(Ss3.session_approve_namespace_validation_failure), N4;
      }
      const { id: n4, relayProtocol: a5, namespaces: c7, sessionProperties: h7, sessionConfig: p5 } = e, d5 = this.client.proposal.get(n4);
      this.client.core.eventClient.deleteEvent({ eventId: r3.eventId });
      const { pairingTopic: l7, proposer: w6, requiredNamespaces: m2, optionalNamespaces: y10 } = d5;
      let _5 = (s2 = this.client.core.eventClient) == null ? void 0 : s2.getEvent({ topic: l7 });
      _5 || (_5 = (i3 = this.client.core.eventClient) == null ? void 0 : i3.createEvent({ type: Cs3.session_approve_started, properties: { topic: l7, trace: [Cs3.session_approve_started, Cs3.session_namespaces_validation_success] } }));
      const R6 = await this.client.core.crypto.generateKeyPair(), V6 = w6.publicKey, E6 = await this.client.core.crypto.generateSharedKey(R6, V6), S7 = I4(I4({ relay: { protocol: a5 ?? "irn" }, namespaces: c7, controller: { publicKey: R6, metadata: this.client.metadata }, expiry: ws2(z7) }, h7 && { sessionProperties: h7 }), p5 && { sessionConfig: p5 }), M6 = F4.relay;
      _5.addTrace(Cs3.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(E6, { transportType: M6 });
      } catch (N4) {
        throw _5.setError(Ss3.subscribe_session_topic_failure), N4;
      }
      _5.addTrace(Cs3.subscribe_session_topic_success);
      const W3 = D3(I4({}, S7), { topic: E6, requiredNamespaces: m2, optionalNamespaces: y10, pairingTopic: l7, acknowledged: false, self: S7.controller, peer: { publicKey: w6.publicKey, metadata: w6.metadata }, controller: R6, transportType: F4.relay });
      await this.client.session.set(E6, W3), _5.addTrace(Cs3.store_session);
      try {
        _5.addTrace(Cs3.publishing_session_settle), await this.sendRequest({ topic: E6, method: "wc_sessionSettle", params: S7, throwOnFailedPublish: true }).catch((N4) => {
          throw _5 == null ? void 0 : _5.setError(Ss3.session_settle_publish_failure), N4;
        }), _5.addTrace(Cs3.session_settle_publish_success), _5.addTrace(Cs3.publishing_session_approve), await this.sendResult({ id: n4, topic: l7, result: { relay: { protocol: a5 ?? "irn" }, responderPublicKey: R6 }, throwOnFailedPublish: true }).catch((N4) => {
          throw _5 == null ? void 0 : _5.setError(Ss3.session_approve_publish_failure), N4;
        }), _5.addTrace(Cs3.session_approve_publish_success);
      } catch (N4) {
        throw this.client.logger.error(N4), this.client.session.delete(E6, er3("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(E6), N4;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _5.eventId }), await this.client.core.pairing.updateMetadata({ topic: l7, metadata: w6.metadata }), await this.client.proposal.delete(n4, er3("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: l7 }), await this.setExpiry(E6, ws2(z7)), { topic: E6, acknowledged: () => Promise.resolve(this.client.session.get(E6)) };
    }, this.reject = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e);
      } catch (r3) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r3;
      }
      const { id: t, reason: s2 } = e;
      let i3;
      try {
        i3 = this.client.proposal.get(t).pairingTopic;
      } catch (r3) {
        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r3;
      }
      i3 && (await this.sendError({ id: t, topic: i3, error: s2, rpcOpts: v5.wc_sessionPropose.reject }), await this.client.proposal.delete(t, er3("USER_DISCONNECTED")));
    }, this.update = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e);
      } catch (p5) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), p5;
      }
      const { topic: t, namespaces: s2 } = e, { done: i3, resolve: r3, reject: n4 } = gs2(), a5 = payloadId(), c7 = getBigIntRpcId().toString(), h7 = this.client.session.get(t).namespaces;
      return this.events.once(Ms2("session_update", a5), ({ error: p5 }) => {
        p5 ? n4(p5) : r3();
      }), await this.client.session.update(t, { namespaces: s2 }), await this.sendRequest({ topic: t, method: "wc_sessionUpdate", params: { namespaces: s2 }, throwOnFailedPublish: true, clientRpcId: a5, relayRpcId: c7 }).catch((p5) => {
        this.client.logger.error(p5), this.client.session.update(t, { namespaces: h7 }), n4(p5);
      }), { acknowledged: i3 };
    }, this.extend = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e);
      } catch (a5) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a5;
      }
      const { topic: t } = e, s2 = payloadId(), { done: i3, resolve: r3, reject: n4 } = gs2();
      return this.events.once(Ms2("session_extend", s2), ({ error: a5 }) => {
        a5 ? n4(a5) : r3();
      }), await this.setExpiry(t, ws2(z7)), this.sendRequest({ topic: t, method: "wc_sessionExtend", params: {}, clientRpcId: s2, throwOnFailedPublish: true }).catch((a5) => {
        n4(a5);
      }), { acknowledged: i3 };
    }, this.request = async (e) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e);
      } catch (w6) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), w6;
      }
      const { chainId: t, request: s2, topic: i3, expiry: r3 = v5.wc_sessionRequest.req.ttl } = e, n4 = this.client.session.get(i3);
      (n4 == null ? void 0 : n4.transportType) === F4.relay && await this.confirmOnlineStateOrThrow();
      const a5 = payloadId(), c7 = getBigIntRpcId().toString(), { done: h7, resolve: p5, reject: d5 } = gs2(r3, "Request expired. Please try again.");
      this.events.once(Ms2("session_request", a5), ({ error: w6, result: m2 }) => {
        w6 ? d5(w6) : p5(m2);
      });
      const l7 = this.getAppLinkIfEnabled(n4.peer.metadata, n4.transportType);
      return l7 ? (await this.sendRequest({ clientRpcId: a5, relayRpcId: c7, topic: i3, method: "wc_sessionRequest", params: { request: D3(I4({}, s2), { expiryTimestamp: ws2(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true, appLink: l7 }).catch((w6) => d5(w6)), this.client.events.emit("session_request_sent", { topic: i3, request: s2, chainId: t, id: a5 }), await h7()) : await Promise.all([new Promise(async (w6) => {
        await this.sendRequest({ clientRpcId: a5, relayRpcId: c7, topic: i3, method: "wc_sessionRequest", params: { request: D3(I4({}, s2), { expiryTimestamp: ws2(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true }).catch((m2) => d5(m2)), this.client.events.emit("session_request_sent", { topic: i3, request: s2, chainId: t, id: a5 }), w6();
      }), new Promise(async (w6) => {
        var m2;
        if (!((m2 = n4.sessionConfig) != null && m2.disableDeepLink)) {
          const y10 = await Ss2(this.client.core.storage, xe2);
          await Es2({ id: a5, topic: i3, wcDeepLink: y10 });
        }
        w6();
      }), h7()]).then((w6) => w6[2]);
    }, this.respond = async (e) => {
      this.isInitialized(), await this.isValidRespond(e);
      const { topic: t, response: s2 } = e, { id: i3 } = s2, r3 = this.client.session.get(t);
      r3.transportType === F4.relay && await this.confirmOnlineStateOrThrow();
      const n4 = this.getAppLinkIfEnabled(r3.peer.metadata, r3.transportType);
      isJsonRpcResult(s2) ? await this.sendResult({ id: i3, topic: t, result: s2.result, throwOnFailedPublish: true, appLink: n4 }) : isJsonRpcError(s2) && await this.sendError({ id: i3, topic: t, error: s2.error, appLink: n4 }), this.cleanupAfterResponse(e);
    }, this.ping = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e);
      } catch (s2) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s2;
      }
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) {
        const s2 = payloadId(), i3 = getBigIntRpcId().toString(), { done: r3, resolve: n4, reject: a5 } = gs2();
        this.events.once(Ms2("session_ping", s2), ({ error: c7 }) => {
          c7 ? a5(c7) : n4();
        }), await Promise.all([this.sendRequest({ topic: t, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s2, relayRpcId: i3 }), r3()]);
      } else this.client.core.pairing.pairings.keys.includes(t) && await this.client.core.pairing.ping({ topic: t });
    }, this.emit = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);
      const { topic: t, event: s2, chainId: i3 } = e, r3 = getBigIntRpcId().toString();
      await this.sendRequest({ topic: t, method: "wc_sessionEvent", params: { event: s2, chainId: i3 }, throwOnFailedPublish: true, relayRpcId: r3 });
    }, this.disconnect = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) await this.sendRequest({ topic: t, method: "wc_sessionDelete", params: er3("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
      else {
        const { message: s2 } = xe("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
        throw new Error(s2);
      }
    }, this.find = (e) => (this.isInitialized(), this.client.session.getAll().filter((t) => hh(t, e))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (e, t) => {
      var s2;
      this.isInitialized(), this.isValidAuthenticate(e);
      const i3 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s2 = this.client.metadata.redirect) == null ? void 0 : s2.linkMode), r3 = i3 ? F4.link_mode : F4.relay;
      r3 === F4.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n4, statement: a5 = "", uri: c7, domain: h7, nonce: p5, type: d5, exp: l7, nbf: w6, methods: m2 = [], expiry: y10 } = e, _5 = [...e.resources || []], { topic: R6, uri: V6 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r3 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: R6, uri: V6 } });
      const E6 = await this.client.core.crypto.generateKeyPair(), S7 = Ru(E6);
      if (await Promise.all([this.client.auth.authKeys.set(ae4, { responseTopic: S7, publicKey: E6 }), this.client.auth.pairingTopics.set(S7, { topic: S7, pairingTopic: R6 })]), await this.client.core.relayer.subscribe(S7, { transportType: r3 }), this.client.logger.info(`sending request to new pairing topic: ${R6}`), m2.length > 0) {
        const { namespace: O8 } = An2(n4[0]);
        let T4 = xu(O8, "request", m2);
        Vr3(_5) && (T4 = Mu(T4, _5.pop())), _5.push(T4);
      }
      const M6 = y10 && y10 > v5.wc_sessionAuthenticate.req.ttl ? y10 : v5.wc_sessionAuthenticate.req.ttl, W3 = { authPayload: { type: d5 ?? "caip122", chains: n4, statement: a5, aud: c7, domain: h7, version: "1", nonce: p5, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: l7, nbf: w6, resources: _5 }, requester: { publicKey: E6, metadata: this.client.metadata }, expiryTimestamp: ws2(M6) }, N4 = { eip155: { chains: n4, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m2])], events: ["chainChanged", "accountsChanged"] } }, De2 = { requiredNamespaces: {}, optionalNamespaces: N4, relays: [{ protocol: "irn" }], pairingTopic: R6, proposer: { publicKey: E6, metadata: this.client.metadata }, expiryTimestamp: ws2(v5.wc_sessionPropose.req.ttl) }, { done: wt4, resolve: Ve2, reject: Ee5 } = gs2(M6, "Request expired"), ce4 = async ({ error: O8, session: T4 }) => {
        if (this.events.off(Ms2("session_request", G5), Re4), O8) Ee5(O8);
        else if (T4) {
          T4.self.publicKey = E6, await this.client.session.set(T4.topic, T4), await this.setExpiry(T4.topic, T4.expiry), R6 && await this.client.core.pairing.updateMetadata({ topic: R6, metadata: T4.peer.metadata });
          const le5 = this.client.session.get(T4.topic);
          await this.deleteProposal(Z5), Ve2({ session: le5 });
        }
      }, Re4 = async (O8) => {
        var T4, le5, Me2;
        if (await this.deletePendingAuthRequest(G5, { message: "fulfilled", code: 0 }), O8.error) {
          const te7 = er3("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return O8.error.code === te7.code ? void 0 : (this.events.off(Ms2("session_connect"), ce4), Ee5(O8.error.message));
        }
        await this.deleteProposal(Z5), this.events.off(Ms2("session_connect"), ce4);
        const { cacaos: ke3, responder: j7 } = O8.result, Ie4 = [], $e2 = [];
        for (const te7 of ke3) {
          await mu({ cacao: te7, projectId: this.client.core.projectId }) || (this.client.logger.error(te7, "Signature verification failed"), Ee5(er3("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: fe5 } = te7, ve4 = Vr3(fe5.resources), Ke4 = [gu(fe5.iss)], mt4 = Vi3(fe5.iss);
          if (ve4) {
            const qe2 = Eu(ve4), _t4 = Su(ve4);
            Ie4.push(...qe2), Ke4.push(..._t4);
          }
          for (const qe2 of Ke4) $e2.push(`${qe2}:${mt4}`);
        }
        const ee7 = await this.client.core.crypto.generateSharedKey(E6, j7.publicKey);
        let pe5;
        Ie4.length > 0 && (pe5 = { topic: ee7, acknowledged: true, self: { publicKey: E6, metadata: this.client.metadata }, peer: j7, controller: j7.publicKey, expiry: ws2(z7), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: R6, namespaces: uh([...new Set(Ie4)], [...new Set($e2)]), transportType: r3 }, await this.client.core.relayer.subscribe(ee7, { transportType: r3 }), await this.client.session.set(ee7, pe5), R6 && await this.client.core.pairing.updateMetadata({ topic: R6, metadata: j7.metadata }), pe5 = this.client.session.get(ee7)), (T4 = this.client.metadata.redirect) != null && T4.linkMode && (le5 = j7.metadata.redirect) != null && le5.linkMode && (Me2 = j7.metadata.redirect) != null && Me2.universal && t && (this.client.core.addLinkModeSupportedApp(j7.metadata.redirect.universal), this.client.session.update(ee7, { transportType: F4.link_mode })), Ve2({ auths: ke3, session: pe5 });
      }, G5 = payloadId(), Z5 = payloadId();
      this.events.once(Ms2("session_connect"), ce4), this.events.once(Ms2("session_request", G5), Re4);
      let Se3;
      try {
        if (i3) {
          const O8 = formatJsonRpcRequest("wc_sessionAuthenticate", W3, G5);
          this.client.core.history.set(R6, O8);
          const T4 = await this.client.core.crypto.encode("", O8, { type: Sr4, encoding: Iu });
          Se3 = Zu(t, R6, T4);
        } else await Promise.all([this.sendRequest({ topic: R6, method: "wc_sessionAuthenticate", params: W3, expiry: e.expiry, throwOnFailedPublish: true, clientRpcId: G5 }), this.sendRequest({ topic: R6, method: "wc_sessionPropose", params: De2, expiry: v5.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: Z5 })]);
      } catch (O8) {
        throw this.events.off(Ms2("session_connect"), ce4), this.events.off(Ms2("session_request", G5), Re4), O8;
      }
      return await this.setProposal(Z5, I4({ id: Z5 }, De2)), await this.setAuthRequest(G5, { request: D3(I4({}, W3), { verifyContext: {} }), pairingTopic: R6, transportType: r3 }), { uri: Se3 ?? V6, response: wt4 };
    }, this.approveSessionAuthenticate = async (e) => {
      const { id: t, auths: s2 } = e, i3 = this.client.core.eventClient.createEvent({ properties: { topic: t.toString(), trace: [Ps3.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (y10) {
        throw i3.setError(Rs3.no_internet_connection), y10;
      }
      const r3 = this.getPendingAuthRequest(t);
      if (!r3) throw i3.setError(Rs3.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);
      const n4 = r3.transportType || F4.relay;
      n4 === F4.relay && await this.confirmOnlineStateOrThrow();
      const a5 = r3.requester.publicKey, c7 = await this.client.core.crypto.generateKeyPair(), h7 = Ru(a5), p5 = { type: pr3, receiverPublicKey: a5, senderPublicKey: c7 }, d5 = [], l7 = [];
      for (const y10 of s2) {
        if (!await mu({ cacao: y10, projectId: this.client.core.projectId })) {
          i3.setError(Rs3.invalid_cacao);
          const S7 = er3("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t, topic: h7, error: S7, encodeOpts: p5 }), new Error(S7.message);
        }
        i3.addTrace(Ps3.cacaos_verified);
        const { p: _5 } = y10, R6 = Vr3(_5.resources), V6 = [gu(_5.iss)], E6 = Vi3(_5.iss);
        if (R6) {
          const S7 = Eu(R6), M6 = Su(R6);
          d5.push(...S7), V6.push(...M6);
        }
        for (const S7 of V6) l7.push(`${S7}:${E6}`);
      }
      const w6 = await this.client.core.crypto.generateSharedKey(c7, a5);
      i3.addTrace(Ps3.create_authenticated_session_topic);
      let m2;
      if ((d5 == null ? void 0 : d5.length) > 0) {
        m2 = { topic: w6, acknowledged: true, self: { publicKey: c7, metadata: this.client.metadata }, peer: { publicKey: a5, metadata: r3.requester.metadata }, controller: a5, expiry: ws2(z7), authentication: s2, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r3.pairingTopic, namespaces: uh([...new Set(d5)], [...new Set(l7)]), transportType: n4 }, i3.addTrace(Ps3.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w6, { transportType: n4 });
        } catch (y10) {
          throw i3.setError(Rs3.subscribe_authenticated_session_topic_failure), y10;
        }
        i3.addTrace(Ps3.subscribe_authenticated_session_topic_success), await this.client.session.set(w6, m2), i3.addTrace(Ps3.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r3.pairingTopic, metadata: r3.requester.metadata });
      }
      i3.addTrace(Ps3.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: h7, id: t, result: { cacaos: s2, responder: { publicKey: c7, metadata: this.client.metadata } }, encodeOpts: p5, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r3.requester.metadata, n4) });
      } catch (y10) {
        throw i3.setError(Rs3.authenticated_session_approve_publish_failure), y10;
      }
      return await this.client.auth.requests.delete(t, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r3.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i3.eventId }), { session: m2 };
    }, this.rejectSessionAuthenticate = async (e) => {
      this.isInitialized();
      const { id: t, reason: s2 } = e, i3 = this.getPendingAuthRequest(t);
      if (!i3) throw new Error(`Could not find pending auth request with id ${t}`);
      i3.transportType === F4.relay && await this.confirmOnlineStateOrThrow();
      const r3 = i3.requester.publicKey, n4 = await this.client.core.crypto.generateKeyPair(), a5 = Ru(r3), c7 = { type: pr3, receiverPublicKey: r3, senderPublicKey: n4 };
      await this.sendError({ id: t, topic: a5, error: s2, encodeOpts: c7, rpcOpts: v5.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i3.requester.metadata, i3.transportType) }), await this.client.auth.requests.delete(t, { message: "rejected", code: 0 }), await this.client.proposal.delete(t, er3("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (e) => {
      this.isInitialized();
      const { request: t, iss: s2 } = e;
      return Wf(t, s2);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e = this.relayMessageCache.shift();
          e && await this.onRelayMessage(e);
        } catch (e) {
          this.client.logger.error(e);
        }
      }, 50);
    }, this.cleanupDuplicatePairings = async (e) => {
      if (e.pairingTopic) try {
        const t = this.client.core.pairing.pairings.get(e.pairingTopic), s2 = this.client.core.pairing.pairings.getAll().filter((i3) => {
          var r3, n4;
          return ((r3 = i3.peerMetadata) == null ? void 0 : r3.url) && ((n4 = i3.peerMetadata) == null ? void 0 : n4.url) === e.peer.metadata.url && i3.topic && i3.topic !== t.topic;
        });
        if (s2.length === 0) return;
        this.client.logger.info(`Cleaning up ${s2.length} duplicate pairing(s)`), await Promise.all(s2.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t) {
        this.client.logger.error(t);
      }
    }, this.deleteSession = async (e) => {
      var t;
      const { topic: s2, expirerHasDeleted: i3 = false, emitEvent: r3 = true, id: n4 = 0 } = e, { self: a5 } = this.client.session.get(s2);
      await this.client.core.relayer.unsubscribe(s2), await this.client.session.delete(s2, er3("USER_DISCONNECTED")), this.addToRecentlyDeleted(s2, "session"), this.client.core.crypto.keychain.has(a5.publicKey) && await this.client.core.crypto.deleteKeyPair(a5.publicKey), this.client.core.crypto.keychain.has(s2) && await this.client.core.crypto.deleteSymKey(s2), i3 || this.client.core.expirer.del(s2), this.client.core.storage.removeItem(xe2).catch((c7) => this.client.logger.warn(c7)), this.getPendingSessionRequests().forEach((c7) => {
        c7.topic === s2 && this.deletePendingSessionRequest(c7.id, er3("USER_DISCONNECTED"));
      }), s2 === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = x5.idle), r3 && this.client.events.emit("session_delete", { id: n4, topic: s2 });
    }, this.deleteProposal = async (e, t) => {
      if (t) try {
        const s2 = this.client.proposal.get(e), i3 = this.client.core.eventClient.getEvent({ topic: s2.pairingTopic });
        i3 == null ? void 0 : i3.setError(Ss3.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e, er3("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "proposal");
    }, this.deletePendingSessionRequest = async (e, t, s2 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e), s2 && (this.sessionRequestQueue.state = x5.idle, this.client.events.emit("session_request_expire", { id: e }));
    }, this.deletePendingAuthRequest = async (e, t, s2 = false) => {
      await Promise.all([this.client.auth.requests.delete(e, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }, this.setExpiry = async (e, t) => {
      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, { expiry: t }));
    }, this.setProposal = async (e, t) => {
      this.client.core.expirer.set(e, ws2(v5.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);
    }, this.setAuthRequest = async (e, t) => {
      const { request: s2, pairingTopic: i3, transportType: r3 = F4.relay } = t;
      this.client.core.expirer.set(e, s2.expiryTimestamp), await this.client.auth.requests.set(e, { authPayload: s2.authPayload, requester: s2.requester, expiryTimestamp: s2.expiryTimestamp, id: e, pairingTopic: i3, verifyContext: s2.verifyContext, transportType: r3 });
    }, this.setPendingSessionRequest = async (e) => {
      const { id: t, topic: s2, params: i3, verifyContext: r3 } = e, n4 = i3.request.expiryTimestamp || ws2(v5.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t, n4), await this.client.pendingRequest.set(t, { id: t, topic: s2, params: i3, verifyContext: r3 });
    }, this.sendRequest = async (e) => {
      const { topic: t, method: s2, params: i3, expiry: r3, relayRpcId: n4, clientRpcId: a5, throwOnFailedPublish: c7, appLink: h7 } = e, p5 = formatJsonRpcRequest(s2, i3, a5);
      let d5;
      const l7 = !!h7;
      try {
        const y10 = l7 ? Iu : tn3;
        d5 = await this.client.core.crypto.encode(t, p5, { encoding: y10 });
      } catch (y10) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), y10;
      }
      let w6;
      if (at3.includes(s2)) {
        const y10 = Ou(JSON.stringify(p5)), _5 = Ou(d5);
        w6 = await this.client.core.verify.register({ id: _5, decryptedId: y10 });
      }
      const m2 = v5[s2].req;
      if (m2.attestation = w6, r3 && (m2.ttl = r3), n4 && (m2.id = n4), this.client.core.history.set(t, p5), l7) {
        const y10 = Zu(h7, t, d5);
        await global.Linking.openURL(y10, this.client.name);
      } else {
        const y10 = v5[s2].req;
        r3 && (y10.ttl = r3), n4 && (y10.id = n4), c7 ? (y10.internal = D3(I4({}, y10.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, d5, y10)) : this.client.core.relayer.publish(t, d5, y10).catch((_5) => this.client.logger.error(_5));
      }
      return p5.id;
    }, this.sendResult = async (e) => {
      const { id: t, topic: s2, result: i3, throwOnFailedPublish: r3, encodeOpts: n4, appLink: a5 } = e, c7 = formatJsonRpcResult(t, i3);
      let h7;
      const p5 = a5 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l7 = p5 ? Iu : tn3;
        h7 = await this.client.core.crypto.encode(s2, c7, D3(I4({}, n4 || {}), { encoding: l7 }));
      } catch (l7) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s2} failed`), l7;
      }
      let d5;
      try {
        d5 = await this.client.core.history.get(s2, t);
      } catch (l7) {
        throw this.client.logger.error(`sendResult() -> history.get(${s2}, ${t}) failed`), l7;
      }
      if (p5) {
        const l7 = Zu(a5, s2, h7);
        await global.Linking.openURL(l7, this.client.name);
      } else {
        const l7 = v5[d5.request.method].res;
        r3 ? (l7.internal = D3(I4({}, l7.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s2, h7, l7)) : this.client.core.relayer.publish(s2, h7, l7).catch((w6) => this.client.logger.error(w6));
      }
      await this.client.core.history.resolve(c7);
    }, this.sendError = async (e) => {
      const { id: t, topic: s2, error: i3, encodeOpts: r3, rpcOpts: n4, appLink: a5 } = e, c7 = formatJsonRpcError(t, i3);
      let h7;
      const p5 = a5 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l7 = p5 ? Iu : tn3;
        h7 = await this.client.core.crypto.encode(s2, c7, D3(I4({}, r3 || {}), { encoding: l7 }));
      } catch (l7) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s2} failed`), l7;
      }
      let d5;
      try {
        d5 = await this.client.core.history.get(s2, t);
      } catch (l7) {
        throw this.client.logger.error(`sendError() -> history.get(${s2}, ${t}) failed`), l7;
      }
      if (p5) {
        const l7 = Zu(a5, s2, h7);
        await global.Linking.openURL(l7, this.client.name);
      } else {
        const l7 = n4 || v5[d5.request.method].res;
        this.client.core.relayer.publish(s2, h7, l7);
      }
      await this.client.core.history.resolve(c7);
    }, this.cleanup = async () => {
      const e = [], t = [];
      this.client.session.getAll().forEach((s2) => {
        let i3 = false;
        xs2(s2.expiry) && (i3 = true), this.client.core.crypto.keychain.has(s2.topic) || (i3 = true), i3 && e.push(s2.topic);
      }), this.client.proposal.getAll().forEach((s2) => {
        xs2(s2.expiryTimestamp) && t.push(s2.id);
      }), await Promise.all([...e.map((s2) => this.deleteSession({ topic: s2 })), ...t.map((s2) => this.deleteProposal(s2))]);
    }, this.onRelayEventRequest = async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === x5.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = x5.active;
        const e = this.requestQueue.queue.shift();
        if (e) try {
          await this.processRequest(e);
        } catch (t) {
          this.client.logger.warn(t);
        }
      }
      this.requestQueue.state = x5.idle;
    }, this.processRequest = async (e) => {
      const { topic: t, payload: s2, attestation: i3, transportType: r3, encryptedId: n4 } = e, a5 = s2.method;
      if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: a5 })) switch (a5) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t, s2);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t, s2);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t, s2);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t, s2);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t, s2);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4, transportType: r3 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t, s2);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4, transportType: r3 });
        default:
          return this.client.logger.info(`Unsupported request method ${a5}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: t, payload: s2, transportType: i3 } = e, r3 = (await this.client.core.history.get(t, s2.id)).request.method;
      switch (r3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t, s2, i3);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t, s2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t, s2);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t, s2);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t, s2);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t, s2);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t, s2);
        default:
          return this.client.logger.info(`Unsupported response method ${r3}`);
      }
    }, this.onRelayEventUnknownPayload = (e) => {
      const { topic: t } = e, { message: s2 } = xe("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s2);
    }, this.shouldIgnorePairingRequest = (e) => {
      const { topic: t, requestMethod: s2 } = e, i3 = this.expectedPairingMethodMap.get(t);
      return !i3 || i3.includes(s2) ? false : !!(i3.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (e) => {
      const { topic: t, payload: s2, attestation: i3, encryptedId: r3 } = e, { params: n4, id: a5 } = s2;
      try {
        const c7 = this.client.core.eventClient.getEvent({ topic: t });
        this.isValidConnect(I4({}, s2.params));
        const h7 = n4.expiryTimestamp || ws2(v5.wc_sessionPropose.req.ttl), p5 = I4({ id: a5, pairingTopic: t, expiryTimestamp: h7 }, n4);
        await this.setProposal(a5, p5);
        const d5 = await this.getVerifyContext({ attestationId: i3, hash: Ou(JSON.stringify(s2)), encryptedId: r3, metadata: p5.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), c7 == null ? void 0 : c7.setError(M5.proposal_listener_not_found)), c7 == null ? void 0 : c7.addTrace(z6.emit_session_proposal), this.client.events.emit("session_proposal", { id: a5, params: p5, verifyContext: d5 });
      } catch (c7) {
        await this.sendError({ id: a5, topic: t, error: c7, rpcOpts: v5.wc_sessionPropose.autoReject }), this.client.logger.error(c7);
      }
    }, this.onSessionProposeResponse = async (e, t, s2) => {
      const { id: i3 } = t;
      if (isJsonRpcResult(t)) {
        const { result: r3 } = t;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r3 });
        const n4 = this.client.proposal.get(i3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n4 });
        const a5 = n4.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a5 });
        const c7 = r3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: c7 });
        const h7 = await this.client.core.crypto.generateSharedKey(a5, c7);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: h7 });
        const p5 = await this.client.core.relayer.subscribe(h7, { transportType: s2 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p5 }), await this.client.core.pairing.activate({ topic: e });
      } else if (isJsonRpcError(t)) {
        await this.client.proposal.delete(i3, er3("USER_DISCONNECTED"));
        const r3 = Ms2("session_connect");
        if (this.events.listenerCount(r3) === 0) throw new Error(`emitting ${r3} without any listeners, 954`);
        this.events.emit(Ms2("session_connect"), { error: t.error });
      }
    }, this.onSessionSettleRequest = async (e, t) => {
      const { id: s2, params: i3 } = t;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: r3, controller: n4, expiry: a5, namespaces: c7, sessionProperties: h7, sessionConfig: p5 } = t.params, d5 = D3(I4(I4({ topic: e, relay: r3, expiry: a5, namespaces: c7, acknowledged: true, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: n4.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: n4.publicKey, metadata: n4.metadata } }, h7 && { sessionProperties: h7 }), p5 && { sessionConfig: p5 }), { transportType: F4.relay }), l7 = Ms2("session_connect");
        if (this.events.listenerCount(l7) === 0) throw new Error(`emitting ${l7} without any listeners 997`);
        this.events.emit(Ms2("session_connect"), { session: d5 }), await this.sendResult({ id: t.id, topic: e, result: true, throwOnFailedPublish: true });
      } catch (r3) {
        await this.sendError({ id: s2, topic: e, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionSettleResponse = async (e, t) => {
      const { id: s2 } = t;
      isJsonRpcResult(t) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(Ms2("session_approve", s2), {})) : isJsonRpcError(t) && (await this.client.session.delete(e, er3("USER_DISCONNECTED")), this.events.emit(Ms2("session_approve", s2), { error: t.error }));
    }, this.onSessionUpdateRequest = async (e, t) => {
      const { params: s2, id: i3 } = t;
      try {
        const r3 = `${e}_session_update`, n4 = Rh.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, i3)) {
          this.client.logger.info(`Discarding out of sync request - ${i3}`), this.sendError({ id: i3, topic: e, error: er3("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I4({ topic: e }, s2));
        try {
          Rh.set(r3, i3), await this.client.session.update(e, { namespaces: s2.namespaces }), await this.sendResult({ id: i3, topic: e, result: true, throwOnFailedPublish: true });
        } catch (a5) {
          throw Rh.delete(r3), a5;
        }
        this.client.events.emit("session_update", { id: i3, topic: e, params: s2 });
      } catch (r3) {
        await this.sendError({ id: i3, topic: e, error: r3 }), this.client.logger.error(r3);
      }
    }, this.isRequestOutOfSync = (e, t) => parseInt(t.toString().slice(0, -3)) <= parseInt(e.toString().slice(0, -3)), this.onSessionUpdateResponse = (e, t) => {
      const { id: s2 } = t, i3 = Ms2("session_update", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Ms2("session_update", s2), {}) : isJsonRpcError(t) && this.events.emit(Ms2("session_update", s2), { error: t.error });
    }, this.onSessionExtendRequest = async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, ws2(z7)), await this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s2, topic: e });
      } catch (i3) {
        await this.sendError({ id: s2, topic: e, error: i3 }), this.client.logger.error(i3);
      }
    }, this.onSessionExtendResponse = (e, t) => {
      const { id: s2 } = t, i3 = Ms2("session_extend", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Ms2("session_extend", s2), {}) : isJsonRpcError(t) && this.events.emit(Ms2("session_extend", s2), { error: t.error });
    }, this.onSessionPingRequest = async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s2, topic: e });
      } catch (i3) {
        await this.sendError({ id: s2, topic: e, error: i3 }), this.client.logger.error(i3);
      }
    }, this.onSessionPingResponse = (e, t) => {
      const { id: s2 } = t, i3 = Ms2("session_ping", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(t) ? this.events.emit(Ms2("session_ping", s2), {}) : isJsonRpcError(t) && this.events.emit(Ms2("session_ping", s2), { error: t.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidDisconnect({ topic: e, reason: t.params }), Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(w4.publish, async () => {
            i3(await this.deleteSession({ topic: e, id: s2 }));
          });
        }), this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e, error: er3("USER_DISCONNECTED") })]).catch((i3) => this.client.logger.error(i3));
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }, this.onSessionRequest = async (e) => {
      var t, s2, i3;
      const { topic: r3, payload: n4, attestation: a5, encryptedId: c7, transportType: h7 } = e, { id: p5, params: d5 } = n4;
      try {
        await this.isValidRequest(I4({ topic: r3 }, d5));
        const l7 = this.client.session.get(r3), w6 = await this.getVerifyContext({ attestationId: a5, hash: Ou(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", d5, p5))), encryptedId: c7, metadata: l7.peer.metadata, transportType: h7 }), m2 = { id: p5, topic: r3, params: d5, verifyContext: w6 };
        await this.setPendingSessionRequest(m2), h7 === F4.link_mode && (t = l7.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s2 = l7.peer.metadata.redirect) == null ? void 0 : s2.universal), (i3 = this.client.signConfig) != null && i3.disableRequestQueue ? this.emitSessionRequest(m2) : (this.addSessionRequestToSessionRequestQueue(m2), this.processSessionRequestQueue());
      } catch (l7) {
        await this.sendError({ id: p5, topic: r3, error: l7 }), this.client.logger.error(l7);
      }
    }, this.onSessionRequestResponse = (e, t) => {
      const { id: s2 } = t, i3 = Ms2("session_request", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Ms2("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(Ms2("session_request", s2), { error: t.error });
    }, this.onSessionEventRequest = async (e, t) => {
      const { id: s2, params: i3 } = t;
      try {
        const r3 = `${e}_session_event_${i3.event.name}`, n4 = Rh.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, s2)) {
          this.client.logger.info(`Discarding out of sync request - ${s2}`);
          return;
        }
        this.isValidEmit(I4({ topic: e }, i3)), this.client.events.emit("session_event", { id: s2, topic: e, params: i3 }), Rh.set(r3, s2);
      } catch (r3) {
        await this.sendError({ id: s2, topic: e, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionAuthenticateResponse = (e, t) => {
      const { id: s2 } = t;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e, payload: t }), isJsonRpcResult(t) ? this.events.emit(Ms2("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(Ms2("session_request", s2), { error: t.error });
    }, this.onSessionAuthenticateRequest = async (e) => {
      var t;
      const { topic: s2, payload: i3, attestation: r3, encryptedId: n4, transportType: a5 } = e;
      try {
        const { requester: c7, authPayload: h7, expiryTimestamp: p5 } = i3.params, d5 = await this.getVerifyContext({ attestationId: r3, hash: Ou(JSON.stringify(i3)), encryptedId: n4, metadata: c7.metadata, transportType: a5 }), l7 = { requester: c7, pairingTopic: s2, id: i3.id, authPayload: h7, verifyContext: d5, expiryTimestamp: p5 };
        await this.setAuthRequest(i3.id, { request: l7, pairingTopic: s2, transportType: a5 }), a5 === F4.link_mode && (t = c7.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(c7.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s2, params: i3.params, id: i3.id, verifyContext: d5 });
      } catch (c7) {
        this.client.logger.error(c7);
        const h7 = i3.params.requester.publicKey, p5 = await this.client.core.crypto.generateKeyPair(), d5 = this.getAppLinkIfEnabled(i3.params.requester.metadata, a5), l7 = { type: pr3, receiverPublicKey: h7, senderPublicKey: p5 };
        await this.sendError({ id: i3.id, topic: s2, error: c7, encodeOpts: l7, rpcOpts: v5.wc_sessionAuthenticate.autoReject, appLink: d5 });
      }
    }, this.addSessionRequestToSessionRequestQueue = (e) => {
      this.sessionRequestQueue.queue.push(e);
    }, this.cleanupAfterResponse = (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = x5.idle, this.processSessionRequestQueue();
      }, (0, import_time8.toMiliseconds)(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: e, error: t }) => {
      const s2 = this.client.core.history.pending;
      s2.length > 0 && s2.filter((i3) => i3.topic === e && i3.request.method === "wc_sessionRequest").forEach((i3) => {
        const r3 = i3.request.id, n4 = Ms2("session_request", r3);
        if (this.events.listenerCount(n4) === 0) throw new Error(`emitting ${n4} without any listeners`);
        this.events.emit(Ms2("session_request", i3.request.id), { error: t });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === x5.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = x5.active, this.emitSessionRequest(e);
      } catch (t) {
        this.client.logger.error(t);
      }
    }, this.emitSessionRequest = (e) => {
      this.client.events.emit("session_request", e);
    }, this.onPairingCreated = (e) => {
      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;
      const t = this.client.proposal.getAll().find((s2) => s2.pairingTopic === e.topic);
      t && this.onSessionProposeRequest({ topic: e.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: t.requiredNamespaces, optionalNamespaces: t.optionalNamespaces, relays: t.relays, proposer: t.proposer, sessionProperties: t.sessionProperties }, t.id) });
    }, this.isValidConnect = async (e) => {
      if (!Ah(e)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(a5);
      }
      const { pairingTopic: t, requiredNamespaces: s2, optionalNamespaces: i3, sessionProperties: r3, relays: n4 } = e;
      if (Pe3(t) || await this.isValidPairingTopic(t), !gh(n4, true)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `connect() relays: ${n4}`);
        throw new Error(a5);
      }
      !Pe3(s2) && Xr3(s2) !== 0 && this.validateNamespaces(s2, "requiredNamespaces"), !Pe3(i3) && Xr3(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), Pe3(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.validateNamespaces = (e, t) => {
      const s2 = vh(e, "connect()", t);
      if (s2) throw new Error(s2.message);
    }, this.isValidApprove = async (e) => {
      if (!Ah(e)) throw new Error(xe("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: t, namespaces: s2, relayProtocol: i3, sessionProperties: r3 } = e;
      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
      const n4 = this.client.proposal.get(t), a5 = Oo2(s2, "approve()");
      if (a5) throw new Error(a5.message);
      const c7 = To3(n4.requiredNamespaces, s2, "approve()");
      if (c7) throw new Error(c7.message);
      if (!Yt4(i3, true)) {
        const { message: h7 } = xe("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(h7);
      }
      Pe3(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.isValidReject = async (e) => {
      if (!Ah(e)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i3);
      }
      const { id: t, reason: s2 } = e;
      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !bh(s2)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s2)}`);
        throw new Error(i3);
      }
    }, this.isValidSessionSettleRequest = (e) => {
      if (!Ah(e)) {
        const { message: c7 } = xe("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(c7);
      }
      const { relay: t, controller: s2, namespaces: i3, expiry: r3 } = e;
      if (!Po4(t)) {
        const { message: c7 } = xe("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c7);
      }
      const n4 = ph(s2, "onSessionSettleRequest()");
      if (n4) throw new Error(n4.message);
      const a5 = Oo2(i3, "onSessionSettleRequest()");
      if (a5) throw new Error(a5.message);
      if (xs2(r3)) {
        const { message: c7 } = xe("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c7);
      }
    }, this.isValidUpdate = async (e) => {
      if (!Ah(e)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a5);
      }
      const { topic: t, namespaces: s2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const i3 = this.client.session.get(t), r3 = Oo2(s2, "update()");
      if (r3) throw new Error(r3.message);
      const n4 = To3(i3.requiredNamespaces, s2, "update()");
      if (n4) throw new Error(n4.message);
    }, this.isValidExtend = async (e) => {
      if (!Ah(e)) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
    }, this.isValidRequest = async (e) => {
      if (!Ah(e)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a5);
      }
      const { topic: t, request: s2, chainId: i3, expiry: r3 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const { namespaces: n4 } = this.client.session.get(t);
      if (!Mh(n4, i3)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a5);
      }
      if (!yh(s2)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `request() ${JSON.stringify(s2)}`);
        throw new Error(a5);
      }
      if (!Eh(n4, i3, s2.method)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `request() method: ${s2.method}`);
        throw new Error(a5);
      }
      if (r3 && !_h(r3, me4)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `request() expiry: ${r3}. Expiry must be a number (in seconds) between ${me4.min} and ${me4.max}`);
        throw new Error(a5);
      }
    }, this.isValidRespond = async (e) => {
      var t;
      if (!Ah(e)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(r3);
      }
      const { topic: s2, response: i3 } = e;
      try {
        await this.isValidSessionTopic(s2);
      } catch (r3) {
        throw (t = e == null ? void 0 : e.response) != null && t.id && this.cleanupAfterResponse(e), r3;
      }
      if (!wh(i3)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i3)}`);
        throw new Error(r3);
      }
    }, this.isValidPing = async (e) => {
      if (!Ah(e)) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidEmit = async (e) => {
      if (!Ah(e)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(n4);
      }
      const { topic: t, event: s2, chainId: i3 } = e;
      await this.isValidSessionTopic(t);
      const { namespaces: r3 } = this.client.session.get(t);
      if (!Mh(r3, i3)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(n4);
      }
      if (!xh(s2)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
      if (!Sh(r3, i3, s2.name)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
    }, this.isValidDisconnect = async (e) => {
      if (!Ah(e)) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidAuthenticate = (e) => {
      const { chains: t, uri: s2, domain: i3, nonce: r3 } = e;
      if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!Yt4(s2, false)) throw new Error("uri is required parameter");
      if (!Yt4(i3, false)) throw new Error("domain is required parameter");
      if (!Yt4(r3, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t.map((a5) => An2(a5).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n4 } = An2(t[0]);
      if (n4 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (e) => {
      const { attestationId: t, hash: s2, encryptedId: i3, metadata: r3, transportType: n4 } = e, a5 = { verified: { verifyUrl: r3.verifyUrl || Z3, validation: "UNKNOWN", origin: r3.url || "" } };
      try {
        if (n4 === F4.link_mode) {
          const h7 = this.getAppLinkIfEnabled(r3, n4);
          return a5.verified.validation = h7 && new URL(h7).origin === new URL(r3.url).origin ? "VALID" : "INVALID", a5;
        }
        const c7 = await this.client.core.verify.resolve({ attestationId: t, hash: s2, encryptedId: i3, verifyUrl: r3.verifyUrl });
        c7 && (a5.verified.origin = c7.origin, a5.verified.isScam = c7.isScam, a5.verified.validation = c7.origin === new URL(r3.url).origin ? "VALID" : "INVALID");
      } catch (c7) {
        this.client.logger.warn(c7);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a5)}`), a5;
    }, this.validateSessionProps = (e, t) => {
      Object.values(e).forEach((s2) => {
        if (!Yt4(s2, false)) {
          const { message: i3 } = xe("MISSING_OR_INVALID", `${t} must be in Record<string, string> format. Received: ${JSON.stringify(s2)}`);
          throw new Error(i3);
        }
      });
    }, this.getPendingAuthRequest = (e) => {
      const t = this.client.auth.requests.get(e);
      return typeof t == "object" ? t : void 0;
    }, this.addToRecentlyDeleted = (e, t) => {
      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s2 = 0;
        const i3 = this.recentlyDeletedLimit / 2;
        for (const r3 of this.recentlyDeletedMap.keys()) {
          if (s2++ >= i3) break;
          this.recentlyDeletedMap.delete(r3);
        }
      }
    }, this.checkRecentlyDeleted = (e) => {
      const t = this.recentlyDeletedMap.get(e);
      if (t) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e}`);
        throw new Error(s2);
      }
    }, this.isLinkModeEnabled = (e, t) => {
      var s2, i3, r3, n4, a5, c7, h7, p5, d5;
      return !e || t !== F4.link_mode ? false : ((i3 = (s2 = this.client.metadata) == null ? void 0 : s2.redirect) == null ? void 0 : i3.linkMode) === true && ((n4 = (r3 = this.client.metadata) == null ? void 0 : r3.redirect) == null ? void 0 : n4.universal) !== void 0 && ((c7 = (a5 = this.client.metadata) == null ? void 0 : a5.redirect) == null ? void 0 : c7.universal) !== "" && ((h7 = e == null ? void 0 : e.redirect) == null ? void 0 : h7.universal) !== void 0 && ((p5 = e == null ? void 0 : e.redirect) == null ? void 0 : p5.universal) !== "" && ((d5 = e == null ? void 0 : e.redirect) == null ? void 0 : d5.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (e, t) => {
      var s2;
      return this.isLinkModeEnabled(e, t) ? (s2 = e == null ? void 0 : e.redirect) == null ? void 0 : s2.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: e }) => {
      if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
      const t = Is2(e, "topic") || "", s2 = decodeURIComponent(Is2(e, "wc_ev") || ""), i3 = this.client.session.keys.includes(t);
      i3 && this.client.session.update(t, { transportType: F4.link_mode }), this.client.core.dispatchEnvelope({ topic: t, message: s2, sessionExists: i3 });
    }, this.registerLinkModeListeners = async () => {
      var e;
      if (_s2() || rr4() && (e = this.client.metadata.redirect) != null && e.linkMode) {
        const t = global == null ? void 0 : global.Linking;
        if (typeof t < "u") {
          t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s2 = await t.getInitialURL();
          s2 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s2 });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o4 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(o4);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(w4.message, (o4) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(o4) : this.onRelayMessage(o4);
    });
  }
  async onRelayMessage(o4) {
    const { topic: e, message: t, attestation: s2, transportType: i3 } = o4, { publicKey: r3 } = this.client.auth.authKeys.keys.includes(ae4) ? this.client.auth.authKeys.get(ae4) : { responseTopic: void 0, publicKey: void 0 }, n4 = await this.client.core.crypto.decode(e, t, { receiverPublicKey: r3, encoding: i3 === F4.link_mode ? Iu : tn3 });
    try {
      isJsonRpcRequest(n4) ? (this.client.core.history.set(e, n4), this.onRelayEventRequest({ topic: e, payload: n4, attestation: s2, transportType: i3, encryptedId: Ou(t) })) : isJsonRpcResponse(n4) ? (await this.client.core.history.resolve(n4), await this.onRelayEventResponse({ topic: e, payload: n4, transportType: i3 }), this.client.core.history.delete(e, n4.id)) : this.onRelayEventUnknownPayload({ topic: e, payload: n4, transportType: i3 });
    } catch (a5) {
      this.client.logger.error(a5);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(R4.expired, async (o4) => {
      const { topic: e, id: t } = ys2(o4.target);
      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, xe("EXPIRED"), true);
      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, xe("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession({ topic: e, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e })) : t && (await this.deleteProposal(t, true), this.client.events.emit("proposal_expire", { id: t }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(q2.create, (o4) => this.onPairingCreated(o4)), this.client.core.pairing.events.on(q2.delete, (o4) => {
      this.addToRecentlyDeleted(o4.topic, "pairing");
    });
  }
  isValidPairingTopic(o4) {
    if (!Yt4(o4, false)) {
      const { message: e } = xe("MISSING_OR_INVALID", `pairing topic should be a string: ${o4}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o4)) {
      const { message: e } = xe("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o4}`);
      throw new Error(e);
    }
    if (xs2(this.client.core.pairing.pairings.get(o4).expiry)) {
      const { message: e } = xe("EXPIRED", `pairing topic: ${o4}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(o4) {
    if (!Yt4(o4, false)) {
      const { message: e } = xe("MISSING_OR_INVALID", `session topic should be a string: ${o4}`);
      throw new Error(e);
    }
    if (this.checkRecentlyDeleted(o4), !this.client.session.keys.includes(o4)) {
      const { message: e } = xe("NO_MATCHING_KEY", `session topic doesn't exist: ${o4}`);
      throw new Error(e);
    }
    if (xs2(this.client.session.get(o4).expiry)) {
      await this.deleteSession({ topic: o4 });
      const { message: e } = xe("EXPIRED", `session topic: ${o4}`);
      throw new Error(e);
    }
    if (!this.client.core.crypto.keychain.has(o4)) {
      const { message: e } = xe("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o4}`);
      throw await this.deleteSession({ topic: o4 }), new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(o4) {
    if (this.checkRecentlyDeleted(o4), this.client.session.keys.includes(o4)) await this.isValidSessionTopic(o4);
    else if (this.client.core.pairing.pairings.keys.includes(o4)) this.isValidPairingTopic(o4);
    else if (Yt4(o4, false)) {
      const { message: e } = xe("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o4}`);
      throw new Error(e);
    } else {
      const { message: e } = xe("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o4}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(o4) {
    if (!mh(o4)) {
      const { message: e } = xe("MISSING_OR_INVALID", `proposal id should be a number: ${o4}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(o4)) {
      const { message: e } = xe("NO_MATCHING_KEY", `proposal id doesn't exist: ${o4}`);
      throw new Error(e);
    }
    if (xs2(this.client.proposal.get(o4).expiryTimestamp)) {
      await this.deleteProposal(o4);
      const { message: e } = xe("EXPIRED", `proposal id: ${o4}`);
      throw new Error(e);
    }
  }
};
var Ss4 = class extends ai2 {
  constructor(o4, e) {
    super(o4, e, st4, ye5), this.core = o4, this.logger = e;
  }
};
var yt3 = class extends ai2 {
  constructor(o4, e) {
    super(o4, e, rt3, ye5), this.core = o4, this.logger = e;
  }
};
var Is4 = class extends ai2 {
  constructor(o4, e) {
    super(o4, e, ot4, ye5, (t) => t.id), this.core = o4, this.logger = e;
  }
};
var fs2 = class extends ai2 {
  constructor(o4, e) {
    super(o4, e, pt4, oe4, () => ae4), this.core = o4, this.logger = e;
  }
};
var vs2 = class extends ai2 {
  constructor(o4, e) {
    super(o4, e, ht4, oe4), this.core = o4, this.logger = e;
  }
};
var qs4 = class extends ai2 {
  constructor(o4, e) {
    super(o4, e, dt4, oe4, (t) => t.id), this.core = o4, this.logger = e;
  }
};
var Ts3 = class {
  constructor(o4, e) {
    this.core = o4, this.logger = e, this.authKeys = new fs2(this.core, this.logger), this.pairingTopics = new vs2(this.core, this.logger), this.requests = new qs4(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var _e5 = class __e extends S4 {
  constructor(o4) {
    super(o4), this.protocol = be6, this.version = Ce6, this.name = we5.name, this.events = new import_events13.EventEmitter(), this.on = (t, s2) => this.events.on(t, s2), this.once = (t, s2) => this.events.once(t, s2), this.off = (t, s2) => this.events.off(t, s2), this.removeListener = (t, s2) => this.events.removeListener(t, s2), this.removeAllListeners = (t) => this.events.removeAllListeners(t), this.connect = async (t) => {
      try {
        return await this.engine.connect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approve = async (t) => {
      try {
        return await this.engine.approve(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.reject = async (t) => {
      try {
        return await this.engine.reject(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.update = async (t) => {
      try {
        return await this.engine.update(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.extend = async (t) => {
      try {
        return await this.engine.extend(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.request = async (t) => {
      try {
        return await this.engine.request(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.respond = async (t) => {
      try {
        return await this.engine.respond(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.ping = async (t) => {
      try {
        return await this.engine.ping(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.emit = async (t) => {
      try {
        return await this.engine.emit(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.disconnect = async (t) => {
      try {
        return await this.engine.disconnect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.find = (t) => {
      try {
        return this.engine.find(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.authenticate = async (t, s2) => {
      try {
        return await this.engine.authenticate(t, s2);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approveSessionAuthenticate = async (t) => {
      try {
        return await this.engine.approveSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.rejectSessionAuthenticate = async (t) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.name = (o4 == null ? void 0 : o4.name) || we5.name, this.metadata = (o4 == null ? void 0 : o4.metadata) || fs(), this.signConfig = o4 == null ? void 0 : o4.signConfig;
    const e = typeof (o4 == null ? void 0 : o4.logger) < "u" && typeof (o4 == null ? void 0 : o4.logger) != "string" ? o4.logger : (0, import_pino.default)(k({ level: (o4 == null ? void 0 : o4.logger) || we5.logger }));
    this.core = (o4 == null ? void 0 : o4.core) || new On4(o4), this.logger = E(e, this.name), this.session = new yt3(this.core, this.logger), this.proposal = new Ss4(this.core, this.logger), this.pendingRequest = new Is4(this.core, this.logger), this.engine = new Rs4(this), this.auth = new Ts3(this.core, this.logger);
  }
  static async init(o4) {
    const e = new __e(o4);
    return await e.initialize(), e;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (o4) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o4.message), o4;
    }
  }
};
var Ns4 = yt3;
var Ps4 = _e5;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
var l6 = { exports: {} };
var c6 = typeof Reflect == "object" ? Reflect : null;
var y9 = c6 && typeof c6.apply == "function" ? c6.apply : function(t, e, n4) {
  return Function.prototype.apply.call(t, e, n4);
};
var f5;
c6 && typeof c6.ownKeys == "function" ? f5 = c6.ownKeys : Object.getOwnPropertySymbols ? f5 = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : f5 = function(t) {
  return Object.getOwnPropertyNames(t);
};
function k5(s2) {
  console && console.warn && console.warn(s2);
}
var w5 = Number.isNaN || function(t) {
  return t !== t;
};
function o3() {
  o3.init.call(this);
}
l6.exports = o3, l6.exports.once = K7, o3.EventEmitter = o3, o3.prototype._events = void 0, o3.prototype._eventsCount = 0, o3.prototype._maxListeners = void 0;
var L3 = 10;
function g3(s2) {
  if (typeof s2 != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s2);
}
Object.defineProperty(o3, "defaultMaxListeners", { enumerable: true, get: function() {
  return L3;
}, set: function(s2) {
  if (typeof s2 != "number" || s2 < 0 || w5(s2)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s2 + ".");
  L3 = s2;
} }), o3.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o3.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || w5(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function _4(s2) {
  return s2._maxListeners === void 0 ? o3.defaultMaxListeners : s2._maxListeners;
}
o3.prototype.getMaxListeners = function() {
  return _4(this);
}, o3.prototype.emit = function(t) {
  for (var e = [], n4 = 1; n4 < arguments.length; n4++) e.push(arguments[n4]);
  var i3 = t === "error", a5 = this._events;
  if (a5 !== void 0) i3 = i3 && a5.error === void 0;
  else if (!i3) return false;
  if (i3) {
    var r3;
    if (e.length > 0 && (r3 = e[0]), r3 instanceof Error) throw r3;
    var h7 = new Error("Unhandled error." + (r3 ? " (" + r3.message + ")" : ""));
    throw h7.context = r3, h7;
  }
  var u4 = a5[t];
  if (u4 === void 0) return false;
  if (typeof u4 == "function") y9(u4, this, e);
  else for (var d5 = u4.length, M6 = O7(u4, d5), n4 = 0; n4 < d5; ++n4) y9(M6[n4], this, e);
  return true;
};
function S6(s2, t, e, n4) {
  var i3, a5, r3;
  if (g3(e), a5 = s2._events, a5 === void 0 ? (a5 = s2._events = /* @__PURE__ */ Object.create(null), s2._eventsCount = 0) : (a5.newListener !== void 0 && (s2.emit("newListener", t, e.listener ? e.listener : e), a5 = s2._events), r3 = a5[t]), r3 === void 0) r3 = a5[t] = e, ++s2._eventsCount;
  else if (typeof r3 == "function" ? r3 = a5[t] = n4 ? [e, r3] : [r3, e] : n4 ? r3.unshift(e) : r3.push(e), i3 = _4(s2), i3 > 0 && r3.length > i3 && !r3.warned) {
    r3.warned = true;
    var h7 = new Error("Possible EventEmitter memory leak detected. " + r3.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    h7.name = "MaxListenersExceededWarning", h7.emitter = s2, h7.type = t, h7.count = r3.length, k5(h7);
  }
  return s2;
}
o3.prototype.addListener = function(t, e) {
  return S6(this, t, e, false);
}, o3.prototype.on = o3.prototype.addListener, o3.prototype.prependListener = function(t, e) {
  return S6(this, t, e, true);
};
function D4() {
  if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function C4(s2, t, e) {
  var n4 = { fired: false, wrapFn: void 0, target: s2, type: t, listener: e }, i3 = D4.bind(n4);
  return i3.listener = e, n4.wrapFn = i3, i3;
}
o3.prototype.once = function(t, e) {
  return g3(e), this.on(t, C4(this, t, e)), this;
}, o3.prototype.prependOnceListener = function(t, e) {
  return g3(e), this.prependListener(t, C4(this, t, e)), this;
}, o3.prototype.removeListener = function(t, e) {
  var n4, i3, a5, r3, h7;
  if (g3(e), i3 = this._events, i3 === void 0) return this;
  if (n4 = i3[t], n4 === void 0) return this;
  if (n4 === e || n4.listener === e) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i3[t], i3.removeListener && this.emit("removeListener", t, n4.listener || e));
  else if (typeof n4 != "function") {
    for (a5 = -1, r3 = n4.length - 1; r3 >= 0; r3--) if (n4[r3] === e || n4[r3].listener === e) {
      h7 = n4[r3].listener, a5 = r3;
      break;
    }
    if (a5 < 0) return this;
    a5 === 0 ? n4.shift() : F5(n4, a5), n4.length === 1 && (i3[t] = n4[0]), i3.removeListener !== void 0 && this.emit("removeListener", t, h7 || e);
  }
  return this;
}, o3.prototype.off = o3.prototype.removeListener, o3.prototype.removeAllListeners = function(t) {
  var e, n4, i3;
  if (n4 = this._events, n4 === void 0) return this;
  if (n4.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n4[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n4[t]), this;
  if (arguments.length === 0) {
    var a5 = Object.keys(n4), r3;
    for (i3 = 0; i3 < a5.length; ++i3) r3 = a5[i3], r3 !== "removeListener" && this.removeAllListeners(r3);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = n4[t], typeof e == "function") this.removeListener(t, e);
  else if (e !== void 0) for (i3 = e.length - 1; i3 >= 0; i3--) this.removeListener(t, e[i3]);
  return this;
};
function b5(s2, t, e) {
  var n4 = s2._events;
  if (n4 === void 0) return [];
  var i3 = n4[t];
  return i3 === void 0 ? [] : typeof i3 == "function" ? e ? [i3.listener || i3] : [i3] : e ? z8(i3) : O7(i3, i3.length);
}
o3.prototype.listeners = function(t) {
  return b5(this, t, true);
}, o3.prototype.rawListeners = function(t) {
  return b5(this, t, false);
}, o3.listenerCount = function(s2, t) {
  return typeof s2.listenerCount == "function" ? s2.listenerCount(t) : E5.call(s2, t);
}, o3.prototype.listenerCount = E5;
function E5(s2) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[s2];
    if (typeof e == "function") return 1;
    if (e !== void 0) return e.length;
  }
  return 0;
}
o3.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f5(this._events) : [];
};
function O7(s2, t) {
  for (var e = new Array(t), n4 = 0; n4 < t; ++n4) e[n4] = s2[n4];
  return e;
}
function F5(s2, t) {
  for (; t + 1 < s2.length; t++) s2[t] = s2[t + 1];
  s2.pop();
}
function z8(s2) {
  for (var t = new Array(s2.length), e = 0; e < t.length; ++e) t[e] = s2[e].listener || s2[e];
  return t;
}
function K7(s2, t) {
  return new Promise(function(e, n4) {
    function i3(r3) {
      s2.removeListener(t, a5), n4(r3);
    }
    function a5() {
      typeof s2.removeListener == "function" && s2.removeListener("error", i3), e([].slice.call(arguments));
    }
    R5(s2, t, a5, { once: true }), t !== "error" && U4(s2, i3, { once: true });
  });
}
function U4(s2, t, e) {
  typeof s2.on == "function" && R5(s2, "error", t, e);
}
function R5(s2, t, e, n4) {
  if (typeof s2.on == "function") n4.once ? s2.once(t, e) : s2.on(t, e);
  else if (typeof s2.addEventListener == "function") s2.addEventListener(t, function i3(a5) {
    n4.once && s2.removeEventListener(t, i3), e(a5);
  });
  else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s2);
}
var A4 = "wc";
var p4 = "Web3Wallet";
var $4 = `${A4}@2:${p4}:`;
var Q5 = class extends l6.exports {
  constructor() {
    super();
  }
};
var x6 = class {
  constructor(t) {
    this.opts = t;
  }
};
var P4 = class {
  constructor(t) {
    this.client = t;
  }
};
var V5 = Object.defineProperty;
var B4 = Object.defineProperties;
var J = Object.getOwnPropertyDescriptors;
var q3 = Object.getOwnPropertySymbols;
var Y5 = Object.prototype.hasOwnProperty;
var Z4 = Object.prototype.propertyIsEnumerable;
var j6 = (s2, t, e) => t in s2 ? V5(s2, t, { enumerable: true, configurable: true, writable: true, value: e }) : s2[t] = e;
var ee6 = (s2, t) => {
  for (var e in t || (t = {})) Y5.call(t, e) && j6(s2, e, t[e]);
  if (q3) for (var e of q3(t)) Z4.call(t, e) && j6(s2, e, t[e]);
  return s2;
};
var te6 = (s2, t) => B4(s2, J(t));
var se5 = class extends P4 {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await Ps4.init({ core: this.client.core, metadata: this.client.metadata, signConfig: this.client.signConfig }), this.authClient = await zr3.init({ core: this.client.core, projectId: "", metadata: this.client.metadata });
    }, this.pair = async (e) => {
      await this.client.core.pairing.pair(e);
    }, this.approveSession = async (e) => {
      const { topic: n4, acknowledged: i3 } = await this.signClient.approve(te6(ee6({}, e), { id: e.id, namespaces: e.namespaces, sessionProperties: e.sessionProperties, sessionConfig: e.sessionConfig }));
      return await i3(), this.signClient.session.get(n4);
    }, this.rejectSession = async (e) => await this.signClient.reject(e), this.updateSession = async (e) => await this.signClient.update(e), this.extendSession = async (e) => await this.signClient.extend(e), this.respondSessionRequest = async (e) => await this.signClient.respond(e), this.disconnectSession = async (e) => await this.signClient.disconnect(e), this.emitSessionEvent = async (e) => await this.signClient.emit(e), this.getActiveSessions = () => this.signClient.session.getAll().reduce((e, n4) => (e[n4.topic] = n4, e), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (e, n4) => await this.authClient.respond(e, n4), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((e) => "requester" in e), this.formatMessage = (e, n4) => this.authClient.formatMessage(e, n4), this.approveSessionAuthenticate = async (e) => await this.signClient.approveSessionAuthenticate(e), this.rejectSessionAuthenticate = async (e) => await this.signClient.rejectSessionAuthenticate(e), this.formatAuthMessage = (e) => this.signClient.formatAuthMessage(e), this.registerDeviceToken = (e) => this.client.core.echoClient.registerDeviceToken(e), this.on = (e, n4) => (this.setEvent(e, "off"), this.setEvent(e, "on"), this.client.events.on(e, n4)), this.once = (e, n4) => (this.setEvent(e, "off"), this.setEvent(e, "once"), this.client.events.once(e, n4)), this.off = (e, n4) => (this.setEvent(e, "off"), this.client.events.off(e, n4)), this.removeListener = (e, n4) => (this.setEvent(e, "removeListener"), this.client.events.removeListener(e, n4)), this.onSessionRequest = (e) => {
      this.client.events.emit("session_request", e);
    }, this.onSessionProposal = (e) => {
      this.client.events.emit("session_proposal", e);
    }, this.onSessionDelete = (e) => {
      this.client.events.emit("session_delete", e);
    }, this.onAuthRequest = (e) => {
      this.client.events.emit("auth_request", e);
    }, this.onProposalExpire = (e) => {
      this.client.events.emit("proposal_expire", e);
    }, this.onSessionRequestExpire = (e) => {
      this.client.events.emit("session_request_expire", e);
    }, this.onSessionRequestAuthenticate = (e) => {
      this.client.events.emit("session_authenticate", e);
    }, this.setEvent = (e, n4) => {
      switch (e) {
        case "session_request":
          this.signClient.events[n4]("session_request", this.onSessionRequest);
          break;
        case "session_proposal":
          this.signClient.events[n4]("session_proposal", this.onSessionProposal);
          break;
        case "session_delete":
          this.signClient.events[n4]("session_delete", this.onSessionDelete);
          break;
        case "auth_request":
          this.authClient[n4]("auth_request", this.onAuthRequest);
          break;
        case "proposal_expire":
          this.signClient.events[n4]("proposal_expire", this.onProposalExpire);
          break;
        case "session_request_expire":
          this.signClient.events[n4]("session_request_expire", this.onSessionRequestExpire);
          break;
        case "session_authenticate":
          this.signClient.events[n4]("session_authenticate", this.onSessionRequestAuthenticate);
          break;
      }
    }, this.signClient = {}, this.authClient = {};
  }
};
var ne5 = { decryptMessage: async (s2) => {
  const t = { core: new On4({ storageOptions: s2.storageOptions, storage: s2.storage }) };
  await t.core.crypto.init();
  const e = t.core.crypto.decode(s2.topic, s2.encryptedMessage);
  return t.core = null, e;
}, getMetadata: async (s2) => {
  const t = { core: new On4({ storageOptions: s2.storageOptions, storage: s2.storage }), sessionStore: null };
  t.sessionStore = new Ns4(t.core, t.core.logger), await t.sessionStore.init();
  const e = t.sessionStore.get(s2.topic), n4 = e == null ? void 0 : e.peer.metadata;
  return t.core = null, t.sessionStore = null, n4;
} };
var T3 = class extends x6 {
  constructor(s2) {
    super(s2), this.events = new l6.exports(), this.on = (t, e) => this.engine.on(t, e), this.once = (t, e) => this.engine.once(t, e), this.off = (t, e) => this.engine.off(t, e), this.removeListener = (t, e) => this.engine.removeListener(t, e), this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.approveSession = async (t) => {
      try {
        return await this.engine.approveSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.rejectSession = async (t) => {
      try {
        return await this.engine.rejectSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.updateSession = async (t) => {
      try {
        return await this.engine.updateSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.extendSession = async (t) => {
      try {
        return await this.engine.extendSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.respondSessionRequest = async (t) => {
      try {
        return await this.engine.respondSessionRequest(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.disconnectSession = async (t) => {
      try {
        return await this.engine.disconnectSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.emitSessionEvent = async (t) => {
      try {
        return await this.engine.emitSessionEvent(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respondAuthRequest = async (t, e) => {
      try {
        return await this.engine.respondAuthRequest(t, e);
      } catch (n4) {
        throw this.logger.error(n4.message), n4;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.formatMessage = (t, e) => {
      try {
        return this.engine.formatMessage(t, e);
      } catch (n4) {
        throw this.logger.error(n4.message), n4;
      }
    }, this.registerDeviceToken = (t) => {
      try {
        return this.engine.registerDeviceToken(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.approveSessionAuthenticate = (t) => {
      try {
        return this.engine.approveSessionAuthenticate(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.rejectSessionAuthenticate = (t) => {
      try {
        return this.engine.rejectSessionAuthenticate(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.metadata = s2.metadata, this.name = s2.name || p4, this.signConfig = s2.signConfig, this.core = s2.core, this.logger = this.core.logger, this.engine = new se5(this);
  }
  static async init(s2) {
    const t = new T3(s2);
    return await t.initialize(), t;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (s2) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(s2.message), s2;
    }
  }
};
var v6 = T3;
v6.notifications = ne5;
var ie4 = v6;

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_lib3();
init_eventemitter3();

// node_modules/@thirdweb-dev/wallets/dist/wc-fbb7ab15.browser.esm.js
var TW_WC_PROJECT_ID = "145769e410f16970a79ff77b2d89a1e0";
var WC_RELAY_URL = "wss://relay.walletconnect.com";
var EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction",
  SWITCH_CHAIN: "wallet_switchEthereumChain"
};

// node_modules/@thirdweb-dev/wallets/dist/base-189f73e0.browser.esm.js
var PREFIX = "__TW__";
var AsyncLocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));
    });
  }
  setItem(key, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
        res();
      } catch (e) {
        rej(e);
      }
    });
  }
  removeItem(key) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
      res();
    });
  }
};
function createAsyncLocalStorage(name) {
  return new AsyncLocalStorage(name);
}
var DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var walletAnalyticsEnabled = true;
function isWalletAnalyticsEnabled() {
  return walletAnalyticsEnabled;
}
function setWalletAnalyticsEnabled(enabled) {
  walletAnalyticsEnabled = enabled;
}
var ANALYTICS_ENDPOINT = "https://c.thirdweb.com/event";
function track(args) {
  if (!isWalletAnalyticsEnabled()) {
    return;
  }
  const {
    clientId,
    walletType,
    walletAddress,
    source,
    action
  } = args;
  const body = {
    source,
    action,
    walletAddress,
    walletType
  };
  fetch(ANALYTICS_ENDPOINT, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-client-id": clientId,
      ...getAnalyticsHeaders()
    },
    body: JSON.stringify(body)
  });
}
var AbstractClientWallet = class extends AbstractWallet {
  /**
   * @internal
   */
  /**
   * @internal
   */
  getMeta() {
    return this.constructor.meta;
  }
  /**
   * Creates an returns instance of `AbstractClientWallet`
   *
   * @param walletId - A Unique identifier for the wallet ( name of the wallet )
   * @param options - Options for creating wallet instance
   */
  constructor(walletId, options) {
    super();
    this.walletId = walletId;
    this.options = options;
    this.chains = ((options == null ? void 0 : options.chains) || defaultChains).map((c7) => updateChainRPCs(c7, options == null ? void 0 : options.clientId));
    this.dappMetadata = (options == null ? void 0 : options.dappMetadata) || DEFAULT_DAPP_META;
    this.walletStorage = (options == null ? void 0 : options.walletStorage) || createAsyncLocalStorage(this.walletId);
  }
  /**
   * Returns the Wallet Connector used by the wallet
   */
  /**
   * auto-connect the wallet if possible
   * @returns
   */
  async autoConnect(connectOptions) {
    const options = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return this._connect(true, options);
  }
  /**
   * Connect wallet
   * @param connectOptions - Options for connecting to the wallet
   * @returns
   */
  async connect(connectOptions) {
    this._connectParams = connectOptions;
    const address = await this._connect(false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  /**
   * @internal
   * Get the options used for connecting to the wallet
   * @returns
   */
  getConnectParams() {
    return this._connectParams;
  }
  /**
   * @internal
   * Get the options used for creating the wallet instance
   */
  getOptions() {
    return this.options;
  }
  async _connect(isAutoConnect, connectOptions) {
    const connector = await this.getConnector();
    this._subscribeToEvents(connector);
    const isConnected = await connector.isConnected();
    if (isConnected) {
      const address = await connector.getAddress();
      connector.setupListeners();
      if (connectOptions == null ? void 0 : connectOptions.chainId) {
        await connector.switchChain(connectOptions == null ? void 0 : connectOptions.chainId);
      }
      this.emit("connect", {
        address,
        chainId: await this.getChainId()
      });
      this._trackConnection(address);
      return address;
    }
    if (isAutoConnect) {
      throw new Error("Failed to auto connect to the wallet.");
    }
    try {
      const address = await connector.connect(connectOptions);
      this._trackConnection(address);
      return address;
    } catch (error) {
      throw new Error(error.message);
    }
  }
  _trackConnection(address) {
    var _a2;
    track({
      clientId: ((_a2 = this.options) == null ? void 0 : _a2.clientId) || "",
      source: "connectWallet",
      action: "connect",
      walletType: this.walletId,
      walletAddress: address
    });
  }
  async _subscribeToEvents(connector) {
    connector.on("connect", (data) => {
      var _a2;
      this.emit("connect", {
        address: data.account,
        chainId: (_a2 = data.chain) == null ? void 0 : _a2.id
      });
    });
    connector.on("change", (data) => {
      var _a2;
      this.emit("change", {
        address: data.account,
        chainId: (_a2 = data.chain) == null ? void 0 : _a2.id
      });
    });
    connector.on("message", (data) => {
      this.emit("message", data);
    });
    connector.on("disconnect", async () => {
      this.emit("disconnect");
    });
    connector.on("error", (error) => this.emit("error", error));
  }
  /**
   * Get [ethers Signer](https://docs.ethers.org/v5/api/signer/) object of the connected wallet
   */
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  /**
   * Disconnect the wallet
   */
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  /**
   * Switch to different Network/Blockchain in the connected wallet
   * @param chainId - The chainId of the network to switch to
   */
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  /**
   * Update the chains supported by the wallet. This is useful if wallet was initialized with some chains and this needs to be updated without re-initializing the wallet
   */
  async updateChains(chains) {
    this.chains = chains.map((c7) => {
      var _a2;
      return updateChainRPCs(c7, (_a2 = this.options) == null ? void 0 : _a2.clientId);
    });
    const connector = await this.getConnector();
    connector.updateChains(this.chains);
  }
  /**
   * If the wallet uses another "personal wallet" under the hood, return it
   *
   * This is only useful for wallets like Safe or Smart Wallet uses a "personal wallet" under the hood to sign transactions. This method returns that wallet
   */
  getPersonalWallet() {
    return void 0;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/blocto/dist/thirdweb-dev-wallets-evm-wallets-blocto.browser.esm.js
init_eventemitter3();
init_lib3();
var BloctoWallet = class _BloctoWallet extends AbstractClientWallet {
  /**
   * Create a `BloctoWallet` instance
   * @param options - The `options` object includes the following properties
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### appId (recommended)
   * To get advanced features and support from Blocto, you can create an appId from [blocto dashboard](https://docs.blocto.app/blocto-sdk/register-app-id)
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { BloctoWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new BloctoWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### chain (optional)
   * The Network to connect the wallet to. Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   */
  constructor(options) {
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    super(_BloctoWallet.id, options);
    _defineProperty(this, "name", "Blocto");
  }
  /**
   * @internal
   */
  async initConnector() {
    var _a2, _b, _c2;
    const {
      BloctoConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-blocto.browser.esm-2QIT4DNW.js");
    const bloctoConnector = new BloctoConnector({
      chains: this.chains,
      options: {
        appId: (_a2 = this.options) == null ? void 0 : _a2.appId,
        chainId: (_c2 = (_b = this.options) == null ? void 0 : _b.chain) == null ? void 0 : _c2.chainId
      }
    });
    this.connector = new WagmiAdapter(bloctoConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initConnector();
    }
    return Promise.resolve(this.connector);
  }
};
_defineProperty(BloctoWallet, "id", walletIds.blocto);
_defineProperty(BloctoWallet, "meta", {
  name: "Blocto",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMzNfMjM4NykiPgo8cmVjdCB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHJ4PSIxMiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTMyLjkwMjggMTguMzA2M0MyOC4zOTExIDE4LjMwNjMgMjMuOTg3MyAyMC4wNDU5IDIwLjY5NTIgMjMuMTMxOUMxNy4wODQzIDI2LjUxNzYgMTQuNzk5MiAzMS41MTc3IDEzLjQ4OTMgMzYuMjIxMkMxMi42MzE0IDM5LjI5OTIgMTIuMjAxNiA0Mi40OTE1IDEyLjIwMTYgNDUuNjg1M0MxMi4yMDE2IDQ2LjY1MTEgMTIuMjQxMiA0Ny42MDg5IDEyLjMxNzQgNDguNTU1NkMxMi40MTA5IDQ5LjcwNjkgMTMuNTMyMSA1MC41MDQ2IDE0LjY0ODUgNTAuMjAzM0MxNS42MjIyIDQ5Ljk0MTYgMTYuNjQ2NiA0OS44MDA1IDE3LjcwMjggNDkuODAwNUMxOS44NzIyIDQ5LjgwMDUgMjEuOTA1MiA1MC4zOTA0IDIzLjY0OCA1MS40MjEyQzIzLjY5MDggNTEuNDQ2NiAyMy43MzIgNTEuNDcxOSAyMy43NzQ4IDUxLjQ5NTdDMjYuNjA3MSA1My4xODQ2IDI5Ljk0ODQgNTQuMTEyMyAzMy41MTE3IDUzLjk5MzRDNDIuODA2MiA1My42ODU3IDUwLjM5OSA0Ni4xMjMgNTAuNzQxNiAzNi44MzAxQzUxLjExNTggMjYuNjYzNSA0Mi45ODY5IDE4LjMwNDcgMzIuOTA0NCAxOC4zMDQ3TDMyLjkwMjggMTguMzA2M1pNMzIuOTAyOCA0NC4zMTJDMjguMzk3NSA0NC4zMTIgMjQuNzQ1NCA0MC42NTk5IDI0Ljc0NTQgMzYuMTU2MkMyNC43NDU0IDMxLjY1MjUgMjguMzk3NSAyNy45OTg3IDMyLjkwMjggMjcuOTk4N0MzNy40MDgxIDI3Ljk5ODcgNDEuMDYwMiAzMS42NTA5IDQxLjA2MDIgMzYuMTU2MkM0MS4wNjAyIDQwLjY2MTQgMzcuNDA4MSA0NC4zMTIgMzIuOTAyOCA0NC4zMTJaIiBmaWxsPSIjMTRBQUZGIi8+CjxwYXRoIGQ9Ik0yNS41NjM2IDEyLjY4MjZDMjUuNTYzNiAxNS4wMzQ0IDI0LjMzMTUgMTcuMjE2NCAyMi4zMDggMTguNDE1M0MyMS4wMzc3IDE5LjE2ODYgMTkuODQ2OCAyMC4wNTgyIDE4Ljc2ODQgMjEuMDcxNUMxNi4zNzU1IDIzLjMxMzkgMTQuNTg5OCAyNi4wNjUzIDEzLjI2NzMgMjguNzkyOUMxMy4wMDcyIDI5LjMzMDQgMTIuMiAyOS4xNDAyIDEyLjIgMjguNTQyM1YxMi42ODI2QzEyLjIgOC45OTI0MiAxNS4xOTI0IDYgMTguODgyNiA2QzIyLjU3MjggNiAyNS41NjUyIDguOTkyNDIgMjUuNTY1MiAxMi42ODI2SDI1LjU2MzZaIiBmaWxsPSIjMDA3NUZGIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMjIzM18yMzg3Ij4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  urls: {
    android: "https://play.google.com/store/apps/details?id=com.portto.blocto",
    ios: "https://apps.apple.com/app/blocto/id1481181682"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/embedded-wallet/dist/thirdweb-dev-wallets-evm-wallets-embedded-wallet.browser.esm.js
init_lib3();
init_eventemitter3();
var EmbeddedWallet = class _EmbeddedWallet extends AbstractClientWallet {
  /**
   * Sends a verification email to the provided email address.
   *
   * @param email - The email address to which the verification email will be sent.
   * @param clientId - Your thirdweb client ID
   * @returns Information on the user's status and whether they are a new user.
   *
   * @example
   * ```typescript
   * EmbeddedWallet.sendVerificationEmail({ email: 'test@example.com', clientId: 'yourClientId' })
   *   .then(() => console.log('Verification email sent successfully.'))
   *   .catch(error => console.error('Failed to send verification email:', error));
   * ```
   */
  static async sendVerificationEmail(options) {
    const wallet = new _EmbeddedWallet({
      chain: c1,
      clientId: options.clientId
    });
    return wallet.sendVerificationEmail({
      email: options.email
    });
  }
  /**
   * Sends a verification sms to the provider phone number.
   *
   * @param phoneNumber - The phone number to which the verification sms will be sent. The phone number must contain the country code.
   * @param clientId - Your thirdweb client ID
   * @returns Information on the user's status and whether they are a new user.
   *
   * @example
   * ```typescript
   * const result = await EmbeddedWallet.sendVerificationEmail({
   *  phoneNumber: '+1234567890',
   *  clientId: 'yourClientId'
   * });
   * ```
   */
  static async sendVerificationSms(options) {
    const wallet = new _EmbeddedWallet({
      chain: c1,
      clientId: options.clientId
    });
    return wallet.sendVerificationSms({
      phoneNumber: options.phoneNumber
    });
  }
  /**
   * @internal
   */
  get walletName() {
    return "Embedded Wallet";
  }
  /**
   * @internal
   */
  /**
   * The options for instantiating an `EmbeddedWallet`
   *
   * @param options -
   * The options object contains the following properties:
   *
   * ### clientId (required)
   * The chain to connect to by default.
   *
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * ### chain (required)
   * The chain to connect to by default.
   *
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   */
  constructor(options) {
    super(_EmbeddedWallet.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
  }
  async getConnector() {
    var _a2, _b;
    if (!this.connector) {
      const {
        EmbeddedWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-embedded-wallet.browser.esm-XGXJ7GGJ.js");
      this.connector = new EmbeddedWalletConnector({
        clientId: ((_a2 = this.options) == null ? void 0 : _a2.clientId) ?? "",
        chain: this.chain,
        chains: this.chains,
        onAuthSuccess: (_b = this.options) == null ? void 0 : _b.onAuthSuccess
      });
    }
    return this.connector;
  }
  /**
   * auto connect the wallet if the wallet was previously connected and session is still valid
   */
  autoConnect(connectOptions) {
    if (!connectOptions) {
      throw new Error("Can't autoconnect embedded wallet");
    }
    return this.connect(connectOptions);
  }
  /**
   * @internal
   */
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    return {
      chainId: connectParams.chainId,
      authResult: {
        user: connectParams.authResult.user
      }
    };
  }
  /**
   * Get the email associated with the currently connected wallet.
   * @example
   * ```ts
   * ```javascript
   * const email = await wallet.getEmail();
   * ```
   */
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  /**
   * Get the phone number associated with the currently connected wallet.
   * @example
   * ```ts
   * ```javascript
   * const email = await wallet.getPhoneNumber();
   * ```
   */
  async getPhoneNumber() {
    const connector = await this.getConnector();
    return connector.getPhoneNumber();
  }
  /**
   * Get the instance of `EmbeddedWalletSdk` used by the wallet.
   */
  async getEmbeddedWalletSDK() {
    const connector = await this.getConnector();
    return connector.getEmbeddedWalletSDK();
  }
  // TODO move to connect/auth callback
  async getRecoveryInformation() {
    const connector = await this.getConnector();
    return connector.getRecoveryInformation();
  }
  /**
   * Send a verification code to the user's email for verification.
   * Use this as a prestep before calling `authenticate` with the `email_verification` strategy.
   *
   * ```javascript
   * const result = await wallet.sendVerificationEmail({
   *   email: "alice@example.com",
   * });
   * ```
   *
   * This method is also available as a static method on the `EmbeddedWallet` class.
   * ```javascript
   * const result = await EmbeddedWallet.sendVerificationEmail({
   *  email: "alice@example.com",
   * })
   * ```
   *
   * @param options - The `options` object contains the following properties:
   * ### email (required)
   * The email address to send verification email to.
   *
   * @returns object containing below properties:
   *
   * ```ts
   * {
   *  isNewDevice: boolean;
   *  isNewUser: boolean;
   *  recoveryShareManagement: "USER_MANAGED" | "AWS_MANAGED";
   * }
   * ```
   *
   * ### isNewDevice
   * If user has not logged in from this device before, this will be true.
   *
   * ### isNewUser
   * If user is logging in for the first time, this will be true.
   *
   * ### recoveryShareManagement
   * Recovery share management type. Can be either `USER_MANAGED` or `AWS_MANAGED`.
   *
   */
  async sendVerificationEmail(options) {
    const {
      email
    } = options;
    const connector = await this.getConnector();
    return connector.sendVerificationEmail({
      email
    });
  }
  /**
   * Send a verification code to the user's phone number for verification. The phone number must contain the country code.
   * Use this as a pre-step before calling `authenticate` with the `phone_number_verification` strategy.
   *
   * ```js
   * const result = await wallet.sendVerificationSms({
   *   phoneNumber: "+1234567890",
   * });
   * ```
   *
   * This method is also available as a static method on the `EmbeddedWallet` class.
   * ```javascript
   * const result = await EmbeddedWallet.sendVerificationSms({
   *   phoneNumber: "+1234567890",
   * });
   * ```
   *
   * @param options - The `options` object contains the following properties:
   * ### phoneNumber (required)
   * The phone number to send verification SMS to. The phone number must contain the country code.
   *
   * @returns object containing below properties:
   *
   * ```ts
   * {
   *  isNewDevice: boolean;
   *  isNewUser: boolean;
   *  recoveryShareManagement: "USER_MANAGED" | "AWS_MANAGED";
   * }
   * ```
   *
   * ### isNewDevice
   * If user has not logged in from this device before, this will be true.
   *
   * ### isNewUser
   * If user is logging in for the first time, this will be true.
   *
   * ### recoveryShareManagement
   * Recovery share management type. Can be either `USER_MANAGED` or `AWS_MANAGED`.
   */
  async sendVerificationSms(options) {
    const {
      phoneNumber
    } = options;
    const connector = await this.getConnector();
    return connector.sendVerificationSms({
      phoneNumber
    });
  }
  /**
   * Authenticate the user with any of the available auth strategies.
   *
   * @example
   * ```javascript
   * const authResult = await wallet.authenticate({
   *   strategy: "google",
   * });
   * ```
   *
   * @param params -
   * Choose one of the available auth strategy, which comes with different required arguments.
   * ```ts
   * // email verification
   * type EmailVerificationAuthParams = {
   *   strategy: "email_verification";
   *   email: string;
   *   verificationCode: string;
   *   recoveryCode?: string;
   * };
   *
   * export type EmbeddedWalletOauthStrategy = "google" | "apple" | "facebook";
   *
   * type OauthAuthParams = {
   *   strategy: EmbeddedWalletOauthStrategy;
   *   openedWindow?: Window;
   *   closeOpenedWindow?: (window: Window) => void;
   * };
   *
   * // bring your own authentication
   * type JwtAuthParams = {
   *   strategy: "jwt";
   *   jwt: string;
   *   encryptionKey?: string;
   * };
   *
   * // open iframe to send and input the verification code only
   * type IframeOtpAuthParams = {
   *   strategy: "iframe_email_verification";
   *   email: string;
   * };
   *
   * // open iframe to enter email and verification code
   * type IframeAuthParams = {
   *   strategy: "iframe";
   * };
   * ```
   *
   * @returns
   * The `authResult` object - which you can pass to the `connect` method to connect to the wallet.
   *
   * ```ts
   * const authResult = await wallet.authenticate(authOptions);
   * await wallet.connect({ authResult });
   * ```
   */
  async authenticate(params) {
    const connector = await this.getConnector();
    const authResult = connector.authenticate(params);
    try {
      await this.walletStorage.setItem(LAST_USED_AUTH_STRATEGY, params.strategy);
    } catch {
    }
    return authResult;
  }
  /**
   * @internal
   */
  async getLastUsedAuthStrategy() {
    try {
      return await this.walletStorage.getItem(LAST_USED_AUTH_STRATEGY);
    } catch {
      return null;
    }
  }
  /**
   * After authenticating, you can connect to the wallet by passing the `authResult` to the `connect` method.
   *
   * ```ts
   * const authResult = await wallet.authenticate(authOptions);
   *
   * await wallet.connect({ authResult });
   * ```
   *
   * @param connectOptions - The `connectOptions` object contains the following properties:
   *
   * ### authResult (required)
   *
   * The `authResult` object is returned from the `authenticate` method.
   *
   * @returns The address of the connected wallet.
   */
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(EmbeddedWallet, "id", walletIds.embeddedWallet);
_defineProperty(EmbeddedWallet, "meta", {
  name: "Embedded Wallet",
  iconURL: "ipfs://QmNx2evQa6tcQs9VTd3YaDm31ckfStvgRGKFGELahUmrbV/emailIcon.svg"
});
var LAST_USED_AUTH_STRATEGY = "lastUsedAuthStrategy";

// node_modules/@thirdweb-dev/wallets/evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.browser.esm.js
init_eventemitter3();
init_lib3();
var MetaMaskWallet = class _MetaMaskWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "MetaMask";
  }
  /**
   * @param options -
   * The `options` object contains the following properties:
   *
   * ### clientId (recommended)
   * Provide clientId to use the thirdweb RPCs for given chains
   * You can create a client ID for your application from thirdweb dashboard.
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to MetaMask mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to `defaultChains` ( `import { defaultChains } from "@thirdweb-dev/chains"` )
   *
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { MetaMaskWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new MetaMaskWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### qrcode (optional)
   * Whether to display the Wallet Connect QR code Modal for connecting to MetaMask on mobile if MetaMask is not injected.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * options to customize the Wallet Connect QR Code Modal ( only relevant when qrcode is true )
   */
  constructor(options) {
    super(_MetaMaskWallet.id, options);
    this.isInjected = !!getInjectedMetamaskProvider();
  }
  async getConnector() {
    var _a2, _b, _c2;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-SRX52KY6.js");
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.metamaskConnector = metamaskConnector;
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-NCWN2W7X.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a2 = this.options) == null ? void 0 : _a2.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c2 = this.options) == null ? void 0 : _c2.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the MetaMask wallet using a QR code if the user does not have the Metamask extension installed.
   *
   * You can use this method to display a QR code. User can scan the QR code from the MetaMask mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * metamask.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, MetaMask will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  /**
   * MetaMask extension on desktop supports switching accounts.
   * This method will trigger the MetaMask extension to show the account switcher Modal
   */
  async switchAccount() {
    if (!this.metamaskConnector) {
      throw new Error("Can not switch Account");
    }
    await this.metamaskConnector.switchAccount();
  }
};
_defineProperty(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    android: "https://play.google.com/store/apps/details?id=io.metamask",
    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202"
  }
});
_defineProperty(MetaMaskWallet, "id", walletIds.metamask);

// node_modules/@thirdweb-dev/wallets/evm/wallets/okx/dist/thirdweb-dev-wallets-evm-wallets-okx.browser.esm.js
init_eventemitter3();
init_lib3();
var OKXWallet = class _OKXWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "OKX";
  }
  /**
   * Create instance of `OKXWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_OKXWallet.id, options);
    this.isInjected = !!getInjectedOKXProvider();
  }
  async getConnector() {
    var _a2, _b, _c2;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          OKXConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-okx.browser.esm-EZEQOAYI.js");
        this.OKXConnector = new OKXConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.OKXConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-NCWN2W7X.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a2 = this.options) == null ? void 0 : _a2.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c2 = this.options) == null ? void 0 : _c2.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the OKX Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(OKXWallet, "id", walletIds.okx);

// node_modules/@thirdweb-dev/wallets/evm/wallets/core-wallet/dist/thirdweb-dev-wallets-evm-wallets-core-wallet.browser.esm.js
init_eventemitter3();
init_lib3();
var CoreWallet = class _CoreWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Core wallet";
  }
  /**
   * Create instance of `CoreWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_CoreWallet.id, options);
    this.isInjected = !!getInjectedCoreWalletProvider();
  }
  async getConnector() {
    var _a2, _b, _c2;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          CoreWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-core-wallet.browser.esm-72SIHZHE.js");
        this.CoreWalletConnector = new CoreWalletConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.CoreWalletConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-NCWN2W7X.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a2 = this.options) == null ? void 0 : _a2.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c2 = this.options) == null ? void 0 : _c2.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Core Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(CoreWallet, "id", walletIds.coreWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/onekey/dist/thirdweb-dev-wallets-evm-wallets-onekey.browser.esm.js
init_eventemitter3();
init_lib3();
var OneKeyWallet = class _OneKeyWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "OneKey wallet";
  }
  /**
   * Create instance of `OneKeyWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_OneKeyWallet.id, options);
    this.isInjected = !!getInjectedOneKeyProvider();
  }
  async getConnector() {
    var _a2, _b, _c2;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          OneKeyConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-onekey.browser.esm-ESTDL56L.js");
        this.OneKeyConnector = new OneKeyConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.OneKeyConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-NCWN2W7X.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a2 = this.options) == null ? void 0 : _a2.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c2 = this.options) == null ? void 0 : _c2.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the OneKey Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(OneKeyWallet, "id", walletIds.oneKey);

// node_modules/@thirdweb-dev/wallets/evm/wallets/crypto-defi-wallet/dist/thirdweb-dev-wallets-evm-wallets-crypto-defi-wallet.browser.esm.js
init_eventemitter3();
init_lib3();
var CryptoDefiWallet = class _CryptoDefiWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Crypto Defi wallet";
  }
  /**
   * Create instance of `CryptoDefiWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_CryptoDefiWallet.id, options);
    this.isInjected = !!getInjectedCryptoDefiWalletProvider();
  }
  async getConnector() {
    var _a2, _b, _c2;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          CryptoDefiWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-crypto-defi-wallet.browser.esm-MWJPUFG4.js");
        this.CryptoDefiWalletConnector = new CryptoDefiWalletConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.CryptoDefiWalletConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-NCWN2W7X.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a2 = this.options) == null ? void 0 : _a2.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c2 = this.options) == null ? void 0 : _c2.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Defi Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(CryptoDefiWallet, "id", walletIds.cryptoDefiWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/rabby/dist/thirdweb-dev-wallets-evm-wallets-rabby.browser.esm.js
init_eventemitter3();
init_lib3();
var RabbyWallet = class _RabbyWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Rabby wallet";
  }
  /**
   * Create instance of `RabbyWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_RabbyWallet.id, options);
    this.isInjected = !!getInjectedRabbyProvider();
  }
  async getConnector() {
    var _a2, _b, _c2;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RabbyConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rabby.browser.esm-I5J2XNGM.js");
        this.RabbyConnector = new RabbyConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.RabbyConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-NCWN2W7X.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a2 = this.options) == null ? void 0 : _a2.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c2 = this.options) == null ? void 0 : _c2.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Rabby Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RabbyWallet, "id", walletIds.rabby);

// node_modules/@thirdweb-dev/wallets/evm/wallets/coin98/dist/thirdweb-dev-wallets-evm-wallets-coin98.browser.esm.js
init_eventemitter3();
init_lib3();
var Coin98Wallet = class _Coin98Wallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Coin98 wallet";
  }
  /**
   * Create instance of `Coin98Wallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_Coin98Wallet.id, options);
    this.isInjected = !!getInjectedCoin98Provider();
  }
  async getConnector() {
    var _a2, _b, _c2;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          Coin98Connector
        } = await import("./thirdweb-dev-wallets-evm-connectors-coin98.browser.esm-TKFXZS6A.js");
        this.Coin98Connector = new Coin98Connector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.Coin98Connector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-NCWN2W7X.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a2 = this.options) == null ? void 0 : _a2.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c2 = this.options) == null ? void 0 : _c2.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Coin98 Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(Coin98Wallet, "id", walletIds.coin98);

// node_modules/@thirdweb-dev/wallets/dist/getInjectedCoinbaseProvider-b24ac791.browser.esm.js
function getInjectedCoinbaseProvider() {
  var _a2;
  function getReady(ethereum) {
    const isCoinbaseWallet = !!(ethereum == null ? void 0 : ethereum.isCoinbaseWallet);
    if (isCoinbaseWallet) {
      return ethereum;
    }
    if (ethereum && "overrideIsMetaMask" in ethereum) {
      if ("providerMap" in ethereum) {
        if (ethereum.providerMap instanceof Map) {
          if (ethereum.providerMap.has("CoinbaseWallet")) {
            return ethereum;
          }
        }
      }
    }
  }
  if (assertWindowEthereum(globalThis.window)) {
    if ((_a2 = globalThis.window.ethereum) == null ? void 0 : _a2.providers) {
      return globalThis.window.ethereum.providers.find(getReady);
    }
    return getReady(globalThis.window.ethereum);
  }
}

// node_modules/@thirdweb-dev/wallets/dist/engine-a0cac2eb.browser.esm.js
init_lib3();
var EngineSigner = class _EngineSigner extends ethers_exports.Signer {
  constructor(config, provider) {
    super();
    this.config = {
      ...config,
      engineUrl: config.engineUrl.replace(/\/$/, "")
    };
    ethers_exports.utils.defineReadOnly(this, "provider", provider || null);
  }
  async getAddress() {
    return this.config.backendWalletAddress;
  }
  async signMessage(message) {
    const res = await this.fetch({
      path: "/backend-wallet/sign-message",
      method: "POST",
      body: {
        message
      }
    });
    return res.result;
  }
  async signTransaction(transaction) {
    var _a2, _b, _c2, _d, _e6, _f2;
    const tx = await ethers_exports.utils.resolveProperties(transaction);
    const res = await this.fetch({
      path: "/backend-wallet/sign-transaction",
      method: "POST",
      body: {
        ...tx,
        nonce: (_a2 = tx.nonce) == null ? void 0 : _a2.toString(),
        gasLimit: (_b = tx.gasLimit) == null ? void 0 : _b.toString(),
        gasPrice: (_c2 = tx.gasPrice) == null ? void 0 : _c2.toString(),
        value: (_d = tx.value) == null ? void 0 : _d.toString(),
        maxPriorityFeePerGas: (_e6 = tx.maxPriorityFeePerGas) == null ? void 0 : _e6.toString(),
        maxFeePerGas: (_f2 = tx.maxFeePerGas) == null ? void 0 : _f2.toString()
      }
    });
    return res.result;
  }
  async sendTransaction(transaction) {
    if (!this.provider) {
      throw new Error("Sending transactions requires a provider!");
    }
    const chainId = (await this.provider.getNetwork()).chainId;
    const tx = await ethers_exports.utils.resolveProperties(transaction);
    const res = await this.fetch({
      path: `/backend-wallet/${chainId}/send-transaction`,
      method: "POST",
      body: {
        toAddress: tx.to,
        data: tx.data,
        value: tx.value || "0"
      }
    });
    const queueId = res.result.queueId;
    return {
      hash: queueId,
      confirmations: 0,
      from: this.config.backendWalletAddress,
      nonce: 0,
      gasLimit: BigNumber.from(0),
      value: BigNumber.from(0),
      data: "",
      chainId,
      wait: async (confirmations) => {
        if (!this.provider) {
          throw new Error("Sending transactions requires a provider!");
        }
        while (true) {
          const {
            result: txRes
          } = await this.fetch({
            path: `/transaction/status/${queueId}`,
            method: "GET"
          });
          switch (txRes.status) {
            case "errored":
              throw new Error(`Transaction errored with reason: ${txRes.errorMessage}`);
            case "cancelled":
              throw new Error(`Transaction execution cancelled.`);
            case "mined":
              const receipt = await this.provider.getTransactionReceipt(txRes.transactionHash);
              return receipt;
          }
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
      }
    };
  }
  connect(provider) {
    return new _EngineSigner(this.config, provider);
  }
  async fetch(_ref) {
    let {
      path,
      method,
      body
    } = _ref;
    const res = await fetch(`${this.config.engineUrl}${path}`, {
      method,
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.config.accessToken}`,
        "x-backend-wallet-address": this.config.backendWalletAddress
      },
      ...body ? {
        body: JSON.stringify(body)
      } : {}
    });
    if (!res.ok) {
      throw new Error(await res.text());
    }
    return res.json();
  }
};
var EngineWallet = class extends AbstractWallet {
  constructor(config) {
    super();
    this._signer = new EngineSigner(config);
  }
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_lib3();
init_eventemitter3();
var PaperWallet = class _PaperWallet extends AbstractClientWallet {
  get walletName() {
    return "Paper Wallet";
  }
  constructor(options) {
    var _a2;
    super(_PaperWallet.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
    if (options.paperClientId && options.paperClientId === "uninitialized") {
      this.paperClientId = "00000000-0000-0000-0000-000000000000";
      return;
    }
    if (options.advancedOptions && ((_a2 = options.advancedOptions) == null ? void 0 : _a2.recoveryShareManagement) === "USER_MANAGED") {
      if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId) || !options.paperClientId && options.clientId && !this.isClientIdLegacyPaper(options.clientId)) {
        throw new Error('RecoveryShareManagement option "USER_MANAGED" is not supported with thirdweb client ID');
      }
    }
    if (!options.clientId && !options.paperClientId) {
      throw new Error("clientId or paperClientId is required");
    }
    if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId)) {
      throw new Error("paperClientId must be a legacy paper client ID");
    }
    if (options.clientId && this.isClientIdLegacyPaper(options.clientId)) {
      throw new Error("clientId must be a thirdweb client ID");
    }
    this.paperClientId = options.paperClientId ?? options.clientId;
    this.onAuthSuccess = options.onAuthSuccess;
  }
  isClientIdLegacyPaper(clientId) {
    return clientId.indexOf("-") > 0 && clientId.length === 36;
  }
  async getConnector() {
    var _a2, _b, _c2;
    if (!this.connector) {
      const {
        PaperWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-paper.browser.esm-IQJ33NU6.js");
      this.connector = new PaperWalletConnector({
        clientId: this.paperClientId,
        chain: this.chain,
        chains: this.chains,
        onAuthSuccess: this.onAuthSuccess,
        advancedOptions: {
          recoveryShareManagement: (_b = (_a2 = this.options) == null ? void 0 : _a2.advancedOptions) == null ? void 0 : _b.recoveryShareManagement
        },
        styles: (_c2 = this.options) == null ? void 0 : _c2.styles
      });
    }
    return this.connector;
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    if (typeof connectParams.googleLogin === "object") {
      return {
        ...connectParams,
        googleLogin: true
      };
    }
    return connectParams;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getPaperSDK() {
    const connector = await this.getConnector();
    return connector.getPaperSDK();
  }
};
_defineProperty(PaperWallet, "id", walletIds.paper);
_defineProperty(PaperWallet, "meta", {
  name: "Paper Wallet",
  iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.browser.esm.js
var import_buffer = __toESM(require_buffer());
init_eventemitter3();
init_lib3();
{
  window.Buffer = import_buffer.Buffer;
}
var CoinbaseWallet = class _CoinbaseWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Coinbase Wallet";
  }
  /**
   * @internal
   */
  /**
   * @internal
   */
  /**
   *
   * @param options -
   * The `options` object contains the following properties:
   *
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   *
   * ### chains (optional)
   *
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   *
   * ### dappMetadata (optional)
   *
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url` and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { CoinbaseWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new CoinbaseWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp", // optional
   *     logoUrl: "https://thirdweb.com/favicon.ico", // optional
   *   },
   * });
   * ```
   *
   * ### headlessMode (optional)
   * This is only relevant applies when coinbase extension wallet is NOT installed on user's browser.
   *
   * By default `headlessMode` is set to `false` - which means that when user does not have coinbase wallet extension installed, a QR Code scan modal will open when calling the `connect` method to allow the user to connect to their coinbase mobile app by scanning the QR code.
   *
   * If headlessMode is set to `true` and coinbase wallet extension is not installed, the wallet will NOT open a QR Code scan modal - This is useful if you want to create a custom QR Code modal.
   *
   * you can use the `getQrUrl` method to get the QR Code url and create your own QR Code Modal
   *
   * Must be a `boolean`.
   */
  constructor(options) {
    super(_CoinbaseWallet.id, options);
    this.headlessMode = (options == null ? void 0 : options.headlessMode) || false;
    this.theme = (options == null ? void 0 : options.theme) || this.dappMetadata.isDarkMode === false ? "light" : "dark";
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-QSO6OABI.js");
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.theme === "dark",
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  /**
   * Get the QR Code url to render a custom QR Code Modal for connecting to Coinbase Wallet.
   *
   * This method is only relevant when coinbase extension wallet is NOT installed on user's browser and `headlessMode` is set to `true`.
   *
   * @example
   * ```ts
   * const wallet = new CoinbaseWallet({ headlessMode: true });
   *
   * const qrUrl = await wallet.getQrUrl();
   * // render a QR Code Modal with the qrUrl
   *
   * const walletAddress = await wallet.connect(); // this is resolved when user scans the QR Code and wallet is connected
   *
   * console.log('connected to', walletAddress);
   * ```
   *
   * @returns
   */
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
};
_defineProperty(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    android: "https://play.google.com/store/apps/details?id=org.toshi",
    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
  }
});
_defineProperty(CoinbaseWallet, "id", walletIds.coinbase);

// node_modules/@thirdweb-dev/wallets/evm/wallets/ethers/dist/thirdweb-dev-wallets-evm-wallets-ethers.browser.esm.js
init_lib3();
init_eventemitter3();
var EthersWallet = class extends AbstractWallet {
  /**
   * Create instance of `EthersWallet`
   * @param signer - ethers.js signer object
   */
  constructor(signer) {
    super();
    this._signer = signer;
  }
  /**
   * Returns [ethers signer](https://docs.ethers.org/v5/api/signer/) object used by the wallet
   */
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/frame/dist/thirdweb-dev-wallets-evm-wallets-frame.browser.esm.js
init_eventemitter3();
init_lib3();
var FrameWallet = class _FrameWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Frame Wallet";
  }
  /**
   * Create a `FrameWallet` instance
   * @param options -
   * The `options` object includes the following properties
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { FrameWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new FrameWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_FrameWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        FrameConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-frame.browser.esm-IDNNW4KQ.js");
      this.connector = new WagmiAdapter(new FrameConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(FrameWallet, "id", walletIds.frame);

// node_modules/@thirdweb-dev/wallets/evm/wallets/imtoken/dist/thirdweb-dev-wallets-evm-wallets-imtoken.browser.esm.js
init_eventemitter3();
init_lib3();
var ImTokenWallet = class _ImTokenWallet extends AbstractClientWallet {
  get walletName() {
    return "imToken";
  }
  constructor(options) {
    var _a2;
    super(_ImTokenWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a2 = globalThis.window.ethereum) == null ? void 0 : _a2.isImToken);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a2, _b, _c2;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ImTokenConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-imtoken.browser.esm-QX4ZMDRK.js");
        const imtokenConnector = new ImTokenConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.imtokenConnector = imtokenConnector;
        this.connector = new WagmiAdapter(imtokenConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-NCWN2W7X.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a2 = this.options) == null ? void 0 : _a2.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c2 = this.options) == null ? void 0 : _c2.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Trust Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ImTokenWallet, "meta", {
  name: "imToken",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMl80NzgzKSI+CjxtYXNrIGlkPSJtYXNrMF8yMjJfNDc4MyIgc3R5bGU9Im1hc2stdHlwZTpsdW1pbmFuY2UiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjAiIHk9IjAiIHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCI+CjxwYXRoIGQ9Ik03OS44OTQ4IDBIMC4wNTA3ODEyVjgwSDc5Ljg5NDhWMFoiIGZpbGw9IndoaXRlIi8+CjwvbWFzaz4KPGcgbWFzaz0idXJsKCNtYXNrMF8yMjJfNDc4MykiPgo8cGF0aCBkPSJNNjIuMDI3NSAwSDE4LjA1MDlDOC4xNDYzOSAwIDAuMTE3MTg4IDguMDQ0ODggMC4xMTcxODggMTcuOTY4OFY2Mi4wMzEyQzAuMTE3MTg4IDcxLjk1NTEgOC4xNDYzOSA4MCAxOC4wNTA5IDgwSDYyLjAyNzVDNzEuOTMyIDgwIDc5Ljk2MTIgNzEuOTU1MSA3OS45NjEyIDYyLjAzMTJWMTcuOTY4OEM3OS45NjEyIDguMDQ0ODggNzEuOTMyIDAgNjIuMDI3NSAwWiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzIyMl80NzgzKSIvPgo8cGF0aCBkPSJNNjUuMDk4MSAyNC43MzNDNjYuNzU4NiA0Ny4yNjY3IDUyLjMwMjEgNTcuOTE3MiAzOS4zNDIzIDU5LjA1M0MyNy4yOTM1IDYwLjEwODcgMTUuOTUyIDUyLjY5MDggMTQuOTU3MSA0MS4yOTM2QzE0LjEzNjMgMzEuODc3NiAxOS45NDQ1IDI3Ljg2ODkgMjQuNTA4IDI3LjQ2OTRDMjkuMjAxNSAyNy4wNTcgMzMuMTQ1OCAzMC4zMDAxIDMzLjQ4NzkgMzQuMjI2OUMzMy44MTc1IDM4LjAwMiAzMS40NjY0IDM5LjcyMDUgMjkuODMxMyAzOS44NjM0QzI4LjUzODIgMzkuOTc3IDI2LjkxMTQgMzkuMTkwNSAyNi43NjQ1IDM3LjUwMTZDMjYuNjM4NSAzNi4wNTAzIDI3LjE4ODUgMzUuODUyNiAyNy4wNTQxIDM0LjMxMDlDMjYuODE0OSAzMS41NjYyIDI0LjQyNjEgMzEuMjQ2NiAyMy4xMTgzIDMxLjM2MDFDMjEuNTM1NyAzMS40OTkxIDE4LjY2NDEgMzMuMzQ5OCAxOS4wNjcgMzcuOTZDMTkuNDcyMiA0Mi42MTAxIDIzLjkyMjIgNDYuMjg0NSAyOS43NTU3IDQ1Ljc3MzRDMzYuMDUwOSA0NS4yMjIzIDQwLjQzMzcgNDAuMzExNCA0MC43NjM0IDMzLjQyMzRDNDAuNzYwMyAzMy4wNTg2IDQwLjgzNyAzMi42OTc1IDQwLjk4OCAzMi4zNjU1TDQwLjk5IDMyLjM1NzJDNDEuMDU3OCAzMi4yMTI4IDQxLjEzNzIgMzIuMDc0MiA0MS4yMjcyIDMxLjk0MjhDNDEuMzYxNiAzMS43NDA5IDQxLjUzMzggMzEuNTE4IDQxLjc1NjIgMzEuMjczOUM0MS43NTgzIDMxLjI2NzYgNDEuNzU4MyAzMS4yNjc2IDQxLjc2MjYgMzEuMjY3NkM0MS45MjQxIDMxLjA4NDcgNDIuMTE5NCAzMC44ODcgNDIuMzM5NyAzMC42NzQ1QzQ1LjA4OTcgMjguMDc1IDU0Ljk5MzEgMjEuOTQ0MiA2NC4zNTkyIDIzLjg4NTVDNjQuNTU3MyAyMy45MjggNjQuNzM2MSAyNC4wMzM0IDY0Ljg2OTMgMjQuMTg2MkM2NS4wMDI1IDI0LjMzOTEgNjUuMDgyNiAyNC41MzA4IDY1LjA5ODEgMjQuNzMzWiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzQ3ODMiIHgxPSI3My41MDA5IiB5MT0iNS4zMTI1IiB4Mj0iMi44NzI0MSIgeTI9Ijc3LjY3NDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzExQzREMSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMDYyQUQiLz4KPC9saW5lYXJHcmFkaWVudD4KPGNsaXBQYXRoIGlkPSJjbGlwMF8yMjJfNDc4MyI+CjxyZWN0IHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4=",
  urls: {
    ios: "https://itunes.apple.com/us/app/imtoken2/id1384798940",
    android: "https://play.google.com/store/apps/details?id=im.token.app"
  }
});
_defineProperty(ImTokenWallet, "id", walletIds.imtoken);

// node_modules/@thirdweb-dev/wallets/evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.browser.esm.js
init_eventemitter3();
init_lib3();
var InjectedWallet = class _InjectedWallet extends AbstractClientWallet {
  get walletName() {
    return "Injected Wallet";
  }
  constructor(options) {
    super(_InjectedWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        InjectedConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-injected.browser.esm-VGIZ3HPM.js");
      this.connector = new WagmiAdapter(new InjectedConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(InjectedWallet, "id", "injected");

// node_modules/@thirdweb-dev/wallets/evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.browser.esm.js
init_lib3();
init_eventemitter3();
var STORAGE_KEY_WALLET_DATA = "localWalletData";
var LocalWallet = class _LocalWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Local Wallet";
  }
  /**
   * Initialize the `LocalWallet` with the given `options`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId or secretKey (recommended)
   * Provide `clientId` or `secretKey` to use the thirdweb RPCs for given `chains`
   *
   * If you are using the `LocalWallet` in a in frontend - provide a `clientId`, If you are using the `LocalWallet` in backend - you can provide a `secretKey`.
   *
   * You can create a `clientId` / `secretKey` from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chain (optional)
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   * Defaults to `Ethereum`.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### storage (optional)
   * This is the default storage for storing the private key, mnemonic or encrypted JSON. This can be implemented in any way you want, as long as it conforms to the `AsyncStorage` interface:
   *
   * If omitted, defaults to browser local storage.
   *
   *
   * ```javascript
   * import { LocalWallet } from "@thirdweb-dev/wallets";
   *
   * const customStorage = {
   *   getItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   removeItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   setItem: (key, value) => {
   *     // Implement your own storage logic here
   *   },
   * };
   *
   * const walletWithOptions = new LocalWallet({
   *   storage: customStorage,
   * });
   * ```
   *
   */
  constructor(options) {
    super(_LocalWallet.id, options);
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options || {};
    this._storage = (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        LocalWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm-4BXFYJFW.js");
      if (!this.ethersWallet) {
        throw new Error("wallet is not initialized");
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c7) => updateChainRPCs(c7, this.options.clientId));
      this.connector = new LocalWalletConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        ethersWallet: this.ethersWallet,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
  /**
   * Load the saved wallet data from storage, if it exists, or generate a new one and save it.
   *
   * @example
   * ```js
   * wallet.loadOrCreate({
   *   strategy: "encryptedJson",
   *   password: password,
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletLoadOrCreateOptions`. It takes a `strategy` property and other properties depending on the strategy.
   *
   * ### strategy "encryptedJson"
   * Load the wallet from encrypted JSON. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to decrypt the encrypted JSON
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * ### strategy "privateKey"
   * Load the wallet from a private key. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - optional encryption object of type `DecryptOptions` to decrypt the private key. This is only required if the saved private key is encrypted.
   */
  async loadOrCreate(options) {
    if (await this.getSavedData(options.storage)) {
      await this.load(options);
    } else {
      await this.generate();
      await this.save(options);
    }
  }
  /**
   * Creates a new random wallet and returns the wallet address.
   *
   * @example
   * ```ts
   * const address = await wallet.generate();
   * ```
   *
   * @returns Promise that resolves to the address of the wallet
   */
  async generate() {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const random = utils_exports.randomBytes(32);
    this.ethersWallet = new Wallet(random);
    return this.ethersWallet.address;
  }
  /**
   * Create local wallet by importing a private key, mnemonic or encrypted JSON.
   * @example
   * ```javascript
   * const address = await localWallet.import({
   *   privateKey: "...",
   *   encryption: false,
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletImportOptions` which can have either `privateKey`, `mnemonic` or `encryptedJson` as a property.
   * They all can be encrypted or un-encrypted. If encrypted, the `encryption` property must be provided with `password` property to decrypt the data.
   *
   * ### privateKey
   * The Private Key of the wallet.
   *
   * ### mnemonic
   * The mnemonic (seed phrase) of the wallet.
   *
   * ### encryptedJson
   * The encrypted JSON of the wallet.
   *
   * ### encryption
   * This is only required if the given `privateKey`, `mnemonic` or `encryptedJson` is encrypted.
   * The `encryption` object of type `DecryptOptions` can be provided to decrypt the data. It is an object with the following properties:
   *
   * #### password
   * The password to decrypt the data.
   *
   * #### decrypt
   * A custom decrypt function that takes the encrypted data and password as arguments and returns the decrypted data.
   *
   * @returns Promise that resolves to the address of the wallet
   */
  async import(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    if ("encryptedJson" in options) {
      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);
      return this.ethersWallet.address;
    }
    if ("privateKey" in options) {
      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {
        throw new Error("invalid private key");
      }
      const privateKey = await getDecryptor(options.encryption)(options.privateKey);
      if (options.encryption && (privateKey === "" || !isValidPrivateKey(privateKey))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = new Wallet(privateKey);
      return this.ethersWallet.address;
    }
    if ("mnemonic" in options) {
      if (!options.encryption && !utils_exports.isValidMnemonic(options.mnemonic)) {
        throw new Error("invalid mnemonic");
      }
      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);
      if (options.encryption && (mnemonic === "" || !utils_exports.isValidMnemonic(mnemonic))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = Wallet.fromMnemonic(mnemonic);
      return this.ethersWallet.address;
    }
    throw new Error("invalid import strategy");
  }
  /**
   * Initialize the wallet from saved data on storage
   *
   * ```js
   * await wallet.load({
   *   strategy: "encryptedJson",
   *   password: "your-password",
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletLoadOptions` which contains a `strategy` property and other properties depending on the strategy.
   *
   * ### strategy "encryptedJson"
   * Initialize the wallet from encrypted JSON. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to decrypt the encrypted JSON
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * ### strategy "privateKey"
   * Initialize the wallet from a private key. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - optional encryption object of type `DecryptOptions` to decrypt the private key. This is only required if the private key is encrypted.
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * ### strategy "mnemonic"
   * Initialize the wallet from a mnemonic (seed phrase). The `options` object takes the following properties:
   * * `strategy` - must be "mnemonic"
   * * `encryption` - optional encryption object of type `DecryptOptions` to decrypt the mnemonic. This is only required if the mnemonic is encrypted.
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * @returns Promise that resolves to the address of the wallet
   */
  async load(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const walletData = await this.getSavedData(options.storage);
    if (!walletData) {
      throw new Error("No Saved wallet found in storage");
    }
    if (walletData.strategy !== options.strategy) {
      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);
    }
    if (options.strategy === "encryptedJson") {
      return this.import({
        encryptedJson: walletData.data,
        password: options.password
      });
    }
    if (walletData.isEncrypted && !options.encryption) {
      throw new Error("Saved wallet data is encrypted, but no password is provided");
    }
    if (!walletData.isEncrypted && options.encryption) {
      throw new Error("Saved wallet data is not encrypted, but encryption config is provided");
    }
    if (options.strategy === "privateKey") {
      return this.import({
        privateKey: walletData.data,
        encryption: options.encryption
      });
    }
    if (options.strategy === "mnemonic") {
      return this.import({
        mnemonic: walletData.data,
        encryption: options.encryption
      });
    }
    throw new Error("invalid load strategy");
  }
  /**
   * Save the wallet data to storage
   *
   * @example
   * ```javascript
   * wallet.save({
   *   strategy: "encryptedJson",
   *   password: "password",
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletSaveOptions`. It takes a `strategy` property and other properties depending on the strategy.
   *
   * ### strategy "encryptedJson"
   * Save the wallet data as encrypted JSON. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to encrypt the wallet data
   * * `storage` - optional storage to save the wallet data to. Must be of type `AsyncStorage`
   *
   * ### strategy "privateKey"
   * Save the wallet data as a private key. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - optional encryption object of type `EncryptOptions` to encrypt the private key. This is only required if you want to encrypt the private key.
   * * `storage` - optional storage to save the wallet data to. Must be of type `AsyncStorage`
   *
   * ### strategy "mnemonic"
   * Save the wallet data as a mnemonic (seed phrase). The `options` object takes the following properties:
   * * `strategy` - must be "mnemonic"
   * * `encryption` - optional encryption object of type `EncryptOptions` to encrypt the mnemonic. This is only required if you want to encrypt the mnemonic.
   * * `storage` - optional storage to save the wallet data to. Must be of type `AsyncStorage`
   *
   */
  async save(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      const encryptedData = await wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
      await this._saveData({
        address: wallet.address,
        data: encryptedData,
        strategy: "encryptedJson",
        isEncrypted: true
      }, options.storage);
    }
    if (options.strategy === "privateKey") {
      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);
      await this._saveData({
        address: wallet.address,
        data: privateKey,
        strategy: "privateKey",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);
      await this._saveData({
        address: wallet.address,
        data: mnemonic,
        strategy: "mnemonic",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
  }
  /**
   * Check if the wallet data is saved in storage.
   *
   * @returns `true` if initialized wallet's data is saved in storage
   */
  async isSaved() {
    try {
      const data = await this.getSavedData();
      const address = await this.getAddress();
      if ((data == null ? void 0 : data.address) === address) {
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  /**
   * Delete the saved wallet from storage. This action is irreversible, use with caution.
   *
   * @example
   * ```ts
   * await wallet.deleteSaved();
   * ```
   */
  async deleteSaved() {
    await this._storage.removeItem(STORAGE_KEY_WALLET_DATA);
  }
  /**
   * Encrypts the wallet with a password in various formats and return it.
   *
   * @example
   * ```javascript
   * const data = await wallet.export({
   *   strategy: "encryptedJson",
   *   password: "password",
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletExportOptions`. It takes a `strategy` and other properties depending on the strategy.
   *
   * ### strategy - "encryptedJson"
   * Export wallet in encryptedJson format. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to encrypt the wallet data
   *
   * ### strategy - "privateKey"
   * Encrypt the private key of the wallet. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - encryption object of type `EncryptOptions` to encrypt the private key. It takes a `password` property to encrypt the private key and an optional `encrypt` function to encrypt the private key. If `encrypt` function is not provided, it uses the default encryption.
   *
   * ### strategy - "mnemonic"
   * Encrypt the mnemonic (seed phrase) of the wallet. The `options` object takes the following properties:
   * * `strategy` - must be "mnemonic"
   * * `encryption` - encryption object of type `EncryptOptions` to encrypt the mnemonic. It takes a `password` property to encrypt the mnemonic and an optional `encrypt` function to encrypt the mnemonic. If `encrypt` function is not provided, it uses the default encryption.
   *
   * @returns Promise that resolves to a `string` that contains encrypted wallet data
   */
  async export(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      return wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
    }
    if (options.strategy === "privateKey") {
      return getEncryptor(options.encryption)(wallet.privateKey);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);
    }
    throw new Error("Invalid export strategy");
  }
  /**
   * Get the saved wallet data from storage
   * @param storage - storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * @example
   * ```javascript
   * const someStorage = {
   *   getItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   removeItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   setItem: (key, value) => {
   *     // Implement your own storage logic here
   *   },
   * }
   *
   * wallet.getSaved(someStorage);
   * ```
   *
   * @returns `Promise` which resolves to a `WalletData` object containing the wallet data. It returns `null` if no wallet data is found in storage.
   * ```ts
   * {
   *     address: string;
   *     strategy: "mnemonic" | "privateKey" | "encryptedJson";
   *     data: string;
   *     isEncrypted: boolean;
   * }
   * ```
   */
  async getSavedData(storage) {
    const _storage = storage || this._storage;
    try {
      const savedDataStr = await _storage.getItem(STORAGE_KEY_WALLET_DATA);
      if (!savedDataStr) {
        return null;
      }
      const savedData = JSON.parse(savedDataStr);
      if (!savedData) {
        return null;
      }
      return savedData;
    } catch (e) {
      return null;
    }
  }
  /**
   * store the wallet data to storage
   */
  async _saveData(data, storage) {
    const _storage = storage || this._storage;
    await _storage.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data));
  }
  /**
   * Disconnect the wallet
   */
  async disconnect() {
    await super.disconnect();
    this.ethersWallet = void 0;
  }
};
_defineProperty(LocalWallet, "id", walletIds.localWallet);
_defineProperty(LocalWallet, "meta", {
  name: "Local Wallet",
  iconURL: "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg"
});
async function noop(msg) {
  return msg;
}
function getDecryptor(encryption) {
  return encryption ? (msg) => (
    // we're using aesDecryptCompat here because we want to support legacy crypto-js ciphertext for the moment
    (encryption.decrypt || aesDecryptCompat)(msg, encryption.password)
  ) : noop;
}
function getEncryptor(encryption) {
  return encryption ? (msg) => (encryption.encrypt || aesEncrypt)(msg, encryption.password) : noop;
}
function isValidPrivateKey(value) {
  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/signer/dist/thirdweb-dev-wallets-evm-wallets-signer.browser.esm.js
init_lib3();
init_eventemitter3();
var SignerWallet = class extends AbstractClientWallet {
  constructor(options) {
    super("signerWallet", options);
    if (options.clientId && options.chain) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options;
    this.signer = options.signer;
    this._storage = (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SignerConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-signer.browser.esm-2IU7KJHK.js");
      if (!this.signer) {
        this.signer = this.options.signer;
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c7) => updateChainRPCs(c7, this.options.clientId));
      this.connector = new SignerConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        signer: this.signer,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic/dist/thirdweb-dev-wallets-evm-wallets-magic.browser.esm.js
init_eventemitter3();
init_lib3();
var MagicLink = class _MagicLink extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Magic Link";
  }
  /**
   * @internal
   */
  /**
   * Create an instance of the `MagicLink` wallet
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### apiKey (required)
   * Your Magic Link apiKey. You can get an API key by signing up for an account on [Magic Link's website](https://magic.link/).
   *
   * Must be a `string`.
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### type (optional)
   * Whether to use [Magic Auth](https://magic.link/docs/auth/overview) or [Magic Connect](https://magic.link/docs/connect/overview) to connect to the wallet.
   *
   * Default is `"auth"`.
   *
   * ```ts
   * type: "auth" | "connect";
   * ```
   *
   * ### magicSdkConfiguration (optional)
   * Configuration for [Magic Auth](https://magic.link/docs/auth/overview) SDK.
   *
   * This is only relevant if you are using `type: 'auth'`.
   *
   * ```ts
   * {
   *   locale?: string;
   *   endpoint?: string;
   *   testMode?: boolean;
   * }
   * ```
   *
   * * locale (optional) - Customize the language of Magic's modal, email and confirmation screen. See [Localization](https://magic.link/docs/auth/more/customization/localization) for more.
   *
   * * endpoint (optional) - A URL pointing to the Magic iframe application.
   *
   * * testMode (optional) - Enable [testMode](https://magic.link/docs/auth/introduction/test-mode) to assert the desired behavior through the email address so that you don't have to go through the auth flow.
   *
   *
   * ### smsLogin
   * Specify whether you want to allow users to log in with their phone number or not. It is `true` by default
   *
   * This is only relevant if you are using `type: 'auth'`.
   *
   * Must be a `boolean`.
   *
   * ### emailLogin (optional)
   * Specify whether you want to allow users to log in with their email or not. It is `true` by default
   *
   * This is only relevant if you are using `type: 'auth'`.
   *
   * Must be a `boolean`.
   *
   *
   * ### oauthOptions (optional)
   * Specify which oauth providers you support in `providers` array. This is only relevant if you are using `type: 'auth'`.
   *
   * Specify which URI to redirect to after the oauth flow is complete in `redirectURI` option. If no `redirectURI` is specified, the user will be redirected to the current page.
   *
   * You must pass full URL and not just a relative path. For example, `"https://example.com/foo"` is valid but `"/foo"` is not.
   * You can use `new URL("/foo", window.location.origin).href` to get the full URL from a relative path based on the current origin.
   *
   * You also need to enable the oauth providers for your apiKey from [Magic dashboard](https://dashboard.magic.link/).
   *
   * ```ts
   * type OauthOptions = {
   *   redirectURI?: string;
   *   providers: OauthProvider[];
   * };
   *
   * type OauthProvider =
   *   | "google"
   *   | "facebook"
   *   | "apple"
   *   | "github"
   *   | "bitbucket"
   *   | "gitlab"
   *   | "linkedin"
   *   | "twitter"
   *   | "discord"
   *   | "twitch"
   *   | "microsoft";
   * ```
   *
   * ```ts
   * const wallet = new MagicLink({
   *   apiKey: "YOUR_API_KEY",
   *   type: "auth",
   *   // specify which Oauth providers to enable
   *   oauthOptions: {
   *     redirectURI: new URL("/foo", window.location.origin).href,
   *     providers: ["google", "facebook", "github", "bitbucket"],
   *   },
   * });
   * ```
   *
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   */
  constructor(options) {
    super(_MagicLink.id, options);
    this.options = options;
  }
  /**
   * @internal
   */
  async initializeConnector() {
    const {
      MagicAuthConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-magic.browser.esm-O7MHK4VX.js");
    const magicConnector = new MagicAuthConnector({
      chains: this.chains,
      options: this.options
    });
    this.magicConnector = magicConnector;
    this.connector = new WagmiAdapter(magicConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initializeConnector();
    }
    return this.connector;
  }
  /**
   * Get Magic Auth SDK instance. Learn more about [Magic Auth SDK](https://magic.link/docs/auth/overview)
   *
   * you use all methods available in the Magic Auth SDK from the SDK instance. Refer to [Magic Auth API](https://magic.link/docs/auth/api-reference/client-side-sdks/web) for more details.
   *
   * ```javascript
   * const magicSDK = await wallet.getMagic();
   * ```
   */
  getMagic() {
    if (!this.magicConnector) {
      throw new Error("Magic connector is not initialized");
    }
    return this.magicConnector.getMagicSDK();
  }
  /**
   * Auto connect wallet if the user is already logged in.
   * @returns
   */
  async autoConnect(options) {
    var _a2;
    await this.initializeConnector();
    await ((_a2 = this.magicConnector) == null ? void 0 : _a2.initializeMagicSDK(options));
    const magic = this.getMagic();
    {
      const url = new URL(window.location.href);
      const isMagicRedirect = url.searchParams.get("magic_credential");
      if (isMagicRedirect) {
        try {
          this.oAuthRedirectResult = await magic.oauth.getRedirectResult();
        } catch {
        }
      }
    }
    const isLoggedIn = await magic.user.isLoggedIn();
    if (isLoggedIn) {
      return super.autoConnect(options);
    }
    throw new Error("Magic user is not logged in");
  }
  /**
   * Disconnect wallet
   */
  async disconnect() {
    this.oAuthRedirectResult = void 0;
    const magic = this.getMagic();
    await magic.user.logout();
    return super.disconnect();
  }
  /**
   * Connect Wallet using Magic Auth or Magic Connect
   *
   * ### Magic Auth
   * There are three ways to call the `connect` function - `email` or `phoneNumber` or `oauthProvider`
   *
   * #### email
   * This opens the Magic Link's Modal and prompts the user to click on the link sent to their email.
   *
   * ```ts
   * await wallet.connect({
   *   email: "user@example.com",
   * });
   * ```
   *
   * #### phoneNumber
   * This opens the Magic Link's Modal and prompts the user to enter the OTP sent to their phone via SMS.
   *
   * ```ts
   * await wallet.connect({
   *   phoneNumber: "+123456789",
   * });
   * ```
   *
   * #### oauthProvider
   * This redirects the user to given provider's sign-in page and once the user is authenticated, it redirects the user back to the `redirectURI` provided in `MagicLink` constructor.
   *
   * ```ts
   * await magic.connect({
   *   oauthProvider: "google",
   * });
   * ```
   *
   * #### Additional Configuration
   *
   * ```typescript
   * wallet.connect({
   *   chainId: 5,
   * });
   * ```
   *
   * If `chainId` is provided, the wallet will be connected to the network with the given chainId, else it will be connected to the Ethereum Mainnet.
   *
   * ### Magic Connect
   * You can call the `connect` function without any arguments. Calling `connect` opens the Magic Link's Modal and prompts the user to login via Google or email.
   *
   * ```ts
   * await wallet.connect();
   * ```
   *
   * #### Additional Configuration
   *
   * ```typescript
   * wallet.connect({
   *   chainId: 5,
   * });
   * ```
   *
   * If `chainId` is provided, the wallet will be connected to the network with the given chainId, else it will be connected to the Ethereum Mainnet.
   *
   * @param options - The `options` object can include the following properties:
   * ### Magic Auth
   * If you are using `type: 'auth'`, you can pass any one of the following properties
   * - `email` - The email address of the user
   * - `phoneNumber` - The phone number of the user
   * - `oauthProvider` - The oauth provider to use for login
   *
   * ### Magic Connect
   * If you are using `type: 'connect'`, you don't need to pass any arguments to `connect` function.
   *
   * @returns
   */
  async connect(options) {
    if ("email" in options && this.options.emailLogin === false) {
      throw new Error("Email login is disabled");
    }
    if ("phoneNumber" in options && this.options.smsLogin === false) {
      throw new Error("SMS login is disabled");
    }
    return super.connect(options);
  }
};
_defineProperty(MagicLink, "meta", {
  iconURL: "ipfs://QmUMBFZGXxBpgDmZzZAHhbcCL5nYvZnVaYLTajsNjLcxMU/1-Icon_Magic_Color.svg",
  name: "Magic Link"
});
_defineProperty(MagicLink, "id", walletIds.magicLink);

// node_modules/@thirdweb-dev/wallets/evm/wallets/xdefi/dist/thirdweb-dev-wallets-evm-wallets-xdefi.browser.esm.js
init_eventemitter3();
init_lib3();
var XDEFIWallet = class _XDEFIWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "XDEFI";
  }
  /**
   * Create instance of `XDEFIWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { XDEFIWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new XDEFIWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_XDEFIWallet.id, options);
    this.isInjected = !!getInjectedXDEFIProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        XDEFIConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-xdefi.browser.esm-62YAQK6K.js");
      const connector = new XDEFIConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.connector = new WagmiAdapter(connector);
    }
    return this.connector;
  }
};
_defineProperty(XDEFIWallet, "id", walletIds.xdefi);

// node_modules/@thirdweb-dev/wallets/evm/wallets/phantom/dist/thirdweb-dev-wallets-evm-wallets-phantom.browser.esm.js
init_eventemitter3();
init_lib3();
var PhantomWallet = class _PhantomWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Phantom";
  }
  /**
   * Create a `PhantomWallet` instance
   * @param options -
   * The `options` object includes the following properties
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { PhantomWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new PhantomWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_PhantomWallet.id, options);
    this.isInjected = !!getInjectedPhantomProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        PhantomConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-phantom.browser.esm-C44WVHK2.js");
      const phantomConnector = new PhantomConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.phantomConnector = phantomConnector;
      this.connector = new WagmiAdapter(phantomConnector);
    }
    return this.connector;
  }
};
_defineProperty(PhantomWallet, "meta", {
  name: "Phantom",
  iconURL: "ipfs://bafybeibkpca5nwxpsjrtuxmz2ckb5lyc2sl2abg5f7dnvxku637vvffjti",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa"
    // not specifiying theme because they can't be used to connect
    // android: "https://play.google.com/store/apps/details?id=app.phantom",
    // ios: "https://apps.apple.com/us/app/phantom-crypto-wallet/id1598432977",
  }
});
_defineProperty(PhantomWallet, "id", walletIds.phantom);

// node_modules/@thirdweb-dev/wallets/evm/wallets/private-key/dist/thirdweb-dev-wallets-evm-wallets-private-key.browser.esm.js
init_lib3();
init_eventemitter3();
var PrivateKeyWallet = class extends AbstractWallet {
  /**
   * Create instance of `PrivateKeyWallet`
   *
   * @param privateKey - The private key to use for signing transactions.
   *
   * @param chain - The chain or rpc url to connect to when querying the blockchain directly through this wallet.
   *
   * @param secretKey -
   * Provide `secretKey` to use the thirdweb RPCs for given `chain`
   *
   * You can create a secret key from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   */
  constructor(privateKey, chain, secretKey) {
    super();
    this._signer = new ethers_exports.Wallet(privateKey, chain ? getChainProvider(chain, {
      secretKey
    }) : void 0);
  }
  /**
   * Get the [ethers.js signer](https://docs.ethers.io/v5/api/signer/) object used by the wallet
   */
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/rainbow-wallet/dist/thirdweb-dev-wallets-evm-wallets-rainbow-wallet.browser.esm.js
init_eventemitter3();
init_lib3();
var RainbowWallet = class _RainbowWallet extends AbstractClientWallet {
  get walletName() {
    return "Rainbow Wallet";
  }
  constructor(options) {
    super(_RainbowWallet.id, options);
    this.isInjected = !!getInjectedRainbowProvider();
  }
  async getConnector() {
    var _a2, _b, _c2;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RainbowConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rainbow.browser.esm-OLS4DVFN.js");
        const rainbowConnector = new RainbowConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.rainbowConnector = rainbowConnector;
        this.connector = new WagmiAdapter(rainbowConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-NCWN2W7X.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a2 = this.options) == null ? void 0 : _a2.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c2 = this.options) == null ? void 0 : _c2.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * connect to wallet with QR code
   *
   * @example
   * ```typescript
   * rainbow.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RainbowWallet, "meta", {
  name: "Rainbow Wallet",
  iconURL: "ipfs://QmSZn47p4DVVBfzvg9BAX2EqwnPxkT1YAE7rUnrtd9CybQ/rainbow-logo.png",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/rainbow/opfgelmcmbiajamepnmloijbpoleiama",
    android: "https://rnbwapp.com/e/Va41HWS6Oxb",
    ios: "https://rnbwapp.com/e/OeMdmkJ6Oxb"
  }
});
_defineProperty(RainbowWallet, "id", walletIds.rainbow);

// node_modules/@thirdweb-dev/wallets/evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.browser.esm.js
init_lib3();
init_eventemitter3();
var SafeWallet = class _SafeWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Safe Wallet";
  }
  /**
   * Create a `SafeWallet` instance.
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   *
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   *
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { SafeWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new SafeWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   }
   * });
   * ```
   *
   */
  constructor(options) {
    super(_SafeWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SafeConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-safe.browser.esm-ASII7F7H.js");
      this.connector = new SafeConnector();
    }
    return this.connector;
  }
  /**
   * Get the personal wallet that is connected to the Safe wallet.
   * @returns
   */
  getPersonalWallet() {
    var _a2;
    return (_a2 = this.connector) == null ? void 0 : _a2.personalWallet;
  }
  /**
   * Auto connect the wallet if it was previously connected.
   */
  autoConnect(params) {
    return this.connect(params);
  }
  /**
   * Connect Safe wallet
   * @param connectOptions -
   * The `connectOptions` object includes the following properties:
   *
   * @example
   * ```javascript
   * import { CoinbaseWallet, SafeWallet } from "@thirdweb-dev/wallets";
   * import { Ethereum } from "@thirdweb-dev/chains";
   *
   * // First, connect the personal wallet
   * const personalWallet = new CoinbaseWallet();
   * await personalWallet.connect();
   *
   * // Then, connect the Safe wallet
   * const wallet = new SafeWallet();
   * await wallet.connect({
   *   personalWallet: personalWallet, // Wallet that can sign transactions on the Safe
   *   chain: Ethereum, // Chain that the Safe is on
   *   safeAddress: "{{contract_address}}", // Smart contract address of the Safe
   * });
   * ```
   *
   * ### personalWallet
   *
   * The instance of a personal wallet that can sign transactions on the Safe.
   *
   * Must be of type `EVMWallet` such as [`CoinbaseWallet`](/wallet/coinbase-wallet) or [`MetamaskWallet`](/wallet/metamask).
   *
   * ### chain
   *
   * The chain that the Safe smart contract is deployed to.
   *
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * ### safeAddress
   *
   * Smart contract address of the Safe wallet.
   *
   * Must be a `string`.
   *
   * @returns A Promise that resolves to the Safe address.
   */
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(SafeWallet, "meta", {
  name: "Safe",
  iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
});
_defineProperty(SafeWallet, "id", walletIds.safe);

// node_modules/@thirdweb-dev/wallets/evm/wallets/smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-smart-wallet.browser.esm.js
init_lib3();
var import_contracts = __toESM(require_dist());
init_eventemitter3();
var sdkCache = /* @__PURE__ */ new Map();
function getSDK(chain) {
  const cached = sdkCache.get(chain);
  if (cached) {
    return cached;
  }
  const sdk = new ThirdwebSDK(chain);
  sdkCache.set(chain, sdk);
  return sdk;
}
async function getAllSigners(chain, factoryAddress, smartWalletAddress) {
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const signers = await factoryContract.call("getSignersOfAccount", [smartWalletAddress]);
  return signers;
}
async function getAllSmartWallets(chain, factoryAddress, personalWalletAddress) {
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const ownedAccount = await getSmartWalletAddress(chain, factoryAddress, personalWalletAddress);
  const accessibleAccounts = await factoryContract.call("getAccountsOfSigner", [personalWalletAddress]);
  return {
    owned: ownedAccount,
    hasSignerRole: accessibleAccounts
  };
}
async function isSmartWalletDeployed(chain, factoryAddress, personalWalletAddress) {
  let data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "0x";
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const accountAddress = await factoryContract.call("getAddress", [personalWalletAddress, data]);
  const isDeployed = await isContractDeployed(accountAddress, readOnlySDK.getProvider());
  return isDeployed;
}
async function getSmartWalletAddress(chain, factoryAddress, personalWalletAddress) {
  let data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "0x";
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const accountAddress = await factoryContract.call("getAddress", [personalWalletAddress, data]);
  return accountAddress;
}
async function getUserOpReceipt(chain, userOpHash) {
  let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3e4;
  let interval = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 2e3;
  let entryPointAddress = arguments.length > 4 ? arguments[4] : void 0;
  const readOnlySDK = getSDK(chain);
  const entrypoint = await readOnlySDK.getContract(entryPointAddress || ENTRYPOINT_ADDRESS, import_contracts.EntryPoint__factory.abi);
  const pastEvents = await entrypoint.events.getEvents("UserOperationEvent", {
    fromBlock: -9e3,
    // look at the last 9000 blocks
    filters: {
      userOpHash
    }
  });
  if (pastEvents[0]) {
    return pastEvents[0].transaction.transactionHash;
  }
  const endtime = Date.now() + timeout;
  while (Date.now() < endtime) {
    const events = await entrypoint.events.getEvents("UserOperationEvent", {
      fromBlock: -100,
      filters: {
        userOpHash
      }
    });
    if (events[0]) {
      return events[0].transaction.transactionHash;
    }
    await new Promise((resolve) => setTimeout(resolve, interval));
  }
  return null;
}
var SmartWallet = class _SmartWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Smart Wallet";
  }
  /**
   *
   * @param options - The `options` object includes the following properties:
   * ### Required Properties
   *
   * #### chain
   * The chain that the Smart Wallet contract is deployed to.
   *
   * Either a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package, a chain name, or an RPC URL.
   *
   *
   * #### factoryAddress
   * The address of the Smart Wallet Factory contract.
   *
   * Must be a `string`.
   *
   *
   * #### gasless
   * Whether to turn on or off gasless transactions.
   *
   * - If set to `true`, all gas fees will be paid by a paymaster.
   * - If set to `false`, all gas fees will be paid by the Smart Wallet itself (needs to be funded).
   *
   * Must be a `boolean`.
   *
   *
   * ### Optional properties
   *
   * #### clientId or secretKey (recommended)
   * Your API key can be obtained from the [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * If you're using your own bundler and paymaster, you can set this to an empty string.
   *
   * You can use either the `clientId` or the `secretKey` depending on whether your application is client or server side.
   *
   * Must be a `string`.
   *
   * #### factoryInfo
   * Customize how the Smart Wallet Factory contract is interacted with. If not provided, the default functions will be used.
   *
   * Must be a `object`. The object can contain the following properties:
   *
   * - `createAccount` - a function that returns the transaction object to create a new Smart Wallet.
   * - `getAccountAddress` - a function that returns the address of the Smart Wallet contract given the owner address.
   * - `abi` - optional ABI. If not provided, the ABI will be auto-resolved.
   *
   * ```javascript
   *  const config: SmartWalletConfig = {
   *       chain,
   *       gasless,
   *       factoryAddress,
   *       clientId,
   *       factoryInfo: {
   *         createAccount: async (factory, owner) => {
   *           return factory.prepare("customCreateAccount", [
   *             owner,
   *             getExtraData(),
   *           ]);
   *         },
   *         getAccountAddress: async (factory, owner) => {
   *           return factory.call("getAccountAddress", [owner]);
   *         },
   *         abi: [...]
   *       },
   *     };
   * ```
   *
   *
   * #### accountInfo
   * Customize how the Smart Wallet Account contract is interacted with. If not provided, the default functions will be used.
   *
   * Must be a `object`. The object can contain the following properties:
   *
   * - `execute` - a function that returns the transaction object to execute an arbitrary transaction.
   * - `getNonce` - a function that returns the current nonce of the account.
   * - `abi` - optional ABI. If not provided, the ABI will be auto-resolved.
   *
   * ```javascript
   *  const config: SmartWalletConfig = {
   *       chain,
   *       gasless,
   *       factoryAddress,
   *       clientId,
   *       accountInfo: {
   *         execute: async (account, target, value, data) => {
   *           return account.prepare("customExecute", [
   *             target, value, data
   *           ]);
   *         },
   *         getNonce: async (account) => {
   *           return account.call("getNonce");
   *         },
   *         abi: [...]
   *       },
   *     };
   * ```
   *
   * #### bundlerUrl
   * Your own bundler URL to send user operations to. Uses thirdweb's bundler by default.
   *
   * Must be a `string`.
   *
   * #### paymasterUrl
   * Your own paymaster URL to send user operations to for gasless transactions. Uses thirdweb's paymaster by default.
   *
   * Must be a `string`.
   *
   * #### paymasterAPI
   * Fully customize how the paymaster data is computed.
   *
   * Must be a `PaymasterAPI` class.
   *
   * ```javascript
   * class MyPaymaster extends PaymasterAPI {
   *   async getPaymasterAndData(
   *     userOp: Partial<UserOperationStruct>,
   *   ): Promise<string> {
   *     // your implementation, must return the signed paymaster data
   *   }
   * }
   *
   * const config: SmartWalletConfig = {
   *   chain,
   *   gasless,
   *   factoryAddress,
   *   clientId,
   *   // highlight-start
   *   paymasterAPI: new MyPaymaster(),
   *   // highlight-end
   * };
   * ```
   *
   *
   * #### entryPointAddress
   * The entrypoint contract address. Uses v0.6 by default.
   *
   * Must be a `string`.
   *
   * #### deployOnSign
   * Whether to deploy the smart wallet when the user signs a message. Defaults to true.
   *
   * Must be a `boolean`.
   *
   * #### chains
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to thirdweb's [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * #### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url` and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { SmartWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new SmartWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp", // optional
   *     logoUrl: "https://thirdweb.com/favicon.ico", // optional
   *   },
   * });
   * ```
   *
   */
  constructor(options) {
    if (options.clientId && typeof options.chain === "object") {
      try {
        options.chain = {
          ...options.chain,
          rpc: getValidChainRPCs(options.chain, options.clientId)
        };
      } catch {
      }
    }
    super(_SmartWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm-DOFEURNE.js");
      this.connector = new SmartWalletConnector(this.options);
    }
    return this.connector;
  }
  /**
   * Get the personal wallet that is connected to the Smart Wallet.
   * @example
   * ```ts
   * const personalWallet = wallet.getPersonalWallet();
   * ```
   */
  getPersonalWallet() {
    var _a2;
    return (_a2 = this.connector) == null ? void 0 : _a2.personalWallet;
  }
  /**
   * Check whether the connected signer can execute a given transaction using the smart wallet.
   * @param transaction - The transaction to execute using the smart wallet.
   * @returns `Promise<true>` if connected signer can execute the transaction using the smart wallet.
   */
  async hasPermissionToExecute(transaction) {
    const connector = await this.getConnector();
    return connector.hasPermissionToExecute(transaction);
  }
  /**
   * Send a single transaction without waiting for confirmations
   * @param transaction - the transaction to send
   * @param options - optional transaction options
   * @returns The transaction result
   */
  async send(transaction, options) {
    const connector = await this.getConnector();
    return connector.send(transaction, options);
  }
  /**
   * Execute a single transaction and wait for confirmations
   *
   * @example
   * ```javascript
   * const transaction = prepareTransaction();
   * await wallet.execute(transaction);
   * ```
   *
   * @param transaction -
   * The transaction to execute. Must be of type `Transaction` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * Creating these transactions can be done easily using the [Transaction Builder](https://portal.thirdweb.com/typescript/v4/interact#prepare) from the thirdweb SDK.
   * @param options - optional transaction options
   * @returns `TransactionResult` containing the transaction receipt.
   */
  async execute(transaction, options) {
    const connector = await this.getConnector();
    return connector.execute(transaction, options);
  }
  /**
   * Send a multiple transaction in a batch without waiting for confirmations
   * @param transactions -
   * An array of transactions to send. Must be of type `Transaction[]` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * Creating these transactions can be done easily using the [Transaction Builder](typescript/sdk.smartcontract.prepare) from the thirdweb SDK.
   * @param options - optional transaction options
   * @returns `TransactionResult` containing the transaction receipt.
   */
  async sendBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.sendBatch(transactions, options);
  }
  /**
   * Execute multiple transactions in a single batch and wait for confirmations, only requiring one signature from the personal wallet.
   *
   * ```javascript
   * // Then you can execute multiple transactions at once
   * const transactions = [
   *   prepareTransaction1(),
   *   prepareTransaction2(),
   *   prepareTransaction3(),
   * ];
   * await wallet.executeBatch(transactions);
   * ```
   *
   * @param transactions -
   * An array of transactions to execute. Must be of type `Transaction[]` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * Creating these transactions can be done easily using the [Transaction Builder](typescript/sdk.smartcontract.prepare) from the thirdweb SDK.
   *
   * @param options - optional transaction options
   * @returns `TransactionResult` containing the transaction receipt.
   */
  async executeBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.executeBatch(transactions, options);
  }
  /**
   * Send a single raw transaction without waiting for confirmations
   * @param transaction - the transaction to send
   * @param options - optional transaction options
   * @returns The transaction result
   */
  async sendRaw(transaction, options) {
    const connector = await this.getConnector();
    return connector.sendRaw(transaction, options);
  }
  /**
   * Execute a single raw transaction and wait for confirmations
   * @param transaction - the transaction to execute
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async executeRaw(transaction, options) {
    const connector = await this.getConnector();
    return connector.executeRaw(transaction, options);
  }
  /**
   * Estimate the gas cost of a single transaction
   * @param transaction - the transaction to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimate(transaction, options) {
    const connector = await this.getConnector();
    return connector.estimate(transaction, options);
  }
  /**
   * Estimate the gas cost of a batch of transactions
   * @param transactions - the transactions to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimateBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateBatch(transactions, options);
  }
  /**
   * Estimate the gas cost of a single raw transaction
   * @param transactions - the transactions to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimateRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateRaw(transactions, options);
  }
  /**
   * Estimate the gas cost of a batch of raw transactions
   * @param transactions - the transactions to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimateBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateBatchRaw(transactions, options);
  }
  /**
   * Send multiple raw transaction in a batch without waiting for confirmations
   * @param transactions - the transactions to send
   * @param options - optional transaction options
   * @returns The transaction result
   */
  async sendBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.sendBatchRaw(transactions, options);
  }
  /**
   * Execute multiple raw transactions in a single batch and wait for confirmations
   * @param transactions - the transactions to execute
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async executeBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.executeBatchRaw(transactions, options);
  }
  /**
   * Manually deploy the smart wallet contract. If already deployed this will throw an error.
   *
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   *
   * @example
   * ```ts
   * const tx = await wallet.deploy();
   * ```
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async deploy(options) {
    const connector = await this.getConnector();
    return connector.deploy(options);
  }
  /**
   * Manually deploy the smart wallet contract. If already deployed this will do nothing.
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   *
   * @example
   * ```ts
   * await wallet.deployIfNeeded();
   * ```
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async deployIfNeeded(options) {
    const connector = await this.getConnector();
    return connector.deployIfNeeded(options);
  }
  /**
   * Check if the smart wallet contract is deployed
   * @example
   * ```ts
   * const isDeployed = await wallet.isDeployed();
   * ```
   *
   * @returns `true` if the smart wallet contract is deployed
   */
  async isDeployed() {
    const connector = await this.getConnector();
    return connector.isDeployed();
  }
  /**
   * Create and add a session key to the Smart Wallet with specific permissions.
   * @example
   * ```javascript
   * // Then you can add session keys with permissions
   * await wallet.createSessionKey(
   *   "0x...", // the session key address
   *   {
   *       approvedCallTargets: ["0x..."], // the addresses of contracts that the session key can call
   *       nativeTokenLimitPerTransaction: 0.1, // the maximum amount of native token (in ETH) that the session key can spend per transaction
   *       startDate: new Date(), // the date when the session key becomes active
   *       expirationDate = new Date(Date.now() + 24 * 60 * 60 * 1000); // the date when the session key expires
   *   }
   * );
   * ```
   *
   * @param keyAddress - The address of the session key to add to the Smart Wallet.
   *
   * @param permissions -
   * The specific permissions to give to the session key.
   * Must be of type `SignerPermissionsInput` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * ```typescript
   * {
   *   startDate: Date;
   *   expirationDate: Date;
   *   nativeTokenLimitPerTransaction: number;
   *   approvedCallTargets: string[];
   * }
   * ```
   */
  async createSessionKey(keyAddress, permissions) {
    const connector = await this.getConnector();
    return connector.grantPermissions(keyAddress, permissions);
  }
  /**
   * Revoke a session key from the Smart Wallet.
   * @example
   * ```javascript
   * await wallet.revokeSessionKey(
   *   "0x...", // the session key address
   * );
   * ```
   *
   * @param keyAddress - The address of the session key to revoke.
   */
  async revokeSessionKey(keyAddress) {
    const connector = await this.getConnector();
    return connector.revokePermissions(keyAddress);
  }
  /**
   * Add another admin to the smart wallet.
   * @param adminAddress - The address of the admin to add.
   */
  async addAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.addAdmin(adminAddress);
  }
  /**
   * Remove an admin from the smart wallet.
   * @param adminAddress - The address of the admin to remove.
   */
  async removeAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.removeAdmin(adminAddress);
  }
  /**
   * Get all the admins and session keys active on the smart wallet.
   */
  async getAllActiveSigners() {
    const connector = await this.getConnector();
    return connector.getAllActiveSigners();
  }
  /**
   * Get the underlying account contract of the smart wallet.
   * @returns The account contract of the smart wallet.
   */
  async getAccountContract() {
    const connector = await this.getConnector();
    return connector.getAccountContract();
  }
  /**
   * Get the underlying account factory contract of the smart wallet.
   * @returns The account factory contract.
   */
  async getFactoryContract() {
    const connector = await this.getConnector();
    return connector.getFactoryContract();
  }
  async verifySignature(message, signature, address, chainId) {
    var _a2, _b;
    try {
      const messageHash = utils_exports.hashMessage(message);
      const messageHashBytes = utils_exports.arrayify(messageHash);
      const recoveredAddress = utils_exports.recoverAddress(messageHashBytes, signature);
      if (recoveredAddress === address) {
        return true;
      }
    } catch {
    }
    if (chainId !== void 0) {
      try {
        return await checkContractWalletSignature(message, signature, address, chainId || 1, (_a2 = this.options) == null ? void 0 : _a2.clientId, (_b = this.options) == null ? void 0 : _b.secretKey);
      } catch {
      }
    }
    return false;
  }
  autoConnect(params) {
    return this.connect(params);
  }
  /**
   * Connect the SmartWallet with given personalWallet
   * @param connectOptions -
   * The `connectOptions` object includes the following properties:
   *
   * #### personalWallet
   * The instance of a personal wallet that can sign transactions on the Smart Wallet.
   * Must be of type `EVMWallet` instance such as `CoinbaseWallet` or `MetamaskWallet`.
   *
   * @returns A Promise that resolves to the address of the Smart Wallet.
   */
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(SmartWallet, "meta", {
  name: "Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(SmartWallet, "id", walletIds.smartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/trust/dist/thirdweb-dev-wallets-evm-wallets-trust.browser.esm.js
init_eventemitter3();
init_lib3();
var TrustWallet = class _TrustWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Trust Wallet";
  }
  /**
   * Create instance of `TrustWallet`
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    var _a2;
    super(_TrustWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a2 = globalThis.window.ethereum) == null ? void 0 : _a2.isTrust);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a2, _b, _c2;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          TrustConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-trust.browser.esm-3CRPCYFQ.js");
        const trustConnector = new TrustConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.trustConnector = trustConnector;
        this.connector = new WagmiAdapter(trustConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-NCWN2W7X.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a2 = this.options) == null ? void 0 : _a2.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c2 = this.options) == null ? void 0 : _c2.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Trust Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(TrustWallet, "meta", {
  name: "Trust Wallet",
  iconURL: "ipfs://QmNigQbXk7wKZwDcgN38Znj1ZZQ3JEG3DD6fUKLBU8SUTP/trust%20wallet.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph",
    android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
    ios: "https://apps.apple.com/us/app/trust-crypto-bitcoin-wallet/id1288339409"
  }
});
_defineProperty(TrustWallet, "id", walletIds.trust);

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.browser.esm.js
init_eventemitter3();
init_lib3();
var WalletConnect = class _WalletConnect extends AbstractClientWallet {
  get walletName() {
    return "WalletConnect";
  }
  /**
   *
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### projectId (recommended)
   * Your project's unique identifier. It can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * It enables the following functionalities within WalletConnect's web3modal:
   *
   * - wallet and chain logos
   * - optional WalletConnect RPC
   * - support for all wallets from our Explorer and WalletConnect v2 support
   *
   * Defaults to thirdweb's common project id.
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   *
   * ### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { WalletConnect } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new WalletConnect({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### qrcode (optional)
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || _WalletConnect.id, options);
    _defineProperty(this, "_maybeThrowError", (error) => {
      if (error) {
        throw error;
      }
    });
    _defineProperty(this, "_onConnect", (data) => {
      this._provider = data.provider;
      if (!this._provider) {
        throw new Error("WalletConnect provider not found after connecting.");
      }
    });
    _defineProperty(this, "_onDisconnect", () => {
      this._removeListeners();
    });
    _defineProperty(this, "_onChange", async (payload) => {
      if (payload.chain) ;
      else if (payload.account) ;
    });
    _defineProperty(this, "_onMessage", (payload) => {
      switch (payload.type) {
        case "display_uri":
          this.emit("display_uri", payload.data);
          break;
      }
    });
    _defineProperty(this, "_onSessionRequestSent", () => {
      this.emit("wc_session_request_sent");
    });
    this.projectId = (options == null ? void 0 : options.projectId) || TW_WC_PROJECT_ID;
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    var _a2;
    if (!this.connector) {
      const {
        WalletConnectConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-NCWN2W7X.js");
      this._walletConnectConnector = new WalletConnectConnector({
        chains: this.chains,
        options: {
          qrcode: this.qrcode,
          projectId: this.projectId,
          dappMetadata: this.dappMetadata,
          storage: this.walletStorage,
          qrModalOptions: (_a2 = this.options) == null ? void 0 : _a2.qrModalOptions
        }
      });
      this.connector = new WagmiAdapter(this._walletConnectConnector);
      this._provider = await this._walletConnectConnector.getProvider();
      this._setupListeners();
    }
    return this.connector;
  }
  _setupListeners() {
    var _a2;
    if (!this._walletConnectConnector) {
      return;
    }
    this._removeListeners();
    this._walletConnectConnector.on("connect", this._onConnect);
    this._walletConnectConnector.on("disconnect", this._onDisconnect);
    this._walletConnectConnector.on("change", this._onChange);
    this._walletConnectConnector.on("message", this._onMessage);
    (_a2 = this._provider) == null ? void 0 : _a2.signer.client.on("session_request_sent", this._onSessionRequestSent);
  }
  _removeListeners() {
    var _a2;
    if (!this._walletConnectConnector) {
      return;
    }
    this._walletConnectConnector.removeListener("connect", this._onConnect);
    this._walletConnectConnector.removeListener("disconnect", this._onDisconnect);
    this._walletConnectConnector.removeListener("change", this._onChange);
    this._walletConnectConnector.removeListener("message", this._onMessage);
    (_a2 = this._provider) == null ? void 0 : _a2.signer.client.removeListener("session_request_sent", this._onSessionRequestSent);
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. User can scan this QR code from the Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this._walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    wcConnector.showWalletConnectModal = false;
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  /**
   * @internal
   */
  async connectWithModal(options) {
    await this.getConnector();
    const wcConnector = this._walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    wcConnector.showWalletConnectModal = true;
    await wcConnector.initProvider();
    await this.connect({
      chainId: options == null ? void 0 : options.chainId
    });
  }
};
_defineProperty(WalletConnect, "id", walletIds.walletConnect);
_defineProperty(WalletConnect, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.browser.esm.js
init_eventemitter3();
init_lib3();
var WalletConnectV1 = WalletConnect;

// node_modules/@thirdweb-dev/wallets/evm/wallets/zerion/dist/thirdweb-dev-wallets-evm-wallets-zerion.browser.esm.js
init_eventemitter3();
init_lib3();
var ZerionWallet = class _ZerionWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Zerion Wallet";
  }
  /**
   * Create an instance of `ZerionWallet`.
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   *
   * ### projectId (recommended)
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### qrcode
   * Whether to open the default Wallet Connect QR code Modal for connecting to Zerion Wallet on mobile
   * (if Zerion is not injected when calling `connect()`).
   *
   * Must be a `boolean`. Defaults to `false`.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   * ```javascript
   * import { ZerionWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new ZerionWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   */
  constructor(options) {
    var _a2;
    super(_ZerionWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a2 = globalThis.window.ethereum) == null ? void 0 : _a2.isZerion);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a2, _b, _c2;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ZerionConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-zerion.browser.esm-QC7VEK2Z.js");
        const zerionConnector = new ZerionConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.zerionConnector = zerionConnector;
        this.connector = new WagmiAdapter(zerionConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-NCWN2W7X.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a2 = this.options) == null ? void 0 : _a2.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c2 = this.options) == null ? void 0 : _c2.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Zerion Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ZerionWallet, "id", "zerion");
_defineProperty(ZerionWallet, "meta", {
  name: "Zerion Wallet",
  iconURL: "ipfs://Qmb1LhNtMUkzbgk1V8ZiUSRXjMJGRkS5HH3R71KyRgjdBG/zerion.png",
  urls: {
    chrome: "https://zerion.io/extension",
    android: "https://link.zerion.io/901o6IN0jqb",
    ios: "https://link.zerion.io/a11o6IN0jqb"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-token-bound-smart-wallet.browser.esm.js
init_lib3();
init_eventemitter3();
var import_contracts2 = __toESM(require_dist());
var TokenBoundSmartWallet = class extends SmartWallet {
  get walletName() {
    return "Token Bound Smart Wallet";
  }
  constructor(options) {
    super({
      ...options,
      factoryAddress: options.registryAddress || ERC6551_REGISTRY
    });
    this.tbaOptions = options;
  }
  async getConnector() {
    if (!this.tbaConnector) {
      const {
        TokenBoundSmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-token-bound-smart-wallet.browser.esm-T2L57DU7.js");
      this.tbaConnector = new TokenBoundSmartWalletConnector(this.tbaOptions);
    }
    return this.tbaConnector;
  }
};
_defineProperty(TokenBoundSmartWallet, "meta", {
  name: "Token Bound Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(TokenBoundSmartWallet, "id", walletIds.tokenBoundSmartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic-eden/dist/thirdweb-dev-wallets-evm-wallets-magic-eden.browser.esm.js
init_eventemitter3();
init_lib3();
var MagicEdenWallet = class _MagicEdenWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Magic Eden";
  }
  /**
   * Create instance of `MagicEdenWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { MagicEdenWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new MagicEdenWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_MagicEdenWallet.id, options);
    this.isInjected = !!getInjectedMagicEdenProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        MagicEdenConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-magic-eden.browser.esm-DTAKPIFS.js");
      const connector = new MagicEdenConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.connector = new WagmiAdapter(connector);
    }
    return this.connector;
  }
};
_defineProperty(MagicEdenWallet, "id", walletIds.magicEden);

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
var import_buffer2 = __toESM(require_buffer());
var import_contracts3 = __toESM(require_dist());
var import_utils6 = __toESM(require_utils());
var PREFIX2 = "__TW__";
var LocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return localStorage.getItem(`${PREFIX2}/${this.name}/${key}`);
  }
  setItem(key, value) {
    return localStorage.setItem(`${PREFIX2}/${this.name}/${key}`, value);
  }
  removeItem(key) {
    return localStorage.removeItem(`${PREFIX2}/${this.name}/${key}`);
  }
};
function createLocalStorage(name) {
  return new LocalStorage(name);
}
var WalletConnectHandler = class extends eventemitter3_default {
  constructor(wallet) {
    super();
    this.wallet = wallet;
  }
};
var WalletConnectV2Handler = class extends WalletConnectHandler {
  constructor(options, wallet) {
    super(wallet);
    const defaultWCReceiverConfig = {
      walletConnectWalletMetadata: {
        name: "thirdweb Smart Account",
        description: "thirdweb Smart Account",
        url: "https://thirdweb.com",
        icons: ["https://thirdweb.com/favicon.ico"]
      },
      walletConnectV2ProjectId: TW_WC_PROJECT_ID,
      walletConnectV2RelayUrl: WC_RELAY_URL,
      ...(options == null ? void 0 : options.walletConnectReceiver) === true ? {} : options == null ? void 0 : options.walletConnectReceiver
    };
    this._wcMetadata = defaultWCReceiverConfig.walletConnectWalletMetadata;
    this._core = new Br({
      projectId: defaultWCReceiverConfig.walletConnectV2ProjectId,
      relayUrl: defaultWCReceiverConfig.walletConnectV2RelayUrl
    });
  }
  async init() {
    this._wcWallet = await ie4.init({
      core: this._core,
      metadata: this._wcMetadata
    });
    const sessions = this._wcWallet.getActiveSessions();
    const keys2 = Object.keys(sessions);
    if (keys2[0]) {
      this._session = sessions[keys2[0]];
    }
    this._setupWalletConnectEventsListeners();
  }
  async connectApp(wcUri) {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await this._wcWallet.core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession() {
    var _a2;
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!this._activeProposal) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await this.wallet.getAddress();
    const {
      id,
      params
    } = this._activeProposal;
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach((key) => {
      var _a3;
      const accounts = [];
      const namespace = requiredNamespaces[key];
      if (namespace) {
        (_a3 = namespace.chains) == null ? void 0 : _a3.map((chain) => {
          accounts.push(`${chain}:${account}`);
        });
        namespaces[key] = {
          accounts,
          methods: namespace.methods,
          events: namespace.events
        };
      }
    });
    this._session = await this._wcWallet.approveSession({
      id,
      relayProtocol: (_a2 = relays[0]) == null ? void 0 : _a2.protocol,
      namespaces
    });
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!this._activeProposal) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = this._activeProposal;
    await this._wcWallet.rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request() {
    var _a2, _b;
    if (!this._activeRequestEvent) {
      return;
    }
    const {
      topic,
      params,
      id
    } = this._activeRequestEvent;
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = this._getSignParamsMessage(request.params);
        const signedMessage = await this.wallet.signMessage(message || "");
        response = formatJsonRpcResult(id, signedMessage);
        break;
      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:
      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:
      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:
      //   const {
      //     domain,
      //     types,
      //     message: data,
      //   } = getSignTypedDataParamsData(request.params);
      //   // https://github.com/ethers-io/ethers.js/issues/687#issuecomment-714069471
      //   delete types.EIP712Domain;
      //   const signedData = await wallet._signTypedData(domain, types, data);
      //   return formatJsonRpcResult(id, signedData);
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await this.wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = formatJsonRpcResult(id, transactionHash);
        break;
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await this.wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = formatJsonRpcResult(id, signature);
        break;
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return (_a2 = this._wcWallet) == null ? void 0 : _a2.respondSessionRequest({
          topic,
          response: error
        });
    }
    return (_b = this._wcWallet) == null ? void 0 : _b.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    var _a2;
    if (!this._activeRequestEvent) {
      return;
    }
    const {
      topic,
      id
    } = this._activeRequestEvent;
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return (_a2 = this._wcWallet) == null ? void 0 : _a2.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = this._wcWallet.getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const session = sessions[sessionKey];
      if (session) {
        const topic = session.topic;
        const peerMeta = session.peer.metadata;
        thisSessions.push({
          topic,
          peer: {
            metadata: peerMeta
          }
        });
      }
    }
    return thisSessions;
  }
  disconnectSession() {
    var _a2;
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!this._session) {
      return Promise.resolve();
    }
    const params = {
      topic: this._session.topic,
      reason: {
        message: "User disconnected.",
        code: 6e3
      }
    };
    return (_a2 = this._wcWallet) == null ? void 0 : _a2.disconnectSession(params);
  }
  _setupWalletConnectEventsListeners() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    this._wcWallet.on("session_proposal", (proposal) => {
      this._activeProposal = proposal;
      this.emit("session_proposal", {
        proposer: {
          metadata: proposal.params.proposer.metadata
        }
      });
    });
    this._wcWallet.on("session_delete", (session) => {
      this._session = void 0;
      this._activeProposal = void 0;
      this.emit("session_delete", {
        topic: session.topic
      });
    });
    this._wcWallet.on("session_request", async (requestEvent) => {
      if (!this._session) {
        return;
      }
      const {
        params: requestParams
      } = requestEvent;
      const {
        request
      } = requestParams;
      const {
        params
      } = request;
      switch (request.method) {
        case EIP155_SIGNING_METHODS.ETH_SIGN:
        case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
          this._activeRequestEvent = requestEvent;
          const message = params[0];
          const decodedMessage = new TextDecoder().decode(utils_exports.arrayify(message));
          const paramsCopy = [...params];
          paramsCopy[0] = decodedMessage;
          this.emit("session_request", {
            topic: this._session.topic,
            params: paramsCopy,
            peer: {
              metadata: this._session.peer.metadata
            },
            method: request.method
          });
          return;
        case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
          this._activeRequestEvent = requestEvent;
          this.emit("session_request", {
            topic: this._session.topic,
            params: requestEvent.params.request.params,
            peer: {
              metadata: this._session.peer.metadata
            },
            method: request.method
          });
          return;
        default:
          throw new Error(`WCV2.Method not supported: ${request.method}`);
      }
    });
  }
  /**
   * Gets message from various signing request methods by filtering out
   * a value that is not an address (thus is a message).
   * If it is a hex string, it gets converted to utf8 string
   */
  _getSignParamsMessage(params) {
    const message = params.filter((p5) => !utils_exports.isAddress(p5))[0] || "";
    if (utils_exports.isHexString(message)) {
      return utils_exports.toUtf8String(message);
    }
    return message;
  }
};

export {
  EIP155_SIGNING_METHODS,
  AsyncLocalStorage,
  createAsyncLocalStorage,
  DEFAULT_DAPP_META,
  isWalletAnalyticsEnabled,
  setWalletAnalyticsEnabled,
  AbstractClientWallet,
  BloctoWallet,
  EmbeddedWallet,
  MetaMaskWallet,
  OKXWallet,
  CoreWallet,
  OneKeyWallet,
  CryptoDefiWallet,
  RabbyWallet,
  Coin98Wallet,
  getInjectedCoinbaseProvider,
  EngineSigner,
  EngineWallet,
  PaperWallet,
  CoinbaseWallet,
  EthersWallet,
  FrameWallet,
  ImTokenWallet,
  InjectedWallet,
  LocalWallet,
  isValidPrivateKey,
  SignerWallet,
  MagicLink,
  XDEFIWallet,
  PhantomWallet,
  PrivateKeyWallet,
  RainbowWallet,
  SafeWallet,
  getAllSigners,
  getAllSmartWallets,
  isSmartWalletDeployed,
  getSmartWalletAddress,
  getUserOpReceipt,
  SmartWallet,
  TrustWallet,
  WalletConnect,
  WalletConnectV1,
  ZerionWallet,
  TokenBoundSmartWallet,
  MagicEdenWallet,
  LocalStorage,
  createLocalStorage,
  WalletConnectHandler,
  WalletConnectV2Handler
};
/*! Bundled license information:

@walletconnect/utils/dist/index.es.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@walletconnect/utils/dist/index.es.js:
  (**
  * [js-sha3]{@link https://github.com/emn178/js-sha3}
  *
  * @version 0.8.0
  * @author Chen, Yi-Cyuan [emn178@gmail.com]
  * @copyright Chen, Yi-Cyuan 2015-2018
  * @license MIT
  *)
*/
//# sourceMappingURL=chunk-EWM7BAHA.js.map
