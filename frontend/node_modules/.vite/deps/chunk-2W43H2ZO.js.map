{
  "version": 3,
  "sources": ["../../@thirdweb-dev/sdk/node_modules/thirdweb/src/rpc/actions/eth_getTransactionReceipt.ts", "../../@thirdweb-dev/sdk/node_modules/thirdweb/src/rpc/actions/eth_blockNumber.ts", "../../@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/watchBlockNumber.js", "../../@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/wait-for-tx-receipt.js"],
  "sourcesContent": [null, null, "import { eth_blockNumber } from \"./actions/eth_blockNumber.js\";\nimport { getRpcClient } from \"./rpc.js\";\nconst MAX_POLL_DELAY = 5000; // 5 seconds\nconst DEFAULT_POLL_DELAY = 1000; // 1 second\nconst MIN_POLL_DELAY = 500; // 500 milliseconds\nconst DEFAULT_OVERPOLL_RATIO = 2; // poll twice as often as the average block time by default\nconst SLIDING_WINDOW_SIZE = 10; // always keep track of the last 10 block times\n/**\n * TODO: document\n * @internal\n */\nfunction getAverageBlockTime(blockTimes) {\n    // left-pad the blocktimes Array with the DEFAULT_POLL_DELAY\n    while (blockTimes.length < SLIDING_WINDOW_SIZE) {\n        blockTimes.unshift(DEFAULT_POLL_DELAY);\n    }\n    const sum = blockTimes.reduce((acc, blockTime) => acc + blockTime, 0);\n    return sum / blockTimes.length;\n}\n/**\n * TODO: document\n * @internal\n */\nfunction createBlockNumberPoller(client, chain, overPollRatio, onError) {\n    let subscribers = [];\n    let blockTimesWindow = [];\n    let isActive = false;\n    let lastBlockNumber;\n    let lastBlockAt;\n    const rpcRequest = getRpcClient({ client, chain });\n    /**\n     * TODO: document\n     * @internal\n     */\n    async function poll() {\n        // stop polling if there are no more subscriptions\n        if (!isActive) {\n            return;\n        }\n        try {\n            const blockNumber = await eth_blockNumber(rpcRequest);\n            if (!lastBlockNumber || blockNumber > lastBlockNumber) {\n                let newBlockNumbers = [];\n                if (lastBlockNumber) {\n                    for (let i = lastBlockNumber + 1n; i <= blockNumber; i++) {\n                        newBlockNumbers.push(BigInt(i));\n                    }\n                }\n                else {\n                    newBlockNumbers = [blockNumber];\n                }\n                lastBlockNumber = blockNumber;\n                const currentTime = new Date().getTime();\n                if (lastBlockAt) {\n                    // if we skipped a block we need to adjust the block time down to that level\n                    const blockTime = (currentTime - lastBlockAt) / newBlockNumbers.length;\n                    blockTimesWindow.push(blockTime);\n                    blockTimesWindow = blockTimesWindow.slice(-SLIDING_WINDOW_SIZE);\n                }\n                lastBlockAt = currentTime;\n                // for all new blockNumbers...\n                for (const b of newBlockNumbers) {\n                    // ... call all current subscribers\n                    for (const subscriberCallback of subscribers) {\n                        subscriberCallback(b);\n                    }\n                }\n            }\n        }\n        catch (err) {\n            if (onError) {\n                onError(err);\n            }\n            else {\n                console.error(`[watchBlockNumber]: Failed to poll for latest block number: ${err}`);\n            }\n        }\n        const currentApproximateBlockTime = getAverageBlockTime(blockTimesWindow);\n        // make sure we never poll faster than our minimum poll delay or slower than our maximum poll delay\n        const pollDelay = Math.max(MIN_POLL_DELAY, Math.min(MAX_POLL_DELAY, Math.max(MIN_POLL_DELAY, currentApproximateBlockTime)));\n        // sleep for the pollDelay for this chain (divided by the overPollRatio, which defaults to 2)\n        await sleep(pollDelay / (overPollRatio ?? DEFAULT_OVERPOLL_RATIO));\n        // poll again\n        poll();\n    }\n    // return the \"subscribe\" function\n    return function subscribe(callBack, initialBlockNumber) {\n        subscribers.push(callBack);\n        // if we are currently not active -> start polling\n        if (!isActive) {\n            lastBlockNumber = initialBlockNumber;\n            isActive = true;\n            poll();\n        }\n        // return the \"unsubscribe\" function (meaning the caller can unsubscribe)\n        return function unSubscribe() {\n            // filter out the callback from the subscribers\n            subscribers = subscribers.filter((fn) => fn !== callBack);\n            // if the new subscribers Array is empty (aka we were the last subscriber) -> stop polling\n            if (subscribers.length === 0) {\n                lastBlockNumber = undefined;\n                lastBlockAt = undefined;\n                isActive = false;\n            }\n        };\n    };\n}\n/**\n * TODO: document\n * @internal\n */\nfunction sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\nconst existingPollers = new Map();\n/**\n * Watches the block number for a specific chain.\n * @param opts - The options for watching the block number.\n * @returns The unwatch function.\n * @example\n * ```ts\n * import { watchBlockNumber } from \"thirdweb\";\n * const unwatch = watchBlockNumber({\n *  client,\n *  chainId,\n *  onNewBlockNumber: (blockNumber) => {\n *    // do something with the block number\n *  },\n *  onError: (err) => {\n *    // do something if getting the block number fails\n *  },\n * });\n *\n * // later stop watching\n * unwatch();\n * ```\n * @rpc\n */\nexport function watchBlockNumber(opts) {\n    const { client, chain, onNewBlockNumber, overPollRatio, latestBlockNumber, onError, } = opts;\n    const chainId = chain.id;\n    // if we already have a poller for this chainId -> use it.\n    let poller = existingPollers.get(chainId);\n    // otherwise create a new poller\n    if (!poller) {\n        poller = createBlockNumberPoller(client, chain, overPollRatio, onError);\n        // and store it for later use\n        existingPollers.set(chainId, poller);\n    }\n    // subscribe to the poller and return the unSubscribe function to the caller\n    return poller(onNewBlockNumber, latestBlockNumber);\n}\n//# sourceMappingURL=watchBlockNumber.js.map", "import { eth_getTransactionReceipt } from \"../../rpc/actions/eth_getTransactionReceipt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { watchBlockNumber } from \"../../rpc/watchBlockNumber.js\";\nexport const DEFAULT_MAX_BLOCKS_WAIT_TIME = 30;\nconst map = new Map();\n/**\n * Waits for the transaction receipt of a given transaction hash on a specific contract.\n * @param options - The options for waiting for the receipt.\n * By default, it's 30 blocks.\n * @returns A promise that resolves with the transaction receipt.\n * @transaction\n * @example\n * ```ts\n * import { waitForReceipt } from \"thirdweb\";\n * const receipt = await waitForReceipt({\n *   client,\n *   chain,\n *   transactionHash: \"0x123...\",\n * });\n * ```\n */\nexport function waitForReceipt(options) {\n    const { transactionHash, chain, client } = options;\n    const chainId = chain.id;\n    const key = `${chainId}:tx_${transactionHash}`;\n    const maxBlocksWaitTime = options.maxBlocksWaitTime ?? DEFAULT_MAX_BLOCKS_WAIT_TIME;\n    if (map.has(key)) {\n        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n        return map.get(key);\n    }\n    const promise = new Promise((resolve, reject) => {\n        if (!transactionHash) {\n            reject(new Error(\"Transaction has no transactionHash to wait for, did you execute it?\"));\n        }\n        const request = getRpcClient({ client, chain });\n        // start at -1 because the first block doesn't count\n        let blocksWaited = -1;\n        const unwatch = watchBlockNumber({\n            client: client,\n            chain: chain,\n            onNewBlockNumber: async () => {\n                blocksWaited++;\n                if (blocksWaited >= maxBlocksWaitTime) {\n                    unwatch();\n                    reject(new Error(`Transaction not found after ${maxBlocksWaitTime} blocks`));\n                    return;\n                }\n                try {\n                    const receipt = await eth_getTransactionReceipt(request, {\n                        hash: transactionHash,\n                    });\n                    // stop the polling\n                    unwatch();\n                    // resolve the top level promise with the receipt\n                    resolve(receipt);\n                }\n                catch {\n                    // noop, we'll try again on the next blocks\n                }\n            },\n        });\n        // remove the promise from the map when it's done (one way or the other)\n    }).finally(() => {\n        map.delete(key);\n    });\n    map.set(key, promise);\n    return promise;\n}\n//# sourceMappingURL=wait-for-tx-receipt.js.map"],
  "mappings": "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",
  "names": []
}
