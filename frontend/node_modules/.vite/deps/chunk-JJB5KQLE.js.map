{
  "version": 3,
  "sources": ["../../@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/promise/withCache.js", "../../@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/chains/utils.js", "../../@thirdweb-dev/sdk/node_modules/thirdweb/src/rpc/fetch-rpc.ts", "../../@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/rpc.js"],
  "sourcesContent": ["// copy of: https://github.com/wevm/viem/blob/6cf2c3b5fe608bce9c828af867dfaa65103753a6/src/utils/promise/withCache.ts\n// with slight adjustments made to comply with our linting rules\n// TODO: explore extracting this from viem and instead having a separate general purpose library for this kind of thing\n// alternatively viem could maybe export this helpful util\n// TODO: explore using a LRU cache instead of a Map\nconst promiseCache = /*#__PURE__*/ new Map();\nconst responseCache = /*#__PURE__*/ new Map();\n/**\n *@internal\n */\nexport function getCache(cacheKey) {\n    const buildCache = (cacheKey_, cache) => ({\n        clear: () => cache.delete(cacheKey_),\n        get: () => cache.get(cacheKey_),\n        set: (data) => cache.set(cacheKey_, data),\n    });\n    const promise = buildCache(cacheKey, promiseCache);\n    const response = buildCache(cacheKey, responseCache);\n    return {\n        clear: () => {\n            promise.clear();\n            response.clear();\n        },\n        promise,\n        response,\n    };\n}\n/**\n * Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n * @internal\n */\nexport async function withCache(fn, { cacheKey, cacheTime = Number.POSITIVE_INFINITY }) {\n    const cache = getCache(cacheKey);\n    // If a response exists in the cache, and it's not expired, return it\n    // and do not invoke the promise.\n    // If the max age is 0, the cache is disabled.\n    const response = cache.response.get();\n    if (response && cacheTime > 0) {\n        const age = new Date().getTime() - response.created.getTime();\n        if (age < cacheTime) {\n            return response.data;\n        }\n    }\n    let promise = cache.promise.get();\n    if (!promise) {\n        promise = fn();\n        // Store the promise in the cache so that subsequent invocations\n        // will wait for the same promise to resolve (deduping).\n        cache.promise.set(promise);\n    }\n    try {\n        const data = await promise;\n        // Store the response in the cache so that subsequent invocations\n        // will return the same response.\n        cache.response.set({ created: new Date(), data });\n        return data;\n    }\n    finally {\n        // Clear the promise cache so that subsequent invocations will\n        // invoke the promise again.\n        cache.promise.clear();\n    }\n}\n//# sourceMappingURL=withCache.js.map", "import { DEFAULT_RPC_URL, getThirdwebDomains } from \"../utils/domains.js\";\nimport { isThirdwebUrl } from \"../utils/fetch.js\";\nimport { withCache } from \"../utils/promise/withCache.js\";\nconst CUSTOM_CHAIN_MAP = new Map();\n/**\n * Defines a chain with the given options.\n * @param options The options for the chain.\n * @returns The defined chain.\n * @example\n * Just pass the chain ID to connect to:\n * ```ts\n * const chain = defineChain(1);\n * ```\n * Or pass your own RPC or custom values:\n * ```ts\n * const chain = defineChain({\n *  id: 1,\n *  rpc: \"https://my-rpc.com\",\n *  nativeCurrency: {\n *    name: \"Ether\",\n *    symbol: \"ETH\",\n *    decimals: 18,\n *  },\n * });\n * ```\n * @chain\n */\nexport function defineChain(options) {\n    if (typeof options === \"number\") {\n        return {\n            id: options,\n            rpc: `https://${options}.rpc.thirdweb.com`,\n        };\n    }\n    if (isViemChain(options)) {\n        return convertViemChain(options);\n    }\n    if (isLegacyChain(options)) {\n        return convertLegacyChain(options);\n    }\n    // otherwise if it's not a viem chain, continue\n    let rpc = options.rpc;\n    if (!rpc) {\n        rpc = `https://${options.id}.rpc.thirdweb.com`;\n    }\n    const chain = { ...options, rpc };\n    CUSTOM_CHAIN_MAP.set(options.id, chain);\n    return chain;\n}\n/**\n * @internal\n */\nexport function getCachedChain(id) {\n    if (CUSTOM_CHAIN_MAP.has(id)) {\n        return CUSTOM_CHAIN_MAP.get(id);\n    }\n    const chain = {\n        id: id,\n        rpc: `https://${id}.rpc.thirdweb.com`,\n    };\n    return chain;\n}\nfunction isLegacyChain(chain) {\n    return \"rpc\" in chain && Array.isArray(chain.rpc) && \"slug\" in chain;\n}\nfunction convertLegacyChain(legacyChain) {\n    const c = {\n        id: legacyChain.chainId,\n        name: legacyChain.name,\n        rpc: legacyChain.rpc[0] ?? `https://${legacyChain.chainId}.rpc.thirdweb.com`,\n        blockExplorers: legacyChain?.explorers?.map((explorer) => ({\n            name: explorer.name,\n            url: explorer.url,\n            apiUrl: explorer.url,\n        })),\n        nativeCurrency: {\n            name: legacyChain.nativeCurrency.name,\n            symbol: legacyChain.nativeCurrency.symbol,\n            decimals: legacyChain.nativeCurrency.decimals,\n        },\n    };\n    if (legacyChain.testnet) {\n        return { ...c, testnet: true };\n    }\n    return c;\n}\nfunction isViemChain(chain) {\n    return \"rpcUrls\" in chain && !(\"rpc\" in chain);\n}\nfunction convertViemChain(viemChain) {\n    return defineChain({\n        id: viemChain.id,\n        name: viemChain.name,\n        nativeCurrency: {\n            name: viemChain.nativeCurrency.name,\n            symbol: viemChain.nativeCurrency.symbol,\n            decimals: viemChain.nativeCurrency.decimals,\n        },\n        rpc: viemChain.rpcUrls.default.http[0] ??\n            `https://${viemChain.id}.rpc.thirdweb.com`,\n        blockExplorers: viemChain?.blockExplorers\n            ? Object.values(viemChain?.blockExplorers).map((explorer) => {\n                return {\n                    name: explorer.name,\n                    url: explorer.url,\n                    apiUrl: explorer.apiUrl,\n                };\n            })\n            : [],\n    });\n}\n/**\n * Retrieves the RPC URL for the specified chain.\n * If a custom RPC URL is defined in the options, it will be used.\n * Otherwise, a thirdweb RPC URL will be constructed using the chain ID and client ID.\n * @param options - The options object containing the chain and client information.\n * @returns The RPC URL for the specified chain.\n * @example\n * ```ts\n * import { getRpcUrlForChain } from \"thirdweb/chains\";\n * const rpcUrl = getRpcUrlForChain({ chain: 1, client });\n * console.log(rpcUrl); // \"https://1.rpc.thirdweb.com/...\n * ```\n * @chain\n */\nexport function getRpcUrlForChain(options) {\n    const baseRpcUrl = getThirdwebDomains().rpc;\n    // if the chain is just a number, construct the RPC URL using the chain ID and client ID\n    if (typeof options.chain === \"number\") {\n        return `https://${options.chain}.${baseRpcUrl}/${options.client.clientId}`;\n    }\n    const { rpc } = options.chain;\n    // add on the client ID to the RPC URL if it's a thirdweb URL\n    if (isThirdwebUrl(rpc)) {\n        const rpcUrl = new URL(options.chain.rpc.replace(DEFAULT_RPC_URL, baseRpcUrl));\n        rpcUrl.pathname = `/${options.client.clientId}`;\n        return rpcUrl.toString();\n    }\n    return rpc;\n}\n/**\n * Retrieves the chain symbol from the provided chain.\n * @param chain - The chain.\n * @returns The chain symbol.\n * @internal\n */\nexport async function getChainSymbol(chain) {\n    if (!chain.nativeCurrency?.symbol) {\n        return getChainMetadata(chain)\n            .then((data) => data.nativeCurrency.symbol)\n            .catch(() => {\n            // if we fail to fetch the chain data, return \"ETH\" as a fallback\n            return \"ETH\";\n        });\n    }\n    // if we have a symbol, return it\n    return chain.nativeCurrency.symbol;\n}\n/**\n * Retrieves the number of decimals for the native currency of a given chain.\n * If the chain is not recognized or the data cannot be fetched, it returns a fallback value of 18.\n * @param chain - The chain for which to retrieve the decimals.\n * @returns A promise that resolves to the number of decimals for the native currency of the chain.\n * @internal\n */\nexport async function getChainDecimals(chain) {\n    if (!chain.nativeCurrency?.decimals) {\n        return getChainMetadata(chain)\n            .then((data) => data.nativeCurrency.decimals)\n            .catch(() => {\n            // if we fail to fetch the chain data, return 18 as a fallback (most likely it's 18)\n            return 18;\n        });\n    }\n    // if we have decimals, return it\n    return chain.nativeCurrency.decimals;\n}\n/**\n * Retrieves the name of the native currency for a given chain.\n * If the chain object does not have a native currency name, it attempts to fetch the chain data and retrieve the native currency name from there.\n * If fetching the chain data fails, it falls back to returning \"ETH\".\n * @param chain The chain object for which to retrieve the native currency name.\n * @returns A promise that resolves to the native currency name.\n * @internal\n */\nexport async function getChainNativeCurrencyName(chain) {\n    if (!chain.nativeCurrency?.name) {\n        return getChainMetadata(chain)\n            .then((data) => data.nativeCurrency.name)\n            .catch(() => {\n            // if we fail to fetch the chain data, return 18 as a fallback (most likely it's 18)\n            return \"ETH\";\n        });\n    }\n    // if we have a name, return it\n    return chain.nativeCurrency.name;\n}\n/**\n * Retrieves chain data for a given chain.\n * @param chain - The chain object containing the chain ID.\n * @returns A Promise that resolves to the chain data.\n * @throws If there is an error fetching the chain data.\n * @example\n * ```ts\n * const chain = defineChain({ id: 1 });\n * const chainData = await getChainMetadata(chain);\n * console.log(chainData);\n * ```\n * @chain\n */\nexport function getChainMetadata(chain) {\n    const chainId = chain.id;\n    return withCache(async () => {\n        try {\n            const res = await fetch(`https://api.thirdweb.com/v1/chains/${chainId}`);\n            if (!res.ok) {\n                res.body?.cancel();\n                throw new Error(`Failed to fetch chain data for chainId ${chainId}`);\n            }\n            const response = (await res.json());\n            if (response.error) {\n                throw new Error(`Failed to fetch chain data for chainId ${chainId}`);\n            }\n            if (!response.data) {\n                throw new Error(`Failed to fetch chain data for chainId ${chainId}`);\n            }\n            const data = response.data;\n            return createChainMetadata(chain, data);\n        }\n        catch {\n            return createChainMetadata(chain);\n        }\n    }, {\n        cacheKey: `chain:${chainId}`,\n        cacheTime: 5 * 60 * 1000, // 5 minutes\n    });\n}\n/**\n * Convert `ApiChain` to `Chain` object\n * @internal\n */\nexport function convertApiChainToChain(apiChain) {\n    return {\n        id: apiChain.chainId,\n        name: apiChain.name,\n        rpc: apiChain.rpc[0] || \"\",\n        testnet: apiChain.testnet === true ? true : undefined,\n        nativeCurrency: apiChain.nativeCurrency,\n        blockExplorers: apiChain.explorers?.map((explorer) => {\n            return {\n                name: explorer.name,\n                url: explorer.url,\n                apiUrl: explorer.url,\n            };\n        }),\n    };\n}\nfunction createChainMetadata(chain, data) {\n    const nativeCurrency = chain.nativeCurrency\n        ? {\n            ...data?.nativeCurrency,\n            ...chain.nativeCurrency,\n        }\n        : data?.nativeCurrency;\n    return {\n        ...data,\n        name: chain.name || data?.name || \"\",\n        chainId: chain.id || data?.chainId || -1,\n        rpc: chain.rpc ? [chain.rpc] : data?.rpc || [\"\"],\n        testnet: chain.testnet || data?.testnet || false,\n        nativeCurrency: {\n            name: nativeCurrency?.name || \"\",\n            symbol: nativeCurrency?.symbol || \"\",\n            decimals: nativeCurrency?.decimals || 18,\n        },\n        icon: chain.icon || data?.icon,\n        chain: data?.chain || chain.name || \"\",\n        shortName: data?.shortName || chain.name || \"\",\n        slug: data?.slug || chain.name || \"\",\n        explorers: chain.blockExplorers?.map((e) => ({\n            name: e.name,\n            url: e.url,\n            standard: \"EIP3091\",\n        })) || data?.explorers,\n    };\n}\n//# sourceMappingURL=utils.js.map", null, "import { getRpcUrlForChain } from \"../chains/utils.js\";\nimport { fetchRpc, fetchSingleRpc } from \"./fetch-rpc.js\";\nconst RPC_CLIENT_MAP = new WeakMap();\n/**\n * @internal\n */\nfunction getRpcClientMap(client) {\n    if (RPC_CLIENT_MAP.has(client)) {\n        return RPC_CLIENT_MAP.get(client);\n    }\n    const rpcClientMap = new Map();\n    RPC_CLIENT_MAP.set(client, rpcClientMap);\n    return rpcClientMap;\n}\n/**\n * @internal\n */\nfunction rpcRequestKey(request) {\n    return `${request.method}:${JSON.stringify(request.params)}`;\n}\nconst DEFAULT_MAX_BATCH_SIZE = 100;\n// default to no timeout (next tick)\nconst DEFAULT_BATCH_TIMEOUT_MS = 0;\n/**\n * Returns an RPC request that can be used to make JSON-RPC requests.\n * @param options - The RPC options.\n * @returns The RPC request function.\n * @rpc\n * @example\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n * import { getRpcClient } from \"thirdweb/rpc\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const rpcRequest = getRpcClient({ client, chain: ethereum, });\n * const blockNumber = await rpcRequest({\n *  method: \"eth_blockNumber\",\n * });\n * ```\n */\nexport function getRpcClient(options) {\n    const rpcClientMap = getRpcClientMap(options.client);\n    const chainId = options.chain.id;\n    if (rpcClientMap.has(options.chain.rpc)) {\n        return rpcClientMap.get(options.chain.rpc);\n    }\n    const rpcClient = (() => {\n        // we can do this upfront because it cannot change later\n        const rpcUrl = getRpcUrlForChain({\n            client: options.client,\n            chain: options.chain,\n        });\n        const batchSize = \n        // look at the direct options passed\n        options.config?.maxBatchSize ??\n            // look at the client options\n            options.client.config?.rpc?.maxBatchSize ??\n            // use defaults\n            DEFAULT_MAX_BATCH_SIZE;\n        const batchTimeoutMs = \n        // look at the direct options passed\n        options.config?.batchTimeoutMs ??\n            // look at the client options\n            options.client.config?.rpc?.batchTimeoutMs ??\n            DEFAULT_BATCH_TIMEOUT_MS;\n        // inflight requests\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        const inflightRequests = new Map();\n        let pendingBatch = [];\n        let pendingBatchTimeout = null;\n        /**\n         * Sends the pending batch of requests.\n         * @internal\n         */\n        function sendPendingBatch() {\n            // clear the timeout if any\n            if (pendingBatchTimeout) {\n                clearTimeout(pendingBatchTimeout);\n                pendingBatchTimeout = null;\n            }\n            // prepare the requests array (we know the size)\n            const requests = new Array(pendingBatch.length);\n            const activeBatch = pendingBatch.slice().map((inflight, index) => {\n                // assign the id to the request\n                inflight.request.id = index;\n                // also assign the jsonrpc version\n                inflight.request.jsonrpc = \"2.0\";\n                // assing the request to the requests array (so we don't have to map it again later)\n                requests[index] = inflight.request;\n                return inflight;\n            });\n            // reset pendingBatch to empty\n            pendingBatch = [];\n            fetchRpc(rpcUrl, options.client, {\n                requests,\n                requestTimeoutMs: options.config?.requestTimeoutMs,\n            })\n                .then((responses) => {\n                // for each response, resolve the inflight request\n                activeBatch.forEach((inflight, index) => {\n                    const response = responses[index];\n                    // if we didn't get a response at all, reject the inflight request\n                    if (!response) {\n                        inflight.reject(new Error(\"No response\"));\n                        return;\n                    }\n                    // handle errors in the response\n                    if (response instanceof Error) {\n                        inflight.reject(response);\n                        return;\n                    }\n                    // handle strings as responses??\n                    if (typeof response === \"string\") {\n                        inflight.reject(new Error(response));\n                        return;\n                    }\n                    if (\"error\" in response) {\n                        inflight.reject(response.error);\n                        // otherwise, resolve the inflight request\n                    }\n                    else if (response.method === \"eth_subscription\") {\n                        // TODO: handle subscription responses\n                        throw new Error(\"Subscriptions not supported yet\");\n                    }\n                    else {\n                        inflight.resolve(response.result);\n                    }\n                    // remove the inflight request from the inflightRequests map\n                    inflightRequests.delete(inflight.requestKey);\n                });\n            })\n                .catch((err) => {\n                // http call failed, reject all inflight requests\n                for (const inflight of activeBatch) {\n                    inflight.reject(err);\n                    // remove the inflight request from the inflightRequests map\n                    inflightRequests.delete(inflight.requestKey);\n                }\n            });\n        }\n        // shortcut everything if we do not need to batch\n        if (batchSize === 1) {\n            return async (request) => {\n                // we can hard-code the id and jsonrpc version\n                // we also mutate the request object here to avoid copying it\n                // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n                request.id = 1;\n                // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n                request.jsonrpc = \"2.0\";\n                const rpcResponse = await fetchSingleRpc(rpcUrl, options.client, {\n                    request: request,\n                    requestTimeoutMs: options.config?.requestTimeoutMs,\n                });\n                if (!rpcResponse) {\n                    throw new Error(\"No response\");\n                }\n                if (\"error\" in rpcResponse) {\n                    throw rpcResponse.error;\n                }\n                return rpcResponse.result;\n            };\n        }\n        return async (request) => {\n            const requestKey = rpcRequestKey(request);\n            // if the request for this key is already inflight, return the promise directly\n            if (inflightRequests.has(requestKey)) {\n                // biome-ignore lint/style/noNonNullAssertion: the `has` check ensures this is defined\n                return inflightRequests.get(requestKey);\n            }\n            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n            let resolve;\n            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n            let reject;\n            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n            const promise = new Promise((resolve_, reject_) => {\n                resolve = resolve_;\n                reject = reject_;\n            });\n            inflightRequests.set(requestKey, promise);\n            // @ts-expect-error - they *are* definitely assgined within the promise constructor\n            pendingBatch.push({ request, resolve, reject, requestKey });\n            if (batchSize > 1) {\n                // if there is no timeout, set one\n                if (!pendingBatchTimeout) {\n                    pendingBatchTimeout = setTimeout(sendPendingBatch, batchTimeoutMs);\n                }\n                // if the batch is full, send it\n                if (pendingBatch.length >= batchSize) {\n                    sendPendingBatch();\n                }\n            }\n            else {\n                sendPendingBatch();\n            }\n            return promise;\n        };\n    })();\n    rpcClientMap.set(chainId, rpcClient);\n    return rpcClient;\n}\n//# sourceMappingURL=rpc.js.map"],
  "mappings": "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",
  "names": ["_a"]
}
